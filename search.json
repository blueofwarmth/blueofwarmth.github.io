[{"title":"Hexo 搭建过程记录","path":"/2024/06/04/Hexo-搭建过程记录/","content":"intro使用 GitHub Pages 来搭建 Hexo 静态博客网站，其最吸引人的莫过于完全免费使用，并且非常稳定（网络问题除外）。 距离第一次搭建hexo博客已经过去好几年了, 由于这玩意第一次部署还是稍微有点麻烦, 比较折腾, 但配置好后还是比较稳定的, 这次自己记录下全过程, 免得每次再网上搜来搜去. 为了照顾小白用户（第一次使用 GitHub 和 Hexo），尽可能详细的写（包括常见的坑和问题都有提示说明），并且多配图片。看起来有点繁杂，捋顺了其实也简单. GitHub Pages 是什么 ?GitHub Pages 是什么？具体解答可以看 GitHub 官方提供的介绍：What is GitHub Pages? – GitHub Help 简单点说 GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。 Hexo是什么 ?Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档快速解析渲染成静态的 HTML 网页。 官网：hexo.io 详细部署方式参考：文档 | Hexo 准备本地环境你需要在本地电脑上面安装： nodejs（&gt;16 版本，最新的应该有 20 版本）：Node.js — Run JavaScript Everywhere git（2.44.0）：Git – Downloads 安装的时候无脑 next 即可。安装完毕以后，可以在 cmd 里面通过：node -v、npm -v 和 git --version 查看安装的版本。正常情况应该有如下输出： 准备GitHUb我们在 GitHub 上面注册一个 free 账号 网络不好的话最好开个TiZi 创建一个GitHub仓库我们在自己 GitHub 的主页 repository 中点击右上角的 New： 填写基本信息 Repository name 中输入用户名.github.io，一定要是这个名字！** 勾选 Add a README file 填好后点击 Create repository 创建仓库。 现在我们访问 https://用户名.github.io（我就是: blueofwarmth.github.io）可以看到默认界面： 本地测试连接GitHub在某一个盘里面创建一个文件夹，名字叫 hexo（好记），然后右键选择 Open Git Bash Here 不出意外的话(但愿没有)应该会弹出一个命令行界面 在里面输入: git config --global user.name &quot;你的 GitHub 用户名&quot;git config --global user.email &quot;你的 GitHub 邮箱&quot; 创建SSH密钥ssh-keygen -t rsa -C &quot;你的 GitHub 邮箱&quot; 什么都不用管，猛猛回车就行。然后我们进入 C:\\Users\\ 用户名 \\.ssh 目录（勾选显示 “隐藏的项目”） 我们用记事本打开id_rsa.pub并复制里面的内容。 在GitHub中添加SSH密钥回到 GitHub，进入 Settings： 选择左边栏的 SSH and GPG keys，点击 New SSH key： Title 随便取，然后把 id_rsa.pub 里面的内容到复制到 Key 中， 默认设置, 然后点击 Add SSH key 保存完毕以后，我们可以在本地验证一下连接 验证连接ssh -T git@github.com 出现 “Are you sure……”，输入 yes 回车确认。 若出现下图的提示即连接成功： 本地安装Hexo我们在已经创建好的文件夹内，同样右键点击 Open Git Bash Here，然后使用 npm 安装 Hexo。在命令行中输入： npm install -g hexo-cli 由于网络问题，安装时间可能会有点久。这段时间里面界面不会有任何反应，请耐心等待，安装完成后会提示： 检查一下 hexo -version 初始化Hexo我们在创建好的 hexo 文件夹内，再新建一个文件夹用来存放 hexo 博客程序。 然后在上面的命令行窗口（git）中输入 hexo init # 初始化hexonpm install # 安装组件 由于网络问题，初始化的时间可能会有点久，耐心等待即可。当出现下图提示的时候，说明已经完成了 初始化完毕以后，我们可以在 hexo 程序文件夹中看到 hexo 程序文件。 预览效果hexo g # 生成页面 生成页面需要等待一会儿，一般一两秒就完成了。 现在生成的是默认的 hexo 博客（主题），我们可以先本地访问一下看看效果。 hexo s # 启动预览 如果提示是否允许专用网络啥的，直接允许就可以。然后我们访问 http://localhost:4000 就可以访问 hexo 了： 上传Hexo到Github我们需要先安装 hexo-deployer-git： npm install hexo-deployer-git --save 然后修改_config.yml 文件末尾的 Deployment 部分： 在这里: 修改成&#96;&#96;如下（修改为你的用户名与仓库名） deploy: type: git repo: git@github.com:blueofwarmth/blueofwarmth.github.io.git branch: gh-pages 其实就是通过 SSH 进行连接，SSH 连接地址可以 直接在仓库 &lt;&gt;Code 里面看到： 保存修改, 然后上传 hexo cl &amp;&amp; hexo d 出现下面的提示说明已经把网站上传到 GitHub 了： 如果出错了就检查下配置文件内容, GitHub仓库名这些. 然后我们需要在库设置（Repository Settings）中将默认分支设置为_config.yml 配置中的分支名称。 然后在 pages 页面调整源分支： 不出意外的话是不会出意外的，稍等片刻我们访问用户名.github.io（比如夜梦这里就是 blueofwarmth.github.io）就可以看到默认 hexo 了。","tags":["笔记","学习"],"categories":["技术"]},{"title":"Java基础复习","path":"/2024/05/04/八股文Java基础/","content":"Java基础Java SE vs Java EE Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。 Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。 JVM vs JDK vs JREJVMJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。使用相同的字节码，它们都会给出相同的结果 JDK 和 JREJDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。 JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。 为什么说 Java 语言 “编译与解释并存”？编译型：编译型语言 open in new window 会通过 编译器 open in new window 将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。 解释型：解释型语言 open in new window 会通过 解释器 open in new window 一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。 为什么说 Java 语言 “编译与解释并存”？ 因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。 包装类型的缓存机制了解么？Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。 自动装箱与拆箱了解吗？原理是什么？什么是自动拆装箱？ 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 从字节码中，我们发现装箱其实就是调用了 包装类的 valueOf() 方法，拆箱其实就是调用了 xxxValue() 方法。 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？关于深拷贝和浅拷贝区别，我这里先给结论： 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。 HashCode () 有什么用？hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。 散列表存储的是键值对 (key-value)，它的特点是：能根据 “键” 快速的检索出对应的 “值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 String, StringBuffer and StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 String.intern()使用 String.intern () 可以保证相同内容的字符串变量引用同一的内存对象。 String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();System.out.println(s1.intern() == s3); // true//如果是&quot;&quot;创建的, 会自动放入poolString s4 = &quot;bbb&quot;;String s5 = &quot;bbb&quot;;System.out.println(s4 == s5); // true 存在继承的情况下，初始化顺序为: 父类 (静态变量、静态语句块) 子类 (静态变量、静态语句块) 父类 (实例变量、普通语句块) 父类 (构造函数) 子类 (实例变量、普通语句块) 子类 (构造函数) 反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类: Field : 可以使用 get () 和 set () 方法读取和修改 Field 对象关联的字段； Method : 可以使用 invoke () 方法调用与 Method 对象关联的方法； Constructor : 可以用 Constructor 创建新的对象。 反射基础这里我们首先需要理解 Class 类，以及类的加载机制； 然后基于此我们如何通过反射获取 Class 类以及类中的成员变量、方法、构造方法等。 Class类Class 类，Class 类也是一个实实在在的类，存在于 JDK 的 java.lang 包中。Class 类的实例表示 java 应用运行时的类 (class ans enum) 或接口 (interface and annotation), 每个 java 类运行时都在 JVM 里表现为一个 class 对象，可通过类名.class、类型.getClass ()、Class.forName (“类名”) 等方法获取 class 对象。 类加载 类加载机制流程 类的加载 反射使用在 Java 中，Class 类与 java.lang.reflect 类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有 Constructor 类表示的是 Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field 表示 Class 对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值 (包含 private)、Method 表示 Class 对象所表示的类的成员方法，通过它可以动态调用对象的方法 (包含 private)，下面将对这几个重要类进行分别说明。 class类对象的获取在类加载的时候，jvm 会创建一个 class 对象 class 对象是可以说是反射中最常用的，获取 class 对象的方式的主要有三种 根据类名：类名.class 根据对象：对象.getClass () 根据全限定类名：Class.forName (全限定类名) class类的方法 方法名 说明 forName() (1) 获取 Class 对象的一个引用，但该类的第一个对象没有生成就加载了这个类。 (2) 为了产生 Class 引用，forName () 立即就进行了初始化 getName() 取全限定的类名 (包括包名)，即类的完整名字。 isInterface() 判断 Class 对象是否是表示一个接口 getInterfaces() 返回 Class 对象数组，表示 Class 对象所引用的类所实现的所有接口。 newInstance() 返回一个 Oject 对象，是实现 “虚拟构造器” 的一种途径。使用该方法创建的类，必须带有无参的构造器。 getFields() 获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有 getMethods 和 getConstructors。 getDeclaredFields 获得某个类的自己声明的字段，即包括 public、private 和 proteced，默认但是不包括父类声明的任何字段。类似的还有 getDeclaredMethods 和 getDeclaredConstructors。 Constructor类及其用法获取 Constructor 对象是通过 Class 类中的方法获取的，Class 类与 Constructor 相关的主要方法如下： 方法返回值 方法名称 方法说明 static Class&lt;?&gt; forName(String className) 返回与带有给定字符串名的类或接口相关联的 Class 对象。 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回指定参数类型、具有 public 访问权限的构造函数对象 Constructor&lt;?&gt;[] getConstructors() 返回所有具有 public 访问权限的构造函数的 Constructor 对象数组 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回指定参数类型、所有声明的（包括 private）构造函数对象 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有声明的（包括 private）构造函数对象 T newInstance() 调用无参构造器创建此 Class 对象所表示的类的一个新实例。 Field类及其用法Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段 Class类与Field对象相关的方法如下: 方法返回值 方法名称 方法说明 Field getDeclaredField(String name) 获取指定 name 名称的 (包含 private 修饰的) 字段，不包括继承的字段 Field[] getDeclaredFields() 获取 Class 对象所表示的类或接口的所有 (包含 private 修饰的) 字段，不包括继承的字段 Field getField(String name) 获取指定 name 名称、具有 public 修饰的字段，包含继承字段 Field[] getFields() 获取修饰符为 public 的字段，包含继承字段 Method类及其用法 方法返回值 方法名称 方法说明 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个指定参数的 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口的公共 member 方法。 反射机制执行的流程Java中的反射机制允许在运行时检查类、对象和方法，并在运行时操作类的属性、方法和构造函数。反射机制执行的一般流程如下： 获取Class对象：首先需要获取要操作的类的Class对象。可以通过以下方式之一获取Class对象： 调用对象的getClass()方法。 使用.class语法获取类字面常量的Class对象。 使用Class类的静态方法forName()根据类的全限定名获取Class对象。 创建对象（可选）：如果需要实例化该类的对象，则可以通过反射机制调用Class对象的newInstance()方法来创建对象。这个方法会调用类的无参构造函数来创建对象。 获取类的属性、方法、构造函数等信息：通过Class对象可以获取类的属性、方法、构造函数等信息。常见的方法包括： getFields()：获取类的公共字段。 getDeclaredFields()：获取类的所有字段，包括私有字段。 getMethods()：获取类的公共方法。 getDeclaredMethods()：获取类的所有方法，包括私有方法。 getConstructors()：获取类的公共构造函数。 getDeclaredConstructors()：获取类的所有构造函数，包括私有构造函数。 操作属性、方法、构造函数：获取了类的属性、方法、构造函数等信息后，可以通过反射机制来动态地操作它们。例如： 设置或获取对象的属性值。 调用对象的方法。 创建对象的实例。 调用对象的构造函数。 异常处理：在使用反射机制时，需要注意处理可能抛出的异常，如ClassNotFoundException、NoSuchMethodException、IllegalAccessException等。 性能考虑：由于反射机制会在运行时进行类型检查和方法调用，因此可能会导致性能损失。在需要高性能的场景下，应谨慎使用反射机制。 总的来说，反射机制允许在运行时动态地获取类的信息并操作类的属性和方法，为程序提供了更大的灵活性和扩展性。但同时也需要注意异常处理和性能问题。 异常 异常申明当前执行的语句必属于某个方法，Java 解释器调用 main 方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字 throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。 注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。 Throws抛出异常的规则： 如果是不可查异常（unchecked exception），即 Error、RuntimeException 或它们的子类，那么可以不使用 throws 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。 必须声明任何可查异常（checked exception）。要么用 try-catch 语句捕获，要么用 throws 子句声明将它抛出，否则会导致编译错误 当抛出了异常当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。 异常抛出如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。 public static double method(int value) &#123; if(value == 0) &#123; throw new ArithmeticException(&quot;参数不能为0&quot;); //抛出一个运行时异常 &#125; return 5.0 / value;&#125; 有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。 private static void readFile(String filePath) throws MyException &#123; try &#123; // code &#125; catch (IOException e) &#123; MyException ex = new MyException(&quot;read file failed.&quot;); ex.initCause(e); throw ex; &#125;&#125; 自定义异常public class MyException extends Exception &#123; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125; // ... 执行顺序 泛型 Java 在语法上支持泛型，但是在编译阶段会进行所谓的 “类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。 为什么要有泛型 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。 也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 引入泛型的意义在于： 适用于多种数据类型执行相同的代码（代码复用） 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型） 泛型类 属性类型 参数类型 返回值类型 class Point&lt;T&gt;&#123; // 此处可以随便写标识符号，T是type的简称 private T var ; // var的类型由T指定，即：由外部指定 public T getVar()&#123; // 返回值的类型由外部决定 return var ; &#125; public void setVar(T var)&#123; // 设置的类型也由外部决定 this.var = var ; &#125; &#125; 泛型接口interface Info&lt;T&gt;&#123; // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 &#125; class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123; // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var)&#123; // 通过构造方法设置属性内容 this.setVar(var) ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; &#125; 泛型方法public static &lt; E &gt; void printArray( E[] inputArray )&#123; for ( E element : inputArray )&#123; System.out.printf( &quot;%s &quot;, element ); &#125; System.out.println(); &#125; 注意: public static &lt; E &gt; void printArray( E[] inputArray ) 一般被称为静态泛型方法； 在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，所以静态泛型方法是没有办法使用class类上声明的泛型的。只能使用自己声明的 &lt;E&gt; 注解注解是 JDK1.5 版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面： 生成文档，通过代码里标识的元数据生成 javadoc 文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。 这么来说是比较抽象的，我们具体看下注解的常见分类： Java 自带的标准注解，包括 @Override、@Deprecated 和 @SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。 元注解，元注解是用于定义注解的注解，@Retention 用于标明注解被保留的阶段，@Target 用于标明注解使用的范围，@Inherited 用于标明注解可继承，@Documented 用于标明是否生成 javadoc 文档。 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。 SPI机制SPI（Service Provider Interface），是 JDK 内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如 java.sql.Driver 接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL 和 PostgreSQL 都有不同的实现提供给用户，而 Java 的 SPI 机制可以为某个接口寻找服务实现。 Java 中 SPI 机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。 当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。 当其他的程序需要这个服务的时候，就可以通过查找这个 jar 包（一般都是以 jar 包做依赖）的 META-INF/services/ 中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK 中查找服务的实现的工具类是：java.util.ServiceLoader 定义一个接口 几个类实现 在文件目录下加载 ServiceLoader.load加载遍历 SPI 和 API 的区别是什么 这里实际包含两个问题，第一个 SPI 和 API 的区别？第二个什么时候用 API，什么时候用 SPI？ SPI - “接口” 位于 “调用方” 所在的 “包” 中 概念上更依赖调用方。 组织上位于调用方所在的包中。 实现位于独立的包中。 常见的例子是：插件模式的插件。 API - “接口” 位于 “实现方” 所在的 “包” 中 概念上更接近实现方。 组织上位于实现方所在的包中。 实现和接口在一个包中。 SPI 机制的缺陷通过上面的解析，可以发现，我们使用 SPI 机制的缺陷： 不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。 获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。 多个并发多线程使用 ServiceLoader 类的实例是不安全 Java集合框架 List(对付顺序的好帮手): 存储的元素是有序的、可重复的。 Set(注重独一无二的性质): 存储的元素不可重复的。 Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f (x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 ArrayList源码分析 ArrayList 实现了 List 接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入 null 元素，底层通过数组实现。 自动扩容默认为, 第一次添加后为10. 数组进行扩容时，会将老数组中的元素重新拷贝(Arrays.copyOf)一份到新的数组中，每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。 // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; // 将oldCapacity 右移一位，其效果相当于oldCapacity /2， // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); HashMap源码分析JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， HashMap 总是使用 2 的幂作为哈希表的大小 底层结构1.7HashMap 通过 key S的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突. 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 1.8相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。 当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin() 方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。 oadFactor 负载因子 loadFactor 负载因子是控制数组存放数据的疏密程度 loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。 threshold(阈值) threshold &#x3D; capacity * loadFactor， 当 Size&gt;threshold 的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准 put /** * 如果既要遍历key又要value，如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。 * 一次是在获取keySet的时候，一次是在遍历所有key的时候。 */ // 而当我调用put(key,value)方法的时候，首先会把key和value封装到 // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取 // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来 // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了 Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue()); &#125; 并发编程并发三要素 可见性 一个线程对共享变量的修改，另外一个线程能够立刻看到。 原子性: 分时复用引起 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 有序性 程序执行的顺序按照代码的先后顺序执行。 何为线程？线程与进程相似，但线程是一个比进程更小的执行单位。 一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 总结： 线程是进程划分成的更小的运行单位。 线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。 并发和并行 并发：两个及两个以上的作业在同一 时间段 内执行。 并行：两个及两个以上的作业在同一 时刻 执行。 最关键的点是：是否是 同时 执行。 同步和异步的区别 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。 异步：调用在发出之后，不用等待返回结果，该调用直接返回。 为什么要使用多线程？先从总体上来说： 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 如何理解线程安全和不安全？线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失 如何创建线程？一般来说，创建线程有很多种方式，例如继承 Thread 类、实现 Runnable 接口、实现 Callable 接口、使用线程池、使用 CompletableFuture 类等等。 不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。 严格来说，Java 就只有一种方式可以创建线程，那就是通过 new Thread().start() 创建。不管是哪种方式，最终还是依赖于 new Thread().start()。 线程的生命周期和状态 当线程执行 wait() 方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。 TIMED_WAITING (超时等待)状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。 线程进入 synchronized 方法 &#x2F; 块或者被 notify调用 wait重新进入 synchronized 方法 &#x2F; 块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。 什么是线程上下文切换？线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。 主动让出 CPU，比如调用了 sleep(), wait() 等。 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。 被终止或结束运行 这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换 什么是线程死锁？如何避免死锁？认识线程死锁多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态 产生死锁的四个必要条件： 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 如何预防和避免线程死锁？ 预防 上面234 避免 避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。 sleep () 方法和 wait () 方法对比共同点：两者都可以暂停线程的执行。 区别： sleep() 方法没有释放锁，而 wait() 方法释放了锁 。 wait() 通常被用于线程间交互 &#x2F; 通信，sleep() 通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。 sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法 wait () 方法不定义在 Thread 中？wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。而每个对象（Object）都拥有对象锁，自然是要操作对应的对象（Object）而非当前的线程（Thread）。 可以直接调用 Thread 类的 run 方法吗？new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 JavaIO Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 字节流InputStream一般不会单独使用, 而是配合BufferedInputStream // 新建一个 BufferedInputStream 对象BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;));// 读取文件的内容并复制到 String 对象中String result = new String(bufferedInputStream.readAllBytes());System.out.println(result);//DataInputStreamFileInputStream fileInputStream = new FileInputStream(&quot;input.txt&quot;);//必须将fileInputStream作为构造参数才能使用DataInputStream dataInputStream = new DataInputStream(fileInputStream);//可以读取任意具体的类型数据dataInputStream.readBoolean();dataInputStream.readInt();dataInputStream.readUTF();//ObjectInputStreamObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;object.data&quot;));MyClass object = (MyClass) input.readObject();input.close(); OutputStreamFileOutputStream output = new FileOutputStream(&quot;output.txt&quot;);byte[] array = &quot;JavaGuide&quot;.getBytes();output.write(array);//配合bufferFileOutputStream fileOutputStream = new FileOutputStream(&quot;output.txt&quot;);BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream) //Data输出流, 指定写入类型FileOutputStream fileOutputStream = new FileOutputStream(&quot;out.txt&quot;);DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream);// 输出任意数据类型dataOutputStream.writeBoolean(true);dataOutputStream.writeByte(1);//ObjectObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;file.txt&quot;);Person person = new Person(&quot;Guide哥&quot;, &quot;JavaGuide作者&quot;);output.writeObject(person); 字符流 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。 如果我们不知道编码类型就很容易出现乱码问题。 ReaderInputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。 // 字节流转换为字符流的桥梁public class InputStreamReader extends Reader &#123;&#125;// 用于读取字符文件public class FileReader extends InputStreamReader &#123;&#125;FileReader fileReader = new FileReader(&quot;input.txt&quot;);int content;long skip = fileReader.skip(3);System.out.println(&quot;The actual number of bytes skipped:&quot; + skip);System.out.print(&quot;The content read from file:&quot;);while ((content = fileReader.read()) != -1) &#123; System.out.print((char) content);&#125; Writerpublic class OutputStreamWriter extends Writer &#123;&#125;// 用于写入字符到文件public class FileWriter extends OutputStreamWriter &#123;&#125;Writer output = new FileWriter(&quot;output.txt&quot;);output.write(&quot;你好，我是Guide。&quot;); 字节缓冲流如果是调用 read(byte b[]) 和 write(byte b[], int off, int len) 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。 @Testvoid copy_pdf_to_another_pdf_with_byte_array_buffer_stream() &#123; // 记录开始时间 long start = System.currentTimeMillis(); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;深入理解计算机操作系统.pdf&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;深入理解计算机操作系统-副本.pdf&quot;))) &#123; int len; byte[] bytes = new byte[4 * 1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;使用缓冲流复制PDF文件总耗时:&quot; + (end - start) + &quot; 毫秒&quot;);&#125;@Testvoid copy_pdf_to_another_pdf_with_byte_array_stream() &#123; // 记录开始时间 long start = System.currentTimeMillis(); try (FileInputStream fis = new FileInputStream(&quot;深入理解计算机操作系统.pdf&quot;); FileOutputStream fos = new FileOutputStream(&quot;深入理解计算机操作系统-副本.pdf&quot;)) &#123; int len; byte[] bytes = new byte[4 * 1024]; while ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;使用普通流复制PDF文件总耗时:&quot; + (end - start) + &quot; 毫秒&quot;);&#125; 打印流System.out.print(&quot;Hello！&quot;);System.out.println(&quot;Hello！&quot;); system.out 实际是用于获取一个 PrintStream 对象，print 方法实际调用的是 PrintStream 对象的 write 方法。 PrintStream 属于字节打印流，与之对应的是 PrintWriter （字符打印流）。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。 设计模式装饰器模式装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流）和 FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和 OutputStream 子类对象的功能。 我们常见的 BufferedInputStream(字节缓冲输入流)、DataInputStream 等等都是 FilterInputStream 的子类 BufferedInputStream 的构造函数其中的一个参数就是 InputStream 例子: 创建一个接口 Shape，定义了原始对象和装饰器对象的公共接口或抽象类。 创建实现接口的实体类，例如 Rectangle 和 Circle。 创建一个抽象装饰类 ShapeDecorator，它继承自 Shape 接口，并包含了一个抽象组件对象（即原始形状对象）。 创建扩展了 ShapeDecorator 类的具体装饰类，例如 RedShapeDecorator，它实现了抽象装饰器的接口，并在原始形状的基础上添加了新的功能（例如设置红色边框）。 使用具体装饰器来装饰原始形状对象，从而动态地增加新的功能。 // 步骤 1：创建一个接口 Shapepublic interface Shape &#123; void draw();&#125;// 步骤 2：创建实现接口的实体类 Rectangle 和 Circle// 步骤 3：创建抽象装饰类 ShapeDecoratorpublic abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape) &#123; this.decoratedShape = decoratedShape; &#125; public void draw() &#123; decoratedShape.draw(); &#125;&#125;// 步骤 4：创建具体装饰类 RedShapeDecoratorpublic class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape) &#123; System.out.println(&quot;Border Color: Red&quot;); &#125;&#125;// 步骤 5：使用 RedShapeDecorator 来装饰 Shape 对象public class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(&quot;Circle with normal border&quot;); circle.draw(); System.out.println(&quot; Circle of red border&quot;); redCircle.draw(); System.out.println(&quot; Rectangle of red border&quot;); redRectangle.draw(); &#125;&#125; 工厂模式 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定对应的具体类。 例如，汽车可以分为轿车、SUV、MPV 等，也分为奔驰、宝马等。我们可以将奔驰的所有车看作是一个产品族，而将宝马的所有车看作是另一个产品族。分别对应两个工厂，一个是奔驰的工厂，另一个是宝马的工厂。与工厂方法不同，奔驰的工厂不只是生产具体的某一个产品，而是一族产品（奔驰轿车、奔驰 SUV、奔驰 MPV）。 “抽象工厂” 的 “抽象” 指的是就是这个意思。 即相比于工厂方法，抽象工厂定义了一系列的产品，而不是一个产品。 上边的工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广。 图示 观察者模式 观察者模式是一种行为型设计模式，它定义了一种多种的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，底座自动通知依赖它的对象。观察者模式属于行为类型模式。 NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。 监听文件创建, 删除, 修改 观察者模式包含以下几个核心角色： 被观察者（Subject）:它是具有状态的对象，并着一个观察者列表。维护主题提供了添加、删除和通知观察者的方法。 观察者（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。 具体被观察者（Concrete subject）：具体主题是主题的具体实现类。它着眼于观察者列表，并在状态发生改变时维护通知观察者。 具体观察者（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。 // 步骤 1：创建 Subject 类public class Subject &#123; //装观察者 private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); private int state; public setState(int state) &#123; this.state = state; notifyAllObservers(); &#125; public void attach(Observer observer) &#123; observers.add(observer); &#125; public void notifyAllObservers() &#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125;&#125;// 步骤 2：创建 Observer 类public abstract class Observer &#123; protected Subject subject; public abstract void update();&#125;// 步骤 3：创建实体观察者类public class BinaryObserver extends Observer &#123; public BinaryObserver(Subject subject) &#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println(&quot;Binary String: &quot; + Integer.toBinaryString(subject.getState())); &#125; // 类似地，创建 OctalObserver 和 HexaObserver 类&#125;// 步骤 4：使用 Subject 和实体观察者对象public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); new BinaryObserver(subject); new OctalObserver(subject); new HexaObserver(subject); System.out.println(&quot;First state change: 15&quot;); subject.setState(15); System.out.println(&quot;Second state change: 10&quot;); subject.setState(10); &#125;&#125; 适配器模式适配器（Adapter Pattern）模式 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。 适配器模式中存在被适配的对象或者类称为 适配者 (Adaptee) ，作用于适配者的对象或者类称为适配器 (Adapter) 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。 IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。 InputStreamReader 和 OutputStreamWriter 就是两个适配器 (Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。InputStreamReader 使用 StreamDecoder （流解码器）对字节进行解码，实现字节流到字符流的转换， OutputStreamWriter 使用 StreamEncoder（流编码器）对字符进行编码，实现字符流到字节流的转换。 InputStream 和 OutputStream 的子类是被适配者， InputStreamReader 和 OutputStreamWriter 是适配器。 适配器模式和装饰器模式有什么区别呢？ 装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。 适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 StreamDecoder （流解码器）和 StreamEncoder（流编码器）就是分别基于 InputStream 和 OutputStream 来获取 FileChannel 对象并调用对应的 read 方法和 write 方法进行字节数据的读取和写入。 IO 模型BIO同步阻塞模型 NIO同步非阻塞 同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。 这种 IO 模型同样存在问题：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。 这个时候，I&#x2F;O 多路复用模型 就上场了。 线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。 通过selector, 只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。 AIO异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 NIONIO 主要包括以下三个核心组件： Buffer（缓冲区）：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。 Channel（通道）：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。 Selector（选择器）：允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。 Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 flip() 可以切换到读模式。如果要再次切换回写模式，可以调用 clear() 或者 compact() 方法。 BUffer Buffer的各种状态 Channel 最常用的是以下几种类型的通道： FileChannel：文件访问通道； SocketChannel、ServerSocketChannel：TCP 通信通道； DatagramChannel：UDP 通信通道； //写文件RandomAccessFile reader = new RandomAccessFile(&quot;/Users/guide/Documents/test_read.in&quot;, &quot;r&quot;))FileChannel channel = reader.getChannel();ByteBuffer buffer = ByteBuffer.allocate(1024);channel.read(buffer); SelectorSelector 是基于事件驱动的 I&#x2F;O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。 NIO零拷贝指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I&#x2F;O 操作时频繁复制数据的问题。 JVM 逻辑关系 JVM基础-类字节码多种语言编译为字节码在JVM运行Java 代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的 JVM 虚拟机去读取执行，从而实现一次编写，到处运行的目的。 JVM 也不再只支持 Java，由此衍生出了许多基于 JVM 的编程语言，如 Groovy, Scala, Koltin 等等。 Java字节码文件class文件结构属性 类加载机制类的生命周期其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，*而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定 (也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载 查找并加载类的二进制数据 验证 确保被加载的类的正确性 准备 为类的静态变量分配内存, 并将其初始化 解析 把类中的符号引用转化为直接引用(直接指向目标的指针) 初始化 为类变量指定初始值 使用静态代码块为类变量指定初始值 加载机制 全盘负责，当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。 双亲委派机制 , 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上 自定义加载器通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类 JVM内存结构运行时数据区 jvm的整体架构, 中间为Java虚拟机定义的各种运行时数据区域 程序计数器程序计数寄存器（Program Counter Register），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。 这里，并非是广义上所指的物理寄存器，JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 作用寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。 概述 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined） 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 设为私有, 保证每个线程独立计算, 不相互影响 虚拟机栈主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。 存储单位 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在 在这个线程上正在执行的每个方法都各自有对应的一个栈帧 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息 运行原理 JVM 直接对 Java 栈的操作只有两个，对栈帧的压栈和出栈，遵循 “先进后出 &#x2F; 后进先出” 原则 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class） 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧 如果当前方法调用了其他方法在方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧 Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出 栈内 局部变量表 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用 操作数栈 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。 动态链接 主要服务一个方法需要调用其他方法的场景 方法返回地址 来存放调用该方法的 PC 寄存器的值。 本地方法栈和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 堆Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。 为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）： 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对像 方法区方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。 当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、即时编译器编译后的代码缓存等数据。 运行时常量池Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表 (Constant Pool Table) 。 字符串常量池字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 // 在堆中创建字符串对象”ab“// 将字符串对象”ab“的引用保存在字符串常量池中String aa = &quot;ab&quot;;// 直接返回字符串常量池中字符串对象”ab“的引用String bb = &quot;ab&quot;;System.out.println(aa==bb);// true 垃圾回收堆空间的基本结构Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。 JDK 8 版本之后 PermGen (永久) 已被 Metaspace (元空间) 取代，元空间使用的是直接内存 内存分配和回收原则对象优先在eden区分配, 当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 大对象直接进入老年代大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。 大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。 长期存活的对象直接进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1 对象在 Survivor 中每熬过一次 MinorGC, 年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。 总结： 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种： 部分收集 (Partial GC)： 新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 空间分配担保空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。 对象死亡判断方法引用计数器给对象中添加一个引用计数器： 每当有一个地方引用它，计数器就加 1； 当引用失效，计数器就减 1； 任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用 可达性分析算法这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。 下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象 引用类型总结无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与 “引用” 有关。 强引用 前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题 软引用 如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存 弱引用 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存 虚引用 “虚引用” 顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。 在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 如何判断一个常量时废弃常量 ? JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是 hotspot 中的永久代 。 假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。 如何判断一个类是无用的类 ? 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法标记-清除算法标记 - 清除（Mark-and-Sweep）算法分为 “标记（Mark）” 和 “清除（Sweep）” 阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。 它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题： 效率问题：标记和清除两个过程效率都不高。 空间问题：标记清除后会产生大量不连续的内存碎片。 复制算法它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 虽然改进了标记 - 清除算法，但依然存在下面这些问题： 可用内存变小：可用内存缩小为原来的一半。 不适合老年代：如果存活对象数量比较大，复制性能会变得很差 标记-整理算法根据老年代的特点提出的一种标记算法，标记过程仍然与 “标记 - 清除” 算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景 分代收集算法当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器 Java8新特性","tags":["Java"],"categories":["记录"]},{"title":"Servlet & JSP","path":"/2024/02/07/Servlet-JSP/","content":"ServletServlet 是 Java EE（Enterprise Edition）平台的一部分，它是在服务器端运行的 Java 应用程序组件，用于扩展服务器的功能。Servlet 主要用于创建动态的、基于 Web 的应用程序，能够接收和响应来自客户端（通常是 Web 浏览器）的 HTTP 请求。 Servlet 的特点和用途包括： 处理 HTTP 请求：Servlet 可以处理来自客户端的各种类型的 HTTP 请求，例如 GET、POST、PUT、DELETE 等。 动态内容生成：Servlet 可以生成动态的内容，例如 HTML 页面、XML 数据、JSON 等，以响应客户端的请求。 与数据库交互：Servlet 可以连接到数据库，并执行查询、更新等操作，以提供基于数据库的动态内容。 与其他服务器端技术集成：Servlet 可以与其他 Java EE 技术（如 JSP、EJB）一起使用，以构建复杂的企业级应用程序。 处理会话管理：Servlet 可以管理用户的会话状态，例如跟踪用户的登录状态、购物车内容等。 安全性：Servlet 可以实现安全控制，例如对访问资源的权限进行验证，以保护应用程序免受未经授权的访问。 Servlet 是基于 Java 编写的，并且与特定的服务器环境相关联，例如常见的 Servlet 容器包括 Apache Tomcat、Jetty、IBM WebSphere 等。Servlet 的生命周期由容器管理，容器负责加载、初始化、调用和销毁 Servlet 实例。 关于系统架构系统架构包括什么形式？ C&#x2F;S架构 B&#x2F;S架构 C&#x2F;S架构？ Client &#x2F; Server（客户端 &#x2F; 服务器） C&#x2F;S架构的软件或者说系统有哪些呢？ QQ（先去腾讯官网下载一个QQ软件，几十MB，然后把这个客户端软件安装上去，然后输入QQ号以及密码，登录之后，就可以和你的朋友聊天了，就可以使用这个软件了。） C&#x2F;S架构的特点：需要安装特定的客户端软件。 C&#x2F;S架构的系统优点和缺点分别是什么？ 优点： 速度快（软件中的数据大部分都是集成到客户端软件当中的，很少量的数据从服务器端传送过来，所以C&#x2F;S结构的系统速度快） 体验好（速度又快，界面又酷炫，当然体验好了。） 界面酷炫（专门的语言去实现界面的，更加灵活。） 服务器压力小（因为大量的数据都是集成在客户端软件当中，所以服务器只需要传送很少的数据量，当然服务器压力小。） 安全（因为大量的数据是集成在客户端软件当中的，并且客户端有很多个，服务器虽然只有一个，就算服务器那边地震了，火灾了，服务器受损了，问题也不大，因为大量的数据在多个客户端上有缓存，有存储，所以从这个方面来说，C&#x2F;S结构的系统比较安全。） ….. 缺点： 升级维护比较差劲。（升级维护比较麻烦。成本比较高。每一个客户端软件都需要升级。有一些软件不是那么容易安装的。） B&#x2F;S架构？ B&#x2F;S（Browser &#x2F; Server，浏览器 &#x2F; 服务器） http://www.baidu.com http://www.jd.com http://www.126.com B&#x2F;S结构的系统是不是一个特殊的C&#x2F;S系统？ 实际上B&#x2F;S结构的系统还是一个C&#x2F;S，只不过这个C比较特殊，这个Client是一个固定不变浏览器软件。 B&#x2F;S结构的系统优点和缺点是： 优点： 升级维护方便，成本比较低。（只需要升级服务器端即可。） 不需要安装特定的客户端软件，用户操作极其方便。只需要打开浏览器，输入网址即可。 缺点： 速度慢（不是因为带宽低的问题，是因为所有的数据都是在服务器上，用户发送的每一个请求都是需要服务器全身心的响应数据，所以B&#x2F;S结构的系统在网络中传送的数据量比较大。） 体验差（界面不是那么酷炫，因为浏览器只支持三个语言HTML CSS JavaScript。在加上速度慢。） 不安全（所有的数据都在服务器上，只要服务器发生火灾，地震等不可抗力，最终数据全部丢失。） …. C&#x2F;S和B&#x2F;S结构的系统，哪个好，哪个不好？ 这个问题问的没有水平。并不是哪个好，哪个不好。不同结构的系统在不同的业务场景下有不同的适用场景。 娱乐性软件建议使用？ C&#x2F;S 结构 公司内部使用的一些业务软件建议使用？ 公司内部使用的系统，需要维护成本低。 公司内部使用的系统，不需要很酷炫。 公司内部使用的企业级系统主要是能够进行数据的维护即可。 B&#x2F;S 结构。 注意了：开发B&#x2F;S结构的系统，其实就是开发网站，其实就是开发一个WEB系统。 开发一个WEB系统你需要会哪些技术？ WEB前端（运行在浏览器上的程序。） HTML CSS JavaScript WEB后端（WEB服务器端的程序。） Java可以（Java做WEB开发我们称为JavaWEB开发。JavaWEB开发最核心的规范：Servlet【Server Applet服务器端的Java小程序。】） C语言也可以 C++也可以 Python也行 PHP也可以 …. JavaEE是什么？Java包括三大块： JavaSE Java标准版（一套类库：别人写好的一套类库，只不过这个类库是标准类库，走EE，或者走ME，这个SE一定是基础，先学。） JavaEE（WEB方向，WEB系统。） Java企业版（也是一套类库：也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。） 别人写好的，你用就行了，用它可以开发企业级项目。 可以开发web系统。 Java比较火爆的就是这个JavaEE方向。 JavaME Java微型版（还是一套类库，只不过这套类库帮助我们进行电子微型设备内核程序的开发） 机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序。。。。。 JavaEE实际上包括很多种规范，13种规范，其中Servlet就是JavaEE规范之一。学Servlet还是Java语言。 B&#x2F;S结构的系统通信原理（没有涉及到Java小程序）WEB系统的访问过程 第一步：打开浏览器 第二步：找到地址栏 第三步：输入一个合法的网址 第四步：回车 第五步：在浏览器上会展示响应的结果。 关于域名： https://www.baidu.com/ （网址） www.baidu.com 是一个域名 在浏览器地址栏上输入域名，回车之后，域名解析器会将域名解析出来一个具体的IP地址和端口号等。 解析结果也许是：http://110.242.68.3:80/index.html P地址是啥？ 计算机在网络当中的一个身份证号。在同一个网络当中，IP地址是唯一的。 A计算机要想和B计算机通信，首先你需要知道B计算机的IP地址，有了IP地址才能建立连接。 端口号是啥？ 一个端口代表一个软件（一个端口代表一个应用，一个端口仅代表一个服务）。 一个计算机当中有很多软件，每一个软件启动之后都有一个端口号。 在同一个计算机上，端口号具有唯一性。 一个WEB系统的通信原理？通信步骤： 第一步：用户输入网址（URL） 第二步：域名解析器进行域名解析：http://110.242.68.3:80/index.html 第三步：浏览器软件在网络中搜索110.242.68.3这一台主机，直到找到这台主机。 第四步：定位110.242.68.3这台主机上的服务器软件，因为是80端口，可以很轻松的定位到80端口对应的服务器软件。 第五步：80端口对应的服务器软件得知浏览器想要的资源名是：index.html 第六步：服务器软件找到index.html文件，并且将index.html文件中的内容直接输出响应到浏览器上。 第七步：浏览器接收到来自服务器的代码（HTML CSS JS） 第八步：浏览器渲染，执行HTML CSS JS代码，展示效果。 什么是URL？ 统一资源定位符（http://www.baidu.com） 什么是请求，什么是响应？ 请求和响应实际上说的是数据的流向不同。 从Browser端发送数据到Server端，我们称为请求。英语单词：request 从Server端向浏览器Browser端发送数据，我们称为响应。英语单词：response B –&gt; S （请求request） S –&gt; B （响应response） 关于WEB服务器软件WEB服务器软件都有哪些呢？ Tomcat（WEB服务器） jetty（WEB服务器） JBOSS（应用服务器） WebLogic（应用服务器） WebSphere（应用服务器） 应用服务器和WEB服务器的关系？ 应用服务器实现了JavaEE的所有规范。(JavaEE有13个不同的规范。) WEB服务器只实现了JavaEE中的Servlet + JSP两个核心的规范。 通过这个讲解说明了：应用服务器是包含WEB服务器的。 Tomcat配置下载 apache官网地址：https://www.apache.org/ tomcat官网地址：https://tomcat.apache.org tomcat开源免费的轻量级WEB服务器。 tomcat还有另外一个名字：catalina（catalina是美国的一个岛屿，风景秀丽，据说作者是在这个风景秀丽的小岛上开发了一个轻量级的WEB服务器，体积小，运行速度快，因此tomcat又被称为catalina） tomcat的logo是一只公猫（寓意表示Tomcat服务器是轻巧的，小巧的，果然，体积小，运行速度快，只实现了Servlet+JSP规范） tomcat是java语言写的。 tomcat服务器要想运行，必须先又jre（Java的运行时环境） Tomcat服务器的安装： 启动Tomcat bin目录下有一个文件：startup.bat,通过它可以启动Tomcat服务器。 xxx.bat文件是个什么文件？ bat文件是windows操作系统专用的，bat文件是批处理文件，这种文件中可以编写大量的windows的dos命令，然后执行bat文件就相当于批量的执行dos命令。 startup.sh，这个文件在windows当中无法执行，在Linux环境当中可以使用。在Linux环境下能够执行的是shell命令，大量的shell命令编写在shell文件当中，然后执行这个shell文件可以批量的执行shell命令。 tomcat服务器提供了bat和sh文件，说明了这个tomcat服务器的通用性。 分析startup.bat文件得出，执行这个命令，实际上最后是执行：catalina.bat文件。 catalina.bat文件中有这样一行配置： MAINCLASS&#x3D;org.apache.catalina.startup.Bootstrap （这个类就是main方法所在的类） tomcat服务器就是Java语言写的，既然是java语言写的，那么启动Tomcat服务器就是执行main方法。 我们尝试打开dos命令窗口，在dos命令窗口中输入startup.bat来启动tomcat服务器。 启动Tomcat服务器只配置path对应的bin目录是不行的。有两个环境变量需要配置： JAVA_HOME&#x3D;JDK的根 CATALINA_HOME&#x3D;Tomcat服务器的根 关于Tomcat服务器的目录 bin ： 这个目录是Tomcat服务器的命令文件存放的目录，比如：启动Tomcat，关闭Tomcat等。 conf： 这个目录是Tomcat服务器的配置文件存放目录。（server.xml文件中可以配置端口号，默认Tomcat端口是8080） lib ：这个目录是Tomcat服务器的核心程序目录，因为Tomcat服务器是Java语言编写的，这里的jar包里面都是class文件。 logs: Tomcat服务器的日志目录，Tomcat服务器启动等信息都会在这个目录下生成日志文件。 temp：Tomcat服务器的临时目录。存储临时文件。 webapps：这个目录当中就是用来存放大量的webapp（web application：web应用） work：这个目录是用来存放JSP文件翻译之后的java文件以及编译之后的class文件。 配置Tomcat服务器需要哪些环境变量？ JAVA_HOME&#x3D;JDK的根 CATALINA_HOME&#x3D;Tomcat服务器的根 PATH&#x3D;%JAVA_HOME%\\bin;%CATALINA_HOME%\\bin 启动Tomcat： startup 关闭Tomcat：stop （shutdown.bat文件重命名为stop.bat，为什么？原因是shutdown命令和windows中的关机命令冲突。所以修改一下。） 怎么测试Tomcat服务器有没有启动成功呢？ 打开浏览器，在浏览器的地址栏上输入URL即可： http://ip地址:端口号 实现一个最基本的web应用（这个web应用中没有java小程序）第一步：找到CATALINA_HOME\\webapps目录 因为所有的webapp要放到webapps目录下。（没有为什么，这是Tomcat服务器的要求。如果不放到这里，Tomcat服务器找不到你的应用。） 第二步：在CATALINA_HOME\\webapps目录下新建一个子目录，起名：oa 这个目录名oa就是你这个webapp的名字。 第三步：在oa目录下新建资源文件，例如：index.html 编写index.html文件的内容。 第四步：启动Tomcat服务器第五步：打开浏览器，在浏览器地址栏上输入这样的URL： http://127.0.0.1:8080/oa/index.html 思考一个问题： 我们在浏览器上直接输入一个URL，然后回车。这个动作和超链接一样吗？既然是一样的，我们完全可以使用超链接。 &lt;!--注意以下的路径，以/开始，带项目名，是一个绝对路径。不需要添加：http://127.0.0.1:8080--&gt;&lt;a href=&quot;/oa/login.html&quot;&gt;user login2&lt;/a&gt;&lt;!--多个层级也没有关系，正常访问即可。--&gt;&lt;!--注意：我们目前前端上的路径都以“/”开始的，都是加项目名的。--&gt;&lt;a href=&quot;/oa/test/debug/d.html&quot;&gt;d page&lt;/a&gt; http://127.0.0.1:8080/oa/userList.html 访问这个地址，可以展示一个用户列表页面。但是这个用户列表页面是写死在HTML文件当中的。这种资源我们称为静态资源。怎么能变成动态资源。显然需要连接数据库。 连接数据库需要JDBC程序，也就是说需要编写Java程序连接数据库，数据库中有多少条记录，页面上就显示多少条记录，这种技术被称为动态网页技术。 对动态web应用, 一个请求和响应的角色参与，之间的协议 有哪些角色（在整个BS结构的系统当中，有哪些人参与进去了） 浏览器软件 WEB Server的开发团队（WEB Server这个软件也是太多了：Tomcat、Jetty、WebLogic、JBOSS、WebSphere….） DB Server的开发团队（DB Server这个软件也是太多了：Oracle、MySQL…..） webapp的开发团队（WEB应用是我们做为JavaWEB程序员开发的） 角色和角色之间需要遵守哪些规范，哪些协议 webapp的开发团队 和 WEB Server的开发团队 之间有一套规范: JavaEE规范之一Servlet规范。 Servlet规范的作用是什么？ WEB Server 和 webapp解耦合。 Browser 和 WebServer之间有一套传输协议：HTTP协议。（超文本传输协议。） webapp开发团队 和 DB Server的开发团队之间有一套规范：JDBC规范。 Servlet规范是一个什么规范？ 遵循Servlet规范的webapp，这个webapp就可以放在不同的WEB服务器中运行。（因为这个webapp是遵循Servlet规范的。） Servlet规范包括什么呢？ 规范了哪些接口 规范了哪些类 规范了一个web应用中应该有哪些配置文件 规范了一个web应用中配置文件的名字 规范了一个web应用中配置文件存放的路径 规范了一个web应用中配置文件的内容 规范了一个合法有效的web应用它的目录结构应该是怎样的。 ….. 模拟Servlet本质 充当SUN公司的角色，制定Servlet规范 javax.servlet.Servlet接口 充当Tomcat服务器的开发者 充当Webapp的开发者 BankServlet implements Servlet UserListServlet implements Servlet UserLoginServlet implements Servlet 通过我们的分析： 对于我们javaweb程序员来说，我们只需要做两件事： 编写一个类实现Servlet接口。 将编写的类配置到配置文件中，在配置文件中：指定 请求路径 和 类名 的关系。 注意： 这个配置文件的文件名不能乱来。固定的。 这个配置文件的存放路径不能乱来。固定的。 文件名、文件路径都是SUN公司制定的Servlet规范中的明细。 严格意义上来说Servlet其实并不是简单的一个接口： Servlet规范中规定了： 一个合格的webapp应该是一个怎样的目录结构。 一个合格的webapp应该有一个怎样的配置文件。 一个合格的webapp配置文件路径放在哪里。 一个合格的webapp中java程序放在哪里。 这些都是Servlet规范中规定的。 Tomcat服务器要遵循Servlet规范。JavaWEB程序员也要遵循这个Servlet规范。 这样Tomcat服务器和webapp才能解耦合-&gt;指在系统中的各个组件或模块之间减少相互依赖，以便它们能够独立地进行修改、维护或替换，而不会对其他部分造成影响。解耦合的目标是提高系统的灵活性、可维护性和可扩展性。 开发一个带有servlet的web app开发步骤是怎样的？webapp路径 第一步：在webapps目录下新建一个目录，起名crm（这个crm就是webapp的名字）。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。 注意：crm就是这个webapp的根 第二步：在webapp的根下新建一个目录：WEB-INF 注意：这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。 第三步：在WEB-INF目录下新建一个目录：classes 注意：这个目录的名字必须是全部小写的classes。这也是Servlet规范中规定的。另外这个目录下一定存放的是Java程序编译之后的class文件（这里存放的是字节码文件）。 第四步：在WEB-INF目录下新建一个目录：lib 第五步：在WEB-INF目录下新建一个文件：web.xml 注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。 这个文件最好从其他的webapp中拷贝，最好别手写 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;/web-app&gt; - 第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。 - 这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。） - Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。） - Servlet接口是JavaEE的规范中的一员。 - Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口， - 重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet - 注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。- 第七步：编译我们编写的HelloServlet - 重点：配置环境变量CLASSPATH CLASSPATH=.;C:\\dev\\apache-tomcat-10.0.12\\lib\\servlet-api.jar- 第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\\classes目录下。- 第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。 - 这一步用专业术语描述：在web.xml文件中注册Servlet类。 - ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;!--servlet描述信息--&gt; &lt;!--任何一个servlet都对应一个servlet-mapping --&gt; &lt;servlet&gt; &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt; &lt;!--这个位置必须是带有包名的全限定类名--&gt; &lt;servlet-class&gt;com.bjpowernode.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet映射信息--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;fdsafdsagfdsafdsa&lt;/servlet-name&gt; &lt;!--这个路径唯一的要求是必须以 / 开始--&gt; &lt;!--当前这个路径可以随便写--&gt; &lt;url-pattern&gt;/fdsa/fd/saf/d/sa/fd/sa/fd&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第十步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是： http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd 非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。 注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：&#x2F;crm 浏览器上编写的路径太复杂，可以使用超链接。（非常重要：html页面只能放到WEB-INF目录外面。） 以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。 总结一下：一个合法的webapp目录结构应该是怎样的？webapproot |------WEB-INF |------classes(存放字节码) |------lib(第三方jar包) |------web.xml(注册Servlet) |------html |------css |------javascript |------image .... 浏览器发送请求，到最终服务器调用Servlet中的方法，是怎样的一个过程？（以下这个过程描述的很粗糙。其中还有很多步骤我省略了。） 用户输入URL，或者直接点击超链接：http://127.0.0.1:8080/crm/fdsa/fd/saf/d/sa/fd/sa/fd 然后Tomcat服务器接收到请求，截取路径：&#x2F;crm&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd Tomcat服务器找到crm项目 Tomcat服务器在web.xml文件中查找&#x2F;fdsa&#x2F;fd&#x2F;saf&#x2F;d&#x2F;sa&#x2F;fd&#x2F;sa&#x2F;fd 对应的Servlet是：com.bjpowernode.servlet.HelloServlet Tomcat服务器通过反射机制，创建com.bjpowernode.servlet.HelloServlet的对象。 Tomcat服务器调用com.bjpowernode.servlet.HelloServlet对象的service方法。 关于JavaEE的版本 JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。 Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。 以后没有JavaEE了。以后都叫做Jakarta EE。 JavaEE8版本升级之后的”JavaEE 9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9 JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet （包名都换了） 如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还 是能够识别javax.servlet这个包。 向浏览器响应一段HTML代码public void service(ServletRequest request, ServletResponse response)&#123; //设置相应的内容类型 response.setContentType(&quot;text/html&quot;); //创建一个PrintWriter对象 PrintWriter out = response.getWriter(); out.print(&quot;&lt;h1&gt;hello servlet!&lt;/h1&gt;&quot;);&#125; 在Servlet中连接数据库，怎么做？ Servlet是Java程序，所以在Servlet中完全可以编写JDBC代码连接数据库。 在一个webapp中去连接数据库，需要将驱动jar包放到WEB-INF&#x2F;lib目录下。（com.mysql.cj.jdbc.Driver 这个类就在驱动jar包当中。） 在集成开发环境当中开发Servlet程序 集成开发工具很多，其中目前使用比较多的是： IntelliJ IDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。） Eclipse（这个少一些）, Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司 使用IDEA集成开发工具开发Servlet让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module help-&gt;find Action-&gt;add framwork-&gt;web appcation support 选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。 重点，需要注意的：在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根 具体步骤 新建类 将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath） File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS…. 实现jakarta.servlet.Servlet接口中的5个方法。 在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。) 在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。 在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来） &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.StudentServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/student&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。 student.html 这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。 student.html文件的内容 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;student page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这里的项目名是 /xmm ，无法动态获取，先写死--&gt; &lt;a href=&quot;/xmm/servlet/student&quot;&gt;student list&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。 IDEA工具右上角，绿色小锤子右边有一个：Add Configuration 左上角加号，点击Tomcat Server –&gt; local 在弹出的界面中设置服务器Server的参数（基本上不用动） 在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。 修改 Application context为：&#x2F;xmm Servlet对象的生命周期什么是Servlet对象生命周期？ Servlet对象什么时候被创建和销毁 Servlet对象创建了几个？ Servlet对象是由谁来维护的？ Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。 Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】） 我们自己new的Servlet对象受WEB容器的管理吗？ 我们自己new的Servlet对象是不受WEB容器管理的。 WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中） web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系 服务器在启动的Servlet对象没有被创建出来（默认情况下） 这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。 怎么让服务器启动的时候创建Servlet对象呢？ 在servlet标签中添加子标签，在该子标签中填写整数，越小的整数优先级越高。 Servlet对象生命周期 默认情况下服务器启动的时候AServlet对象并没有被实例化 用户在发送第二次，或者第三次，或者第四次请求的时候, 还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明： 第一：Servlet对象是单例的 第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。 第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。 关闭服务器的时候，控制台输出了以下内容： AServlet&#x27;s destroy method execute! 通过以上输出内容，可以得出以下结论： Servlet的destroy方法只被Tomcat服务器调用一次。 请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？ destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。 GenericServlet我们编写一个Servlet类直接实现Servlet接口有什么缺点？ 我们只需要service方法，其他方法大部分情况下是不需要使用的。代码很丑陋。 编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。 GenericServlet实现Servlet接口。 GenericServlet是一个适配器。 以后编写的所有Servlet类继承GenericServlet，重写service方法即可, 不需要实现所有的方法。 GenericServlet类是否需要改造一下？怎么改造？更利于子类程序的编写？ 思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？ 还会执行。会执行GenericServlet类中的init方法。 思考一下Tomcat服务器伪代码： public class Tomcat &#123; public static void main(String[] args)&#123; // ..... // Tomcat服务器伪代码 // 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象） Class clazz = Class.forName(&quot;com.bjpowernode.javaweb.servlet.LoginServlet&quot;); Object obj = clazz.newInstance(); // 向下转型 //LoginSerlvet继承了GenericServlet类, 而这个类实现了Servlet接口, 所以可以转型 Servlet servlet = (Servlet)obj; // 创建ServletConfig对象 // Tomcat服务器负责将ServletConfig对象实例化出来。 // 多态（Tomcat服务器完全实现了Servlet规范）StandarWrapperFacade类实现了ServletConfig ServletConfig servletConfig = new org.apache.catalina.core.StandardWrapperFacade(); // 调用Servlet的init方法 servlet.init(servletConfig); // 调用Servlet的service方法 // .... &#125;&#125; ServletConfig什么是ServletConfig？ Servlet对象的配置信息对象。 ServletConfig对象中封装了标签中的配置信息。（web.xml文件中servlet的配置信息） 一个Servlet对应一个ServletConfig对象。 Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。 ServletConfig接口有哪些常用的方法？public String getInitParameter(String name); // 通过初始化参数的name获取valuepublic Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的namepublic ServletContext getServletContext(); // 获取ServletContext对象public String getServletName(); // 获取Servlet的name 以上方法在Servlet类当中，都可以使用this去调用。因为GenericServlet实现了ServletConfig接口。 ServletContext &#x3D;&#x3D;一个Servlet对象对应一个ServletConfig。&#x3D;&#x3D;100个Servlet对象则对应100个ServletConfig对象。 只要在同一个webapp当中，只要在同一个应用当中，&#x3D;&#x3D;所有的Servlet对象都是共享同一个ServletContext对象的。&#x3D;&#x3D; ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。 ServletContext被称为Servlet上下文对象。（Servlet对象的四周环境对象。） 一个ServletContext对象通常对应的是一个web.xml文件。 ServletContext是一个接口，Tomcat服务器对ServletContext接口进行了实现。 ServletContext接口中有哪些常用的方法？getInitParameter() &amp; getInitParameterNames()public String getInitParameter(String name); // 通过初始化参数的name获取valuepublic Enumeration&lt;String&gt; getInitParameterNames(); // 获取所有的初始化参数的name &lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt; &lt;context-param&gt; &lt;param-name&gt;pageSize&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;startIndex&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt; &lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt; #### getContextPath()- ```java // 获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径 // 在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。 public String getContextPath(); //String contextPath = application.getContextPath(); getRealPath()// 获取文件的绝对路径（真实路径）public String getRealPath(String path); 日志信息// 通过ServletContext对象也是可以记录日志的public void log(String message);public void log(String message, Throwable t);// 这些日志信息记录到哪里了？// localhost.2021-11-05.log// Tomcat服务器的logs目录下都有哪些日志文件？//catalina.2021-11-05.log 服务器端的java程序运行的控制台信息。//localhost.2021-11-05.log ServletContext对象的log方法记录的日志信息存储到这个文件中。//localhost_access_log.2021-11-05.txt 访问日志 attribute()ServletContext对象还有另一个名字：应用域（后面还有其他域，例如：请求域、会话域） 如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中 为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。 为什么这些共享数据很少的修改，或者说几乎不修改？ 所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。 数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。 // 存（怎么向ServletContext应用域中存数据）public void setAttribute(String name, Object value); // map.put(k, v) 名字和对应的Object// 取（怎么从ServletContext应用域中取数据）public Object getAttribute(String name); // Object v = map.get(k)// 删（怎么删除ServletContext应用域中的数据）public void removeAttribute(String name); // map.remove(k) 注意：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B&#x2F;S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。 我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要直到它的继承结构： jakarta.servlet.Servlet（接口）【爷爷】jakarta.servlet.GenericServlet implements Servlet（抽象类）【儿子】jakarta.servlet.http.HttpServlet extends GenericServlet（抽象类）【孙子】我们以后编写的Servlet要继承HttpServlet类。 大家到目前为止都接触过哪些缓存机制了？ 堆内存当中的字符串常量池。 “abc” 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。 堆内存当中的整数型常量池。 [-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。 连接池(Connection Cache) 这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。 JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。 连接池 最小连接数 最大连接数 连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。 线程池 Tomcat服务器本身就是支持多线程的。 Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？ 当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。 所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。 redis NoSQL数据库。非关系型数据库。缓存数据库。 向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中了。 HTTP协议 什么是HTTP协议？ HTTP协议：是W3C制定的一种超文本传输协议。（通信协议：发送消息的模板提前被制定好。） W3C： 万维网联盟组织 负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。 万维网之父：蒂姆·伯纳斯·李 这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。 什么是解耦合？ B不依赖S。 S也不依赖B。 HTTP协议包括： 请求协议 浏览器 向 WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。 响应协议 WEB服务器 向 浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。 HTTP的请求协议（B –&gt; S） HTTP的请求协议包括：4部分 请求行 请求头 空白行 请求体 HTTP请求协议的具体报文：GET请求 GET /servlet05/getServlet?username=lucy&amp;userpwd=1111 HTTP/1.1 请求行 Host: localhost:8080 请求头 Connection: keep-alive sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: &quot;Windows&quot; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: http://localhost:8080/servlet05/index.html Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 空白行 请求体 - HTTP请求协议的具体报文：POST请求 - ``` POST /servlet05/postServlet HTTP/1.1 请求行 Host: localhost:8080 请求头 Connection: keep-alive Content-Length: 25 Cache-Control: max-age=0 sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: &quot;Windows&quot; Upgrade-Insecure-Requests: 1 Origin: http://localhost:8080 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: http://localhost:8080/servlet05/index.html Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 空白行 username=lisi&amp;userpwd=123 请求体 请求行GET &#x2F;servlet05&#x2F;getServlet?username&#x3D;lucy&amp;userpwd&#x3D;1111 HTTP&#x2F;1.1 包括三部分： 第一部分：请求方式（7种） get（常用的） post（常用的） delete put head options trace 第二部分：URI 什么是URI？ 统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。 什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。 URI和URL什么关系，有什么区别？ URL包括URI http://localhost:8080/servlet05/index.html 这是URL。 &#x2F;servlet05&#x2F;index.html 这是URI。 第三部分：HTTP协议版本号 请求头Host: localhost:8080 请求的主机 主机的端口 浏览器信息 平台信息 cookie等信息 …. 空白行 空白行是用来区分“请求头”和“请求体” 请求体 向服务器发送的具体数据。 HTTP的响应协议（S –&gt; B） HTTP的响应协议包括：4部分 状态行 响应头 空白行 响应体 HTTP响应协议的具体报文： HTTP/1.1 200 ok 状态行 Content-Type: text/html;charset=UTF-8 响应头 Content-Length: 160 Date: Mon, 08 Nov 2021 13:19:32 GMT Keep-Alive: timeout=20 Connection: keep-alive 空白行 &lt;!doctype html&gt; 响应体 &lt;html&gt; &lt;head&gt; &lt;title&gt;from get servlet&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;from get servlet&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; #### 状态行- 三部分组成 - 第一部分：协议版本号（HTTP/1.1） - 第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。） - 200 表示请求响应成功，正常结束。 - 404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。 - 405表示前端发送的请求方式与后端请求的处理方式不一致时发生： - 比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405 - 比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405 - 500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。 - 以4开始的，一般是浏览器端的错误导致的。 - 以5开始的，一般是服务器端的错误导致的。 - 第三部分：状态的描述信息 - ok 表示正常成功结束。 - not found 表示资源找不到。#### 响应头：- 响应的内容类型- 响应的内容长度- 响应的时间- ....#### 空白行：- 用来分隔“响应头”和“响应体”的。#### 响应体：- 响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。- 怎么查看的协议内容？ - 使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。- 怎么向服务器发送GET请求，怎么向服务器发送POST请求？ - 到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method=&quot;post&quot;。 - 其他所有情况一律都是get请求： - 在浏览器地址栏上直接输入URL，敲回车，属于get请求。 - 在浏览器上直接点击超链接，属于get请求。 - 使用form表单提交数据时，form标签中没有写method属性，默认就是get - 或者使用form的时候，form标签中method属性值为：method=&quot;get&quot; - ....#### GET请求和POST请求有什么区别？get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，&quot;?&quot;后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据）- http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据）get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。- get请求无法发送大数据量。- post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。- post请求可以发送大数据量，理论上没有长度限制。- get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。- post请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。get请求是安全的。get请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。）post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。get请求支持缓存。- https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg- 任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中： - 一个get请求的路径a 对应 一个资源。 - 一个get请求的路径b 对应 一个资源。 - 一个get请求的路径c 对应 一个资源。 - ......- 实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。post请求不支持缓存。（POST是用来修改服务器端的资源的。）- post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。- 不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的： - name=value&amp;name=value&amp;name=value&amp;name=value - name是什么？ - 以form表单为例：form表单中input标签的name。 - value是什么？ - 以form表单为例：form表单中input标签的value。## 模板方法设计模式### 什么是设计模式？某个问题的固定的解决方案。(可以被重复使用。)### 你知道哪些设计模式？- GoF设计模式： - 通常我们所说的23种设计模式。（Gang of Four：4人组提出的设计模式） - 单例模式 - 工厂模式 - 代理模式 - 门面模式 - 责任链设计模式 - 观察者模式 - 模板方法设计模式 - .....- JavaEE设计模式： - DAO - DTO - VO - PO - pojo - ....- ....### 什么是模板方法设计模式？- 模板方法设计模式（Template Method Design Pattern）是一种行为型设计模式，它定义了一个操作中的算法的骨架，将一些步骤延迟到子类中。通过这种方式，可以在不改变算法结构的情况下，重新定义算法的某些步骤。 模板方法设计模式通常包含以下角色： 1. **模板类（Abstract Class）**：定义了一个模板方法，该方法提供了算法的骨架，它包含了一系列的步骤，其中某些步骤是抽象的，需要在子类中实现。 2. **具体子类（Concrete Class）**：实现了模板类中定义的抽象方法，以完成算法中具体的步骤。这些步骤可以根据需要进行覆盖或扩展。 模板方法设计模式的主要优点包括： - 代码复用：将公共的行为提取到模板方法中，子类只需实现特定的细节。 - 灵活性：允许子类在不改变算法结构的情况下重新定义算法中的某些步骤。 - 封装性：将算法的实现细节封装在模板方法内部，对客户端代码隐藏了具体的实现。 一个经典的示例是咖啡和茶的制作过程，其中模板类是一个抽象类，定义了一个制作饮料的模板方法，具体子类分别实现了制作咖啡和茶的具体步骤。 模板方法设计模式在许多框架和库中都有应用，例如在 Java 中的Servlet中，Servlet类中定义了一个模板方法doGet/doPost，子类继承Servlet并重写这些方法来处理HTTP GET和POST请求。## HttpServlet源码分析- HttpServlet类是专门为HTTP协议准备的。比GenericServlet更加适合HTTP协议下的开发。- HttpServlet在哪个包下？ - jakarta.servlet.http.HttpServlet### 目前为止我们接触了servlet规范中哪些接口？- jakarta.servlet.Servlet 核心接口（接口）- jakarta.servlet.ServletConfig Servlet配置信息接口（接口）- jakarta.servlet.ServletContext Servlet上下文接口（接口）- jakarta.servlet.ServletRequest Servlet请求接口（接口）- jakarta.servlet.ServletResponse Servlet响应接口（接口）- jakarta.servlet.ServletException Servlet异常（类）- jakarta.servlet.GenericServlet 标准通用的Servlet类（抽象类）### http包下都有哪些类和接口呢？jakarta.servlet.http.*;- jakarta.servlet.http.HttpServlet （HTTP协议专用的Servlet类，抽象类）- jakarta.servlet.http.HttpServletRequest （HTTP协议专用的请求对象）- jakarta.servlet.http.HttpServletResponse （HTTP协议专用的响应对象）### HttpServletRequest对象中封装了什么信息？- HttpServletRequest中封装了请求协议的全部内容。Tomcat服务器（WEB服务器）将“请求协议”中的数据全部解析出来，然后将这些数据全部封装到request对象当中了。- HttpServletResponse对象是专门用来响应HTTP协议到浏览器的。回忆Servlet生命周期？- 用户第一次请求 - Tomcat服务器通过反射机制，调用无参数构造方法。创建Servlet对象。(web.xml文件中配置的Servlet类对应的对象。) - Tomcat服务器调用Servlet对象的init方法完成初始化。 - Tomcat服务器调用Servlet对象的service方法处理请求。- 用户第二次请求 - Tomcat服务器调用Servlet对象的service方法处理请求。- 用户第三次请求 - Tomcat服务器调用Servlet对象的service方法处理请求。- .... - Tomcat服务器调用Servlet对象的service方法处理请求。- 服务器关闭 - Tomcat服务器调用Servlet对象的destroy方法，做销毁之前的准备工作。 - Tomcat服务器销毁Servlet对象。- HttpServlet源码分析：```javapublic class HelloServlet extends HttpServlet &#123;\t// 用户第一次请求，创建HelloServlet对象的时候，会执行这个无参数构造方法。\tpublic HelloServlet() &#123; &#125; //override 重写 doGet方法 //override 重写 doPost方法&#125;public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable &#123; // 用户第一次请求的时候，HelloServlet对象第一次被创建之后，这个init方法会执行。 public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init(); &#125;\t// 用户第一次请求的时候，带有参数的init(ServletConfig config)执行之后，会执行这个没有参数的init()\tpublic void init() throws ServletException &#123; // NOOP by default &#125;&#125;// HttpServlet模板类。public abstract class HttpServlet extends GenericServlet &#123; // 用户发送第一次请求的时候这个service会执行 // 用户发送第N次请求的时候，这个service方法还是会执行。 // 用户只要发送一次请求，这个service方法就会执行一次。 @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; // 将ServletRequest和ServletResponse向下转型为带有Http的HttpServletRequest和HttpServletResponse request = (HttpServletRequest) req; response = (HttpServletResponse) res; &#125; catch (ClassCastException e) &#123; throw new ServletException(lStrings.getString(&quot;http.non_http&quot;)); &#125; // 调用重载的service方法。 service(request, response); &#125; // 这个service方法的两个参数都是带有Http的。 // 这个service是一个模板方法。 // 在该方法中定义核心算法骨架，具体的实现步骤延迟到子类中去完成。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求方式 // 这个请求方式最终可能是：&quot;&quot; // 注意：request.getMethod()方法获取的是请求方式，可能是七种之一： // GET POST PUT DELETE HEAD OPTIONS TRACE String method = req.getMethod(); // 如果请求方式是GET请求，则执行doGet方法。 if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&#x27;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); &#125; catch (IllegalArgumentException iae) &#123; // Invalid date header - proceed as if none was set ifModifiedSince = -1; &#125; if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; // 如果请求方式是POST请求，则执行doPost方法。 doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; // 报405错误 String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); sendMethodNotAllowed(req, resp, msg); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 报405错误 String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;); sendMethodNotAllowed(req, resp, msg); &#125; &#125; 到今天我们终于得到了最终的一个Servlet类的开发步骤： 第一步：编写一个Servlet类，直接继承HttpServlet 第二步：重写doGet方法或者重写doPost方法，到底重写谁，javaweb程序员说了算。 第三步：将Servlet类配置到web.xml文件当中。 第四步：准备前端的页面（form表单），form表单中指定请求路径即可。 关于一个web站点的欢迎页面怎么设置欢迎页面呢？ 第一步：我在IDEA工具的web目录下新建了一个文件login.html 第二步：在web.xml文件中进行了以下的配置 &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; - 注意：设置欢迎页面的时候，这个路径不需要以“/”开始。并且这个路径默认是从webapp的根下开始查找。- 第三步：启动服务器，浏览器地址栏输入地址 - http://localhost:8080/servlet07一个webapp是可以设置多个欢迎页面的- ```xml &lt;welcome-file-list&gt; &lt;welcome-file&gt;page1/page2/page.html&lt;/welcome-file&gt; &lt;welcome-file&gt;login.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 注意：越靠上的优先级越高。找不到的继续向下找。 你有没有注意一件事：当我的文件名设置为index.html的时候，不需要在web.xml文件中进行配置欢迎页面。这是为什么？ 这是因为小猫咪Tomcat服务器已经提前配置好了。 实际上配置欢迎页面有两个地方可以配置： 一个是在webapp内部的web.xml文件中。（在这个地方配置的属于局部配置） 一个是在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件中进行配置。（在这个地方配置的属于全局配置） &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; - Tomcat服务器的全局欢迎页面是：index.html index.htm index.jsp。如果你一个web站点没有设置局部的欢迎页面，Tomcat服务器就会以index.html index.htm index.jsp作为一个web站点的欢迎页面。 - 注意原则：局部优先原则。（就近原则）欢迎页可以是一个Servlet吗？- 当然可以。- 你不要多想，欢迎页就是一个资源，既然是一个资源，那么可以是静态资源，也可以是动态资源。- 静态资源：index.html welcome.html .....- 动态资源：Servlet类。### 关于WEB-INF目录- 在WEB-INF目录下新建了一个文件：welcome.html- 打开浏览器访问：http://localhost:8080/servlet07/WEB-INF/welcome.html 出现了404错误。- 注意：放在WEB-INF目录下的资源是受保护的。在浏览器上不能够通过路径直接访问。所以像HTML、CSS、JS、image等静态资源一定要放到WEB-INF目录之外。## HttpServletRequest接口详解- HttpServletRequest是一个接口，全限定名称：jakarta.servlet.http.HttpServletRequest- HttpServletRequest接口是Servlet规范中的一员。- HttpServletRequest接口的父接口：ServletRequest ```java public interface HttpServletRequest extends ServletRequest &#123;&#125; HttpServletRequest接口的实现类谁写的? HttpServletRequest对象是谁给创建的？通过测试：org.apache.catalina.connector.RequestFacade 实现了 HttpServletRequest接口 public class RequestFacade implements HttpServletRequest &#123;&#125; 测试结果说明：Tomcat服务器（WEB服务器、WEB容器）实现了HttpServletRequest接口，还是说明了Tomcat服务器实现了Servlet规范。而&#x3D;&#x3D;对于我们javaweb程序员来说，实际上不需要关心这个，我们只需要面向接口编程即可。&#x3D;&#x3D;我们关心的是HttpServletRequest接口中有哪些方法，这些方法可以完成什么功能！！！！ HttpServletRequest对象中都有什么信息？都包装了什么信息？ HttpServletRequest对象是Tomcat服务器负责创建的。这个对象中封装了HTTP的请求协议。 实际上是用户发送请求的时候，遵循了HTTP协议，发送的是HTTP的请求协议，Tomcat服务器将HTTP协议中的信息以及数据全部解析出来，然后Tomcat服务器把这些信息封装到HttpServletRequest对象当中，传给了我们javaweb程序员。 javaweb程序员面向HttpServletRequest接口编程，调用方法就可以获取到请求的信息了。 request和response对象的生命周期？ request对象和response对象，一个是请求对象，一个是响应对象。这两个对象只在当前请求中有效。 一次请求对应一个request。 两次请求则对应两个request。 ….. HttpServletRequest接口中有哪些常用的方法？怎么获取前端浏览器用户提交的数据？ Map&lt;String,String[]&gt; getParameterMap() 这个是获取整个Map集合Enumeration&lt;String&gt; getParameterNames() 这个是获取Map集合中所有的keyString[] getParameterValues(String name) 根据key获取Map集合的valueString getParameter(String name) 获取value这个一维数组当中的第一个元素。这个方法最常用。// 以上的4个方法，和获取用户提交的数据有关系。 思考：如果是你，前端的form表单提交了数据之后，你准备怎么存储这些数据，你准备采用什么样的数据结构去存储这些数据呢？ 前端提交的数据格式：username&#x3D;abc&amp;userpwd&#x3D;111&amp;aihao&#x3D;s&amp;aihao&#x3D;d&amp;aihao&#x3D;tt 我会采用Map集合来存储： Map&lt;String,String&gt; key存储String value存储String 这种想法对吗？不对。 如果采用以上的数据结构存储会发现key重复的时候value覆盖。 key value --------------------- username abc userpwd 111 aihao s aihao d aihao tt 这样是不行的，因为map的key不能重复。 Map&lt;String, String[]&gt; key存储String value存储String[] key value ------------------------------- username &#123;&quot;abc&quot;&#125; userpwd &#123;&quot;111&quot;&#125; aihao &#123;&quot;s&quot;,&quot;d&quot;,&quot;tt&quot;&#125; - 注意：前端表单提交数据的时候，假设提交了120这样的“数字”，其实是以字符串&quot;120&quot;的方式提交的，所以服务器端获取到的一定是一个字符串的&quot;120&quot;，而不是一个数字。（前端永远提交的是字符串，后端获取的也永远是字符串。） #### 手工开发一个webapp。测试HttpServletRequest接口中的相关方法。后端收到前端发来的数据, 然后在servlet类中重写方法处理request和response先测试了4个常用的方法，获取请求参数的四个方法。```java\tMap&lt;String,String[]&gt; parameterMap = request.getParameterMap();//获取map\tEnumeration&lt;String&gt; names = request.getParameterNames();//获取所有key\tString[] values = request.getParameterValues(&quot;name&quot;);//根据key获取values数组\tString value = request.getParameter(&quot;name&quot;);//根据key获取第一个value值 request对象实际上又称为“请求域”对象。应用域对象是什么？ ServletContext （Servlet上下文对象。） 什么情况下会考虑向ServletContext这个应用域当中绑定数据呢？ 第一：所有用户共享的数据。 第二：这个共享的数据量很小。 第三：这个共享的数据很少的修改操作。 实际上向应用域当中绑定数据，就相当于把数据放到了缓存（Cache）当中，然后用户访问的时候直接从缓存中取，减少IO的操作，大大提升系统的性能，所以缓存技术是提高系统性能的重要手段。 你见过哪些缓存技术呢？ 字符串常量池 整数型常量池 [-128~127]，但凡是在这个范围当中的Integer对象不再创建新对象，直接从这个整数型常量池中获取。大大提升系统性能。 数据库连接池（提前创建好N个连接对象，将连接对象放到集合当中，使用连接对象的时候，直接从缓存中拿。省去了连接对象的创建过程。效率提升。） 线程池（Tomcat服务器就是支持多线程的。所谓的线程池就是提前先创建好N个线程对象，将线程对象存储到集合中，然后用户请求过来之后，直接从线程池中获取线程对象，直接拿来用。提升系统性能） 后期你还会学习更多的缓存技术，例如：redis、mongoDB….. ServletContext当中有三个操作域的方法： void setAttribute(String name, Object obj); // 向域当中绑定数据。Object getAttribute(String name); // 从域当中根据name获取数据。void removeAttribute(String name); // 将域当中绑定的数据移除// 以上的操作类似于Map集合的操作。Map&lt;String, Object&gt; map;map.put(&quot;name&quot;, obj); // 向map集合中放key和valueObject obj = map.get(&quot;name&quot;); // 通过map集合的key获取valuemap.remove(&quot;name&quot;); // 通过Map集合的key删除key和value这个键值对。 “请求域”对象 “请求域”对象要比“应用域”对象范围小很多。生命周期短很多。请求域只在一次请求内有效。 一个请求对象request对应一个请求域对象。一次请求结束之后，这个请求域就销毁了。 请求域对象也有这三个方法： 我们可以在获取到请求的时候, 自己绑定数据到请求域当中 void setAttribute(String name, Object obj); // 向域当中绑定数据。Object getAttribute(String name); // 从域当中根据name获取数据。void removeAttribute(String name); // 将域当中绑定的数据移除 请求域和应用域的选用原则？ 尽量使用小的域对象，因为小的域对象占用的资源较少。 跳转 执行了Aservlet之后跳转到Bservlet 转发（一次请求） // 第一步：获取请求转发器对象RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/b&quot;); //翻译: 请求转发器, bservlet在xml中对应的url// 第二步：调用转发器的forward方法完成跳转/转发//两个参数, 都是要传递给下一个资源dispatcher.forward(request,response);// 第一步和第二步代码可以联合在一起。request.getRequestDispatcher(&quot;/b&quot;).forward(request,response); 两个Servlet怎么共享数据？ 将数据放到ServletContext应用域当中，当然是可以的，但是应用域范围太大，占用资源太多。不建议使用。 可以将数据放到request域当中，然后AServlet转发到BServlet，保证AServlet和BServlet在同一次请求当中，这样就可以做到两个Servlet，或者多个Servlet共享同一份数据。 转发的下一个资源必须是一个Servlet吗？ 不一定，只要是Tomcat服务器当中的合法资源，都是可以转发的。例如：html…. 注意：转发的时候，路径的写法要注意，转发的路径以“&#x2F;”开始，不加项目名。 关于request对象中两个非常容易混淆的方法： // uri?username=zhangsan&amp;userpwd=123&amp;sex=1String username = request.getParameter(&quot;username&quot;);// 之前一定是执行过：request.setAttribute(&quot;name&quot;, new Object())Object obj = request.getAttribute(&quot;name&quot;);// 以上两个方法的区别是什么？// 第一个方法：获取的是用户在浏览器上提交的数据。// 第二个方法：获取的是请求域当中绑定的数据。 HttpServletRequest接口的其他常用方法： // 获取客户端的IP地址String remoteAddr = request.getRemoteAddr(); // 获取应用的根路径String contextPath = request.getContextPath();// 获取请求方式String method = request.getMethod();// 获取请求的URIString uri = request.getRequestURI(); // /aaa/testRequest// 获取servlet pathString servletPath = request.getServletPath(); // /testRequest 使用纯Servlet做一个单表的CRUD操作使用纯粹的Servlet完成单表【对部门的】的增删改查操作。（B&#x2F;S结构的。） 实现步骤 第一步：准备一张数据库表。（sql脚本） # 部门表 drop table if exists dept; create table dept( deptno int primary key, dname varchar(255), loc varchar(255) ); insert into dept(deptno, dname, loc) values(10, &#39;XiaoShouBu&#39;, &#39;BEIJING&#39;); insert into dept(deptno, dname, loc) values(20, &#39;YanFaBu&#39;, &#39;SHANGHAI&#39;); insert into dept(deptno, dname, loc) values(30, &#39;JiShuBu&#39;, &#39;GUANGZHOU&#39;); insert into dept(deptno, dname, loc) values(40, &#39;MeiTiBu&#39;, &#39;SHENZHEN&#39;); commit; select * from dept; - 第二步：准备一套HTML页面（项目原型）【前端开发工具使用HBuilder】 - 把HTML页面准备好 - 然后将HTML页面中的链接都能够跑通。（页面流转没问题。） - 应该设计哪些页面呢？ - 欢迎页面：index.html - 列表页面：list.html（以列表页面为核心，展开其他操作。） - 新增页面：add.html - 修改页面：edit.html - 详情页面：detail.html- 第三步：分析我们这个系统包括哪些功能？ - 什么叫做一个功能呢？ - 只要 这个操作连接了数据库，就表示一个独立的功能。 - 包括哪些功能？ - 查看部门列表 - 新增部门 - 删除部门 - 查看部门详细信息 - 跳转到修改页面 - 修改部门- 第四步：在IDEA当中搭建开发环境 - 创建一个webapp（给这个webapp添加servlet-api.jar和jsp-api.jar到classpath当中。） - 向webapp中添加连接数据库的jar包（mysql驱动） - 必须在WEB-INF目录下新建lib目录，然后将mysql的驱动jar包拷贝到这个lib目录下。这个目录名必须叫做lib，全部小写的。 - JDBC的工具类 - 将所有HTML页面拷贝到web目录下。- 第五步：实现第一个功能：查看部门列表 - 我们应该怎么去实现一个功能呢？ - 建议：你可以从后端往前端一步一步写。也可以从前端一步一步往后端写。都可以。但是千万要记住不要想起来什么写什么。你写代码的过程最好是程序的执行过程。也就是说：程序执行到哪里，你就写哪里。这样一个顺序流下来之后，基本上不会出现什么错误、意外。 - 从哪里开始？ - 假设从前端开始，那么一定是从用户点击按钮那里开始的。 - 第一：先修改前端页面的超链接，因为用户先点击的就是这个超链接。 - ```html &lt;a href=&quot;/oa/dept/list&quot;&gt;查看部门列表&lt;/a&gt; 第二：编写web.xml文件 &lt;servlet&gt; &lt;servlet-name&gt;list&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptListServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;list&lt;/servlet-name&gt; &lt;!--web.xml文件中的这个路径也是以“/”开始的，但是不需要加项目名--&gt; &lt;url-pattern&gt;/dept/list&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; - 第三：编写DeptListServlet类继承HttpServlet类。然后重写doGet方法。 - ```java package com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; 第四：在DeptListServlet类的doGet方法中连接数据库，查询所有的部门，动态的展示部门列表页面. 分析list.html页面中哪部分是固定死的，哪部分是需要动态展示的。 list.html页面中的内容所有的双引号要替换成单引号，因为out.print(“”)这里有一个双引号，容易冲突。 现在写完这个功能之后，你会有一种感觉，感觉开发很繁琐，只使用servlet写代码太繁琐了。 while(rs.next())&#123; String deptno = rs.getString(&quot;a&quot;); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); out.print(&quot; &lt;tr&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+(++i)+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+deptno+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;+dname+&quot;&lt;/td&gt;&quot;); out.print(&quot; &lt;td&gt;&quot;); out.print(&quot; &lt;a href=&#39;&#39;&gt;删除&lt;/a&gt;&quot;); out.print(&quot; &lt;a href=&#39;edit.html&#39;&gt;修改&lt;/a&gt;&quot;); out.print(&quot; &lt;a href=&#39;detail.html&#39;&gt;详情&lt;/a&gt;&quot;); out.print(&quot; &lt;/td&gt;&quot;); out.print(&quot; &lt;/tr&gt;&quot;); &#125; - 第六步：查看部门详情。 - 建议：从前端往后端一步一步实现。首先要考虑的是，用户点击的是什么？用户点击的东西在哪里？ - 一定要先找到用户点的“详情”在哪里。找了半天，终于在后端的java程序中找到了 - ```html &lt;a href=&#x27;写一个路径&#x27;&gt;详情&lt;/a&gt; - 详情 是需要连接数据库的，所以这个超链接点击之后也是需要执行一段java代码的。所以要将这个超链接的路径修改一下。 - 注意：修改路径之后，这个路径是需要加项目名的。&quot;/oa/dept/detail&quot; 技巧： out.print(&quot;&lt;a href=&#39;&quot;+contextPath+&quot;/dept/detail?deptno=&quot;+deptno+&quot;&#39;&gt;详情&lt;/a&gt;&quot;); - 重点：向服务器提交数据的格式：uri?name=value&amp;name=value&amp;name=value&amp;name=value - 这里的问号，必须是英文的问号。不能中文的问号。- 解决404的问题。写web.xml文件。 - ```xml &lt;servlet&gt; &lt;servlet-name&gt;detail&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptDetailServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;detail&lt;/servlet-name&gt; &lt;url-pattern&gt;/dept/detail&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 编写一个类：DeptDetailServlet继承HttpServlet，重写doGet方法。 package com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptDetailServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //中文思路（思路来源于：你要做什么？目标：查看部门详细信息。） // 第一步：获取部门编号 // 第二步：根据部门编号查询数据库，获取该部门编号对应的部门信息。 // 第三步：将部门信息响应到浏览器上。（显示一个详情。） &#125; &#125; - 在doGet方法当中：连接数据库，根据部门编号查询该部门的信息。动态展示部门详情页。 - 第七步：删除部门 - 怎么开始？从哪里开始？从前端页面开始，用户点击删除按钮的时候，应该提示用户是否删除。因为删除这个动作是比较危险的。任何系统在进行删除操作之前，是必须要提示用户的，因为这个删除的动作有可能是用户误操作。（在前端页面上写JS代码，来提示用户是否删除。） - ```html &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;del(30)&quot; &gt;删除&lt;/a&gt; &lt;script type=&quot;text/javascript&quot;&gt; function del(dno)&#123; if(window.confirm(&quot;亲，删了不可恢复哦！&quot;))&#123; document.location.href = &quot;/oa/dept/delete?deptno=&quot; + dno; &#125; &#125; &lt;/script&gt; 以上的前端程序要写到后端的java代码当中： DeptListServlet类的doGet方法当中，使用out.print()方法，将以上的前端代码输出到浏览器上。 解决404的问题： http://localhost:8080/oa/dept/delete?deptno=30 web.xml文件 &lt;servlet&gt; &lt;servlet-name&gt;delete&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjpowernode.oa.web.action.DeptDelServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;delete&lt;/servlet-name&gt; &lt;url-pattern&gt;/dept/delete&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; - 编写DeptDelServlet继承HttpServlet，重写doGet方法。- ```java package com.bjpowernode.oa.web.action; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; public class DeptDelServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 根据部门编号，删除部门。 &#125; &#125; 删除成功或者失败的时候的一个处理（这里我们选择了转发，并没有使用重定向机制。） // 判断删除成功了还是失败了。 if (count == 1) &#123; //删除成功 //仍然跳转到部门列表页面 //部门列表页面的显示需要执行另一个Servlet。怎么办？转发。 request.getRequestDispatcher(&quot;/dept/list&quot;).forward(request, response); &#125;else&#123; // 删除失败 request.getRequestDispatcher(&quot;/error.html&quot;).forward(request, response); &#125; - 第八步：新增部门 - 注意：最后保存成功之后，转发到 /dept/list 的时候，会出现405，为什么？ - 第一：保存用的是post请求。底层要执行doPost方法。 - 第二：转发是一次请求，之前是post，之后还是post，因为它是一次请求。 - 第三：/dept/list Servlet当中只有一个doGet方法。 - 怎么解决？两种方案 - 第一种：在/dept/list Servlet中添加doPost方法，然后在doPost方法中调用doGet。 - 第二种：重定向。- 第九步：跳转到修改部门的页面- 第十步：修改部门## 在一个web应用中应该如何完成资源的跳转在一个web应用中通过两种方式，可以完成资源的跳转：- 第一种方式：转发- 第二种方式：重定向### 转发和重定向有什么区别？代码上有什么区别？- 转发 ```java // 获取请求转发器对象 RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/dept/list&quot;); // 调用请求转发器对象的forward方法完成转发 dispatcher.forward(request, response); // 合并一行代码 request.getRequestDispatcher(&quot;/dept/list&quot;).forward(request, response); // 转发的时候是一次请求，不管你转发了多少次。都是一次请求。 // AServlet转发到BServlet，再转发到CServlet，再转发到DServlet，不管转发了多少次，都在同一个request当中。 // 这是因为调用forward方法的时候，会将当前的request和response对象传递给下一个Servlet。 重定向 // 注意：路径上要加一个项目名。为什么？ // 浏览器发送请求，请求路径上是需要添加项目名的。 // 以下这一行代码会将请求路径“/oa/dept/list”发送给浏览器 // 浏览器会自发的向服务器发送一次全新的请求：/oa/dept/list response.sendRedirect(&quot;/oa/dept/list&quot;); #### 有什么区别？- 转发（一次请求） - 在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a ，最终请求结束之后，浏览器地址栏上的地址还是这个。没变。- 重定向（两次请求） - 在浏览器地址栏上发送的请求是：http://localhost:8080/servlet10/a ，最终在浏览器地址栏上显示的地址是：http://localhost:8080/servlet10/b- 转发和重定向的本质区别？ - 转发：是由WEB服务器来控制的。A资源跳转到B资源，这个跳转动作是Tomcat服务器内部完成的。 - 重定向：是浏览器完成的。具体跳转到哪个资源，是浏览器说了算。- ==转发和重定向应该如何选择？==什么时候使用转发，什么时候使用重定向？ - 如果在上一个Servlet当中向request域当中绑定了数据，希望从下一个Servlet当中把request域里面的数据取出来，使用转发机制。 - 剩下所有的请求均使用重定向。（重定向使用较多。）- 跳转的下一个资源有没有要求呢？必须是一个Servlet吗？ - 不一定，跳转的资源只要是服务器内部合法的资源即可。包括：Servlet、JSP、HTML.....- 转发会存在浏览器的刷新问题。 ![重定向](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202402151431367.png) ![转发](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202402151432141.png)### 将oa项目中的资源跳转修改为合适的跳转方式- 删除之后，重定向- 修改之后，重定向- 保存之后，重定向- 重定向： - 成功 - 失败## Servlet注解，简化配置分析oa项目中的web.xml文件- 现在只是一个单标的CRUD，没有复杂的业务逻辑，很简单的一丢丢功能。web.xml文件中就有如此多的配置信息。如果采用这种方式，对于一个大的项目来说，这样的话web.xml文件会非常庞大，有可能最终会达到几十兆。- 在web.xml文件中进行servlet信息的配置，显然开发效率比较低，每一个都需要配置一下。- 而且在web.xml文件中的配置是很少被修改的，所以这种配置信息能不能直接写到java类当中呢？可以的。Servlet3.0版本之后，推出了各种Servlet基于注解式开发。优点是什么？- 开发效率高，不需要编写大量的配置信息。直接在java类上使用注解进行标注。- web.xml文件体积变小了。并不是说注解有了之后，web.xml文件就不需要了：- 有一些需要变化的信息，还是要配置到web.xml文件中。一般都是 注解+配置文件 的开发模式。- 一些不会经常变化修改的配置建议使用注解。一些可能会被修改的建议写到配置文件中。- 我们的第一个注解： jakarta.servlet.annotation.WebServlet 在Servlet类上使用：@WebServlet，WebServlet注解中有哪些属性呢？- name属性：用来指定Servlet的名字。等同于：&lt;servlet-name&gt;- urlPatterns属性：用来指定Servlet的映射路径。可以指定多个字符串。&lt;url-pattern&gt; loadOnStartUp属性：用来指定在服务器启动阶段是否加载该Servlet。等同于：&lt;load-on-startup&gt;- value属性：当注解的属性名是value的时候，使用注解的时候，value属性名是可以省略的。- 注意：属性是一个数组，如果数组中只有一个元素，使用该注解的时候，属性值的大括号可以省略。- 注解对象的使用格式： - @注解名称(属性名=属性值, 属性名=属性值, 属性名=属性值....)## 使用模板方法设计模式优化oa项目上面的注解解决了配置文件的问题。但是现在的oa项目仍然存在一个比较臃肿的问题。- 一个单标的CRUD，就写了6个Servlet。如果一个复杂的业务系统，这种开发方式，显然会导致类爆炸。（类的数量太大。）怎么解决类爆炸问题？- 以前的设计是一个请求一个Servlet类。1000个请求对应1000个Servlet类。导致类爆炸。- 可以这样: ==一个请求对应一个方法, 一个业务对应一个Servlet类==。- 处理部门相关业务的对应一个DeptServlet。处理用户相关业务的对应一个UserServlet。处理银行卡卡片业务对应一个CardServlet。## 分析使用纯粹Servlet开发web应用的缺陷在Servlet当中编写HTML/CSS/JavaScript等前端代码。存在什么问题？- java程序中编写前端代码，编写难度大。麻烦。- java程序中编写前端代码，显然程序的耦合度非常高。- java程序中编写前端代码，代码非常不美观。- java程序中编写前端代码，维护成本太高。（非常难于维护） - 修改小小的一个前端代码，只要有改动，就需要重新编译java代码，生成新的class文件，打一个新的war包，重新发布。上面的那个Servlet（Java程序）能不能不写了，让机器自动生成。我们程序员只需要写这个Servlet程序中的“前端的那段代码”，机器将我们写的“前端代码”生成 “Servlet这种java程序”。## 关于B/S结构系统的会话机制（session机制）### 什么是会话？用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做：session。在Java中，Session（会话）是一种在服务器端存储用户数据的机制。==它允许在用户的多次请求之间保持状态信息，并且对于跟踪用户的登录状态和其他相关信息非常有用。==在Web应用程序中，Session通常是通过使用Servlet或类似的服务器端技术来管理的。当用户首次访问Web应用程序时，==服务器会为其创建一个唯一的会话ID，并将该ID与用户的相关数据相关联。==这个会话ID通常通过Cookie或URL重写的方式发送给客户端，以便在用户的后续请求中可以被识别。### 什么是一次请求?用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的java对象是：request。- 一个会话当中包含多次请求。（一次会话对应N次请求。）- 在java的servlet规范当中，session对应的类名：HttpSession（jarkata.servlet.http.HttpSession）- session机制属于B/S结构的一部分。- session对象最主要的作用是：==保存会话状态。==（用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用session对象可以保留会话状态。）### 为什么需要session对象来保存会话状态呢？- 因为HTTP协议是一种==无状态协议==。- 什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以==降低服务器的压力==。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。- 只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗？ - 不知道。服务器是不知道浏览器关闭的。- 张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成： - 张三专属的session对象 - 李四专属的session对象 `HttpSession session = request.getSession();`#### 为什么不使用request对象保存会话状态？为什么不使用ServletContext对象保存会话状态？- request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。- ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。- ServletContext对象的域太大,所有用户共享, 而request太小。- request请求域（HttpServletRequest）、session会话域（HttpSession）、application域（ServletContext）- request &lt; session &lt; application在Java中，使用Session通常涉及到以下几个步骤：1. 创建或获取Session对象：通常是通过HttpServletRequest对象来获取Session对象。在Servlet中，可以通过调用`request.getSession()`方法来获取Session对象。如果Session对象不存在，则会创建一个新的Session；如果Session对象已经存在，则返回现有的Session。```javaHttpSession session = request.getSession(); 向Session中存储数据：可以使用Session对象的setAttribute()方法将数据存储在Session中。存储的数据以键值对的形式存在，可以使用键来获取相应的值。 session.setAttribute(&quot;username&quot;, &quot;john_doe&quot;); 从Session中获取数据：可以使用Session对象的getAttribute()方法从Session中获取数据。 String username = (String) session.getAttribute(&quot;username&quot;); 在需要的时候使Session失效：当用户注销或者会话结束时，应该使Session失效以释放资源。可以调用Session对象的invalidate()方法来使Session失效。 session.invalidate(); 这些是Session的基本用法。通过Session，你可以在服务器端跟踪用户的状态，存储用户的登录信息、购物车内容、用户偏好设置等数据，并在用户的多次请求之间保持这些信息。 思考一下：session对象的实现原理。HttpSession session = request.getSession(); 张三访问的时候获取的session对象就是张三的, 李四访问的时候获取就是李四的。 Session 的简单实现原理可以通过以下步骤来解释： 会话标识的生成和传递： 当用户首次访问服务器时，服务器会为该用户创建一个唯一的会话标识（通常是一个随机生成的字符串或者基于加密算法生成的哈希值）。这个会话标识通常被保存在一个名为 “JSESSIONID” 的 Cookie 中，或者在 URL 中通过参数的方式传递给客户端。 会话状态的存储： 当用户与服务器建立会话后，服务器会创建一个对应该会话的 Session 对象。session列表是一个Map，map的key是sessionid，map的value是session对象。 会话标识的识别： 每当用户发送请求时，客户端会将会话标识（&#x3D;&#x3D;通常是存储在 Cookie 中的 JSESSIONID&#x3D;&#x3D;）发送给服务器。服务器会根据这个会话标识来识别用户的会话，并将相应的 Session 对象加载到内存中，以便对用户的请求进行处理。 会话状态的维护： 在用户的每次请求中，服务器都会检查会话标识，并根据标识加载相应的 Session 对象。服务器可以从 Session 对象中获取存储的数据，以便在请求处理过程中使用。同时，服务器还可以向 Session 对象中存储新的数据，以便在下次请求时使用。 会话的销毁： 当用户会话结束时（例如用户注销、会话超时等情况），服务器会将对应的 Session 对象销毁，并释放相关资源。这样可以确保在用户离开后不再占用服务器资源，同时也可以保护用户的隐私安全。 总的来说，Session 的简单实现原理就是通过在客户端和服务器端之间传递唯一的会话标识，并在服务器端存储与该会话相关的状态信息，从而实现对用户会话的跟踪和管理。 Cookie禁用了，session还能找到吗？ cookie禁用是什么意思？服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。 找不到了。每一次请求都会获取到新的session对象。 cookie禁用了，session机制还能实现吗？ 可以。需要使用URL重写机制。 http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16 URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：你要是禁用cookie，你就别用了。 总结一下到目前位置我们所了解的域对象： request（对应的类名：HttpServletRequest） 请求域（请求级别的） session（对应的类名：HttpSession） 会话域（用户级别的） application（对应的类名：ServletContext） 应用域（项目级别的，所有用户共享的。） 这三个域对象的大小关系 request &lt; session &lt; application 他们三个域对象都有以下三个公共的方法： setAttribute（向域当中绑定数据） getAttribute（从域当中获取数据） removeAttribute（删除域当中的数据） 使用原则：尽量使用小的域。 session掌握之后，我们怎么解决oa项目中的登录问题，怎么能让登录起作用。 登录成功之后，可以将用户的登录信息存储到session当中。也就是说session中如果有用户的信息就代表用户登录成功了。session中没有用户信息，表示用户没有登录过。则跳转到登录页面。 销毁session对象： session.invalidate(); ## Cookiesession的实现原理中，每一个session对象都会关联一个sessionid- 对于session关联的cookie来说，这个==cookie是被保存在浏览器的“运行内存”当中, session保存在服务端==。- 只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？？？？？？？1. cookie最终是保存在浏览器客户端上的。 - 可以保存在运行内存中。（浏览器只要关闭cookie就消失了。） - 也可以保存在硬盘文件中。（永久保存。）2. cookie有啥用呢？ - cookie和session机制其实都是为了保存会话的状态。 - cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。） - session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。） - 为什么要有cookie和session机制呢？因为HTTP协议是无状态 无连接协议。cookie机制和session机制其实都==不属于java中的机制==，实际上cookie机制和session机制都是HTTP协议的一部分。HTTP协议中规定：==任何一个cookie都是由name和value组成的==。name和value都是字符串类型的。### 在java的servlet中，对cookie提供了哪些支持呢？- 提供了一个Cookie类来专门表示cookie数据。jakarta.servlet.http.Cookie;- java程序怎么把cookie数据发送给浏览器呢？response.addCookie(cookie);- 在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL。）#### 关于cookie的path，cookie关联的路径：`setPath()`方法是用来设置Cookie的路径的。Cookie的路径指定了服务器在发送Cookie时，客户端浏览器应该将Cookie发送给哪些路径下的服务器。这个路径决定了哪些URL能够访问到这个Cookie。当不显式设置Cookie的路径时，Cookie的默认路径是当前请求的上下文路径（Context Path）。这意味着Cookie只能在与当前请求的上下文路径匹配的路径下被发送和接收。通过调用`setPath()`方法，你可以指定Cookie的路径为一个更广泛的范围，使得这个Cookie能够被更多的URL访问到。例如，如果你将Cookie的路径设置为`&quot;/&quot;`，那么这个Cookie将在整个域名下都可用。```javaCookie cookie = new Cookie(&quot;username&quot;, &quot;john_doe&quot;);cookie.setPath(&quot;/&quot;); // 设置Cookie的路径为根路径，使其在整个域名下都可用 相反，如果你将Cookie的路径设置为一个特定的路径，例如&quot;/myapp&quot;，那么这个Cookie只会在以/myapp开头的URL路径下可用。 Cookie cookie = new Cookie(&quot;username&quot;, &quot;john_doe&quot;);cookie.setPath(&quot;/myapp&quot;); // 设置Cookie的路径为/myapp，使其仅在/myapp路径下可用 通过设置Cookie的路径，你可以控制Cookie的可见性，&#x3D;&#x3D;使其在需要的范围内可用&#x3D;&#x3D;，并提高了Web应用程序的安全性和灵活性。 在Java中，使用Cookie通常涉及以下几个步骤： 创建Cookie对象： 首先，你需要创建一个Cookie对象，设置其名称和值等属性。 Cookie cookie = new Cookie(&quot;username&quot;, &quot;john_doe&quot;); //key:username value:john_doe 设置Cookie的其他属性（可选）： 你可以设置Cookie的一些其他属性，例如过期时间、路径、域等。 cookie.setMaxAge(3600); // 设置Cookie的过期时间为3600秒cookie.setPath(&quot;/&quot;); // 设置Cookie的路径为根路径 将Cookie添加到HTTP响应中： 将Cookie添加到HTTP响应中，以便服务器将其发送给客户端。 response.addCookie(cookie); 从HTTP请求中获取Cookie： 在处理HTTP请求时，你可以从请求中获取客户端发送的Cookie。 Cookie[] cookies = request.getCookies();if (cookies != null) &#123; for (Cookie c : cookies) &#123; if (c.getName().equals(&quot;username&quot;)) &#123; String username = c.getValue(); // 使用username进行相应的逻辑处理 break; &#125; &#125;&#125; 更新或删除Cookie（可选）： 如果需要更新Cookie的值或者删除Cookie，可以重新创建一个具有相同名称的Cookie对象，然后将其添加到HTTP响应中，或者设置其过期时间为过去的日期。 Cookie newCookie = new Cookie(&quot;username&quot;, &quot;new_value&quot;);response.addCookie(newCookie);// 删除CookieCookie deleteCookie = new Cookie(&quot;username&quot;, &quot;&quot;);deleteCookie.setMaxAge(0);response.addCookie(deleteCookie); 这些是在Java中使用Cookie的基本步骤。通过操作Cookie，你可以在客户端和服务器之间传递数据，并实现用户状态的跟踪和个性化服务。 使用cookie实现一下十天内免登录功能。 先实现登录功能 登录成功 跳转到部门列表页面 登录失败 跳转到登录失败页面 修改前端页面 在登录页面给一个复选框，复选框后面给一句话：十天内免登录。 用户选择了复选框：表示要支持十天内免登录。 用户没有选择复选框：表示用户不想使用十天内免登录功能。 修改Servlet中的login方法 如果用户登录成功了，并且用户登录时选择了十天内免登录功能，这个时候应该在Servlet的login方法中创建cookie，用来存储用户名和密码，并且设置路径，设置有效期，将cookie响应给浏览器。（浏览器将其自动保存在硬盘文件当中10天） 用户再次访问该网站的时候，访问这个网站的首页的时候，有两个走向: 要么跳转到部门列表页面 要么跳转到登录页面 以上分别有两个走向，这显然是需要编写java程序进行控制的。 JSP我的第一个JSP程序：访问index.jsp，底层执行的是：index_jsp.class 这个java程序。 访问index.jsp，实际上执行的是index_jsp.class中的方法。 JSP实际上就是一个Servlet。 index_jsp 类继承 HttpJspBase，而HttpJspBase类继承的是HttpServlet。&#x3D;&#x3D;所以index_jsp类就是一个Servlet类。&#x3D;&#x3D; JSP是什么？ JSP是java程序。（JSP本质还是一个Servlet） JSP是：JavaServer Pages的缩写。（基于Java语言实现的服务器端的页面。） Servlet是JavaEE的13个子规范之一，那么JSP也是JavaEE的13个子规范之一。 JSP是一套规范。所有的web容器&#x2F;web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译” 每一个web容器&#x2F;web服务器都会内置一个JSP翻译引擎。 对JSP进行错误调试的时候，还是要直接打开JSP文件对应的java文件，检查java代码。 开发JSP的最高境界： 眼前是JSP代码，但是脑袋中呈现的是java代码。 JSP既然本质上是一个Servlet，那么JSP和Servlet到底有什么区别呢？ 职责不同： Servlet的职责是收集数据。（Servlet的强项是逻辑处理，业务处理，然后链接数据库，获取&#x2F;收集数据。） JSP的职责是展示数据。（JSP的强项是做数据的展示） JSP的基础语法在jsp文件中直接编写文字，都会自动被翻译到哪里？ 翻译到servlet类的service方法的out.write(“翻译到这里”)，直接翻译到双引号里，被java程序当做普通字符串打印输出到浏览器。 在JSP中编写的HTML CSS JS代码，这些代码对于JSP来说只是一个普通的字符串。但是JSP把这个普通的字符串一旦输出到浏览器，浏览器就会对HTML CSS JS进行解释执行。展现一个效果。 JSP的page指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题： 通过page指令来设置响应的内容类型，在内容类型的最后面添加：charset&#x3D;UTF-8 &lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;UTF-8”%&gt;，表示响应的内容类型是text&#x2F;html，采用的字符集UTF-8 &lt;%@page import&#x3D;”java.util.List,java.util.ArrayList”%&gt; 怎么在JSP中编写Java程序： &lt;% java语句; %&gt; 在这个符号当中编写的被视为java程序，被翻译到Servlet类的service方法内部。 这里你要细心点，你要思考，在&lt;% %&gt;这个符号里面写java代码的时候，你要时时刻刻的记住你正在“方法体”当中写代码，方法体中可以写什么，不可以写什么，你心里是否明白呢？ 在service方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。 service方法当中&#x3D;&#x3D;不能写静态代码块，不能写方法，不能定义成员变量。。。。。。&#x3D;&#x3D; 在同一个JSP当中 &lt;%%&gt; 这个符号可以出现多个。 &lt;%! %&gt; 在这个符号当中编写的java程序会自动翻译到service方法之外。 这个语法很少用，为什么？不建议使用，因为在service方法外面写静态变量和实例变量，都会存在线程安全问题，因为JSP就是servlet，servlet是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。 JSP的输出语句 怎么向浏览器上输出一个java变量。 &lt;% String name &#x3D; “jack”; out.write(“name &#x3D; “ + name); %&gt; 注意：以上代码中的out是JSP的九大内置对象之一。可以直接拿来用。当然，必须只能在service方法内部使用。 如果向浏览器上输出的内容中没有“java代码”，例如输出的字符串是一个固定的字符串，可以直接在jsp中编写，不需要写到&lt;%%&gt; 这里。 如果输出的内容中含有“java代码”，这个时候可以使用以下语法格式： &lt;%&#x3D; %&gt; 注意：在&#x3D;的后面编写要输出的内容。 &lt;%&#x3D; %&gt; 这个符号会被翻译到哪里？最终翻译成什么？ 翻译成了这个java代码： out.print(); 翻译到service方法当中了。 什么时候使用&lt;%&#x3D;%&gt; 输出呢？输出的内容中含有java的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出的是一个固定的字符串，直接在JSP文件中编写即可。 在JSP中如何编写JSP的专业注释 &lt;%–JSP的专业注释，不会被翻译到java源代码当中。–%&gt; JSP基础语法总结： JSP中直接编写普通字符串 翻译到service方法的out.write(“这里”) &lt;%%&gt; 翻译到service方法体内部，里面是一条一条的java语句。 &lt;%! %&gt; 翻译到service方法之外。 &lt;%&#x3D; %&gt; 翻译到service方法体内部，翻译为：out.print(); &lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;UTF-8”%&gt; page指令，通过contentType属性用来设置响应的内容类型。 使用Servlet + JSP完成oa项目的改造。Servlet处理业务，收集数据. JSP展示数据。 将之前原型中的html文件，全部修改为jsp，然后在jsp文件头部添加page指令（指定contentType防止中文乱码），将所有的JSP直接拷贝到web目录下。 完成所有页面的正常流转。（页面仍然能够正常的跳转。修改超链接的请求路径。） &lt;%=request.getContextPath() %&gt; 在&#x3D;&#x3D;JSP中动态的获取应用的根路径。&#x3D;&#x3D; Servlet中连接数据库，查询所有的部门，遍历结果集。 遍历结果集的过程中，取出部门编号、部门名、位置等信息，封装成java对象。 将java对象存放到List集合中。 将List集合存储到request域当中。 转发forward到jsp。 在JSP中： 从request域当中取出List集合。 遍历List集合，取出每个部门对象。动态生成tr。 JSP文件的扩展名必须是xxx.jsp吗？ jsp文件的扩展名是可以配置的。不是固定的。 在CATALINA_HOME&#x2F;conf&#x2F;web.xml，在这个文件当中配置jsp文件的扩展名。 &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; - xxx.jsp文件对于小猫咪来说，只是一个普通的文本文件，web容器会将xxx.jsp文件最终生成java程序，最终调用的是java对象相关的方法，真正执行的时候，和jsp文件就没有关系了。- 小窍门：JSP如果看不懂，建议把jsp翻译成java代码，就能看懂了。#### 什么是javabean？实际上javabean你可以理解为符合某种规范的java类，比如：- 有无参数构造方法- 属性私有化- 对外提供公开的set和get方法- 实现java.io.Serializable接口- 重写toString- 重写hashCode+equals- ....- javabean其实就是java中的实体类。负责数据的封装。- 由于javabean符合javabean规范，具有更强的通用性。### 完成剩下所有功能的改造。存在的问题：任何一个用户都可以访问这个系统，都可以对这个系统当中的数据进行增删改这些危险的操作。- 加一个登录功能。登录成功的可以访问该系统，登录失败不能访问。#### 实现登录功能：- 步骤1：数据库当中添加一个用户表：t_user - t_user表当中存储的是用户的登录信息，最基本的也包括：登录的用户名和登录的密码。 - 密码一般在数据库表当中存储的是密文。一般不以明文的形式存储。（这里先使用明文方式。） - 向t_user表中插入数据。- 步骤2：再实现一个登录页面。 - 登录页面上应该有一个登录的表单。有用户名和密码输入的框。 - 用户点击登录，提交表单，提交用户名和密码。form是post方式提交。- 步骤3：后台要有一个对应的Servlet来处理登录的请求。 - 登录成功：跳转到部门列表页面。 - 登录失败：跳转到失败的页面。- 步骤4：再提供一个登录失败的页面。#### 登录功能实现了，目前存在的最大的问题：- 这个登录功能目前只是一个摆设，没有任何作用。只要用户知道后端的请求路径，照样可以在不登录的情况下访问。- 这个登录没有真正起到拦截的作用。怎么解决？## JSP的指令- 指令的作用：指导JSP的翻译引擎如何工作（指导当前的JSP翻译引擎如何翻译JSP文件。）- 指令包括哪些呢？ - include指令：包含指令，在JSP中完成静态包含，很少用了。（这里不讲） - taglib指令：引入标签库的指令。这个到JJSTL标签库的时候再学习。现在先不管。 - page指令：目前重点学习一个page指令。- 指令的使用语法是什么？ - &lt;%@指令名 属性名=属性值 属性名=属性值 属性名=属性值....%&gt;- 关于page指令当中都有哪些常用的属性呢？ &lt;%@page session=&quot;true|false&quot; %&gt; true表示启用JSP的内置对象session，表示一定启动session对象。没有session对象会创建。 如果没有设置，默认值就是session=&quot;true&quot; session=&quot;false&quot; 表示不启动内置对象session。当前JSP页面中无法使用内置对象session。 &lt;%@page contentType=&quot;text/json&quot; %&gt; contentType属性用来设置响应的内容类型 但同时也可以设置字符集。 &lt;%@page contentType=&quot;text/json;charset=UTF-8&quot; %&gt; &lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; pageEncoding=&quot;UTF-8&quot; 表示设置响应时采用的字符集。 &lt;%@page import=&quot;java.util.List, java.util.Date, java.util.ArrayList&quot; %&gt; &lt;%@page import=&quot;java.util.*&quot; %&gt; import语句，导包。 &lt;%@page errorPage=&quot;/error.jsp&quot; %&gt; 当前页面出现异常之后，跳转到error.jsp页面。 errorPage属性用来指定出错之后的跳转位置。 &lt;%@page isErrorPage=&quot;true&quot; %&gt; 表示启用JSP九大内置对象之一：exception, 表示异常信息 默认值是false。 ### JSP的九大内置对象- 页面作用域​\tjakarta.servlet.jsp.PageContext pageContext * 请求作用域- jakarta.servlet.http.HttpServletRequest request - 会话作用域- jakarta.servlet.http.HttpSession session - 应用作用域- jakarta.servlet.ServletContext application - pageContext &lt; request &lt; session &lt; application - 以上四个作用域都有：setAttribute、getAttribute、removeAttribute方法。 - 以上作用域的使用原则：尽可能使用小的域。- java.lang.Throwable exception - jakarta.servlet.ServletConfig config(xml)- java.lang.Object page （其实是this，当前的servlet对象）- jakarta.servlet.jsp.JspWriter out （负责输出）- jakarta.servlet.http.HttpServletResponse response （负责响应）# EL表达式EL表达式是干什么用的？- Expression Language（表达式语言）- EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。- JSP中夹杂着各种java代码，例如&lt;% java代码 %&gt;、&lt;%=%&gt;等，导致JSP文件很混乱，不好看，不好维护。所以才有了后期的EL表达式。- EL表达式可以算是JSP语法的一部分。==EL表达式归属于JSP。==EL表达式出现在JSP中主要是：- 从某个作用域中取数据，然后将其转换成字符串，然后将其输出到浏览器。这就是EL表达式的功效。三大功效：1. 从某个域中取数据。- 四个域： - pageContext - request - session - application2. 将取出的数据转成字符串。​\t如果是一个java对象，也会自动调用java对象的toString方法将其转换成字符串。3. 将字符串输出到浏览器。- 和这个一样：&lt;%= %&gt;，将其输出到浏览器。- EL表达式很好用，基本的语法格式： - $&#123;表达式&#125;## EL表达式的使用：```jsp&lt;%\t// 创建User对象\tUser user = new User();\tuser.setUsername(&quot;jackson&quot;);\tuser.setPassword(&quot;1234&quot;);\tuser.setAge(50);\t// 将User对象存储到某个域当中。一定要存，因为EL表达式只能从某个范围中取数据。\t// 数据是必须存储到四大范围之一的。\trequest.setAttribute(&quot;userObj&quot;, user);%&gt;&lt;%--使用EL表达式取--%&gt;$&#123;这个位置写什么？？？？这里写的一定是存储到域对象当中时的name&#125;要这样写：$&#123;userObj&#125;等同于java代码：&lt;%=request.getAttribute(&quot;userObj&quot;)%&gt;你不要这样写：$&#123;&quot;userObj&quot;&#125;面试题：\t$&#123;abc&#125; 和 $&#123;&quot;abc&quot;&#125;的区别是什么？ $&#123;abc&#125;表示从某个域中取出数据，并且被取的这个数据的name是&quot;abc&quot;，之前一定有这样的代码: 域.setAttribute(&quot;abc&quot;, 对象); $&#123;&quot;abc&quot;&#125; 表示直接将&quot;abc&quot;当做普通字符串输出到浏览器。不会从某个域中取数据了。$&#123;userObj&#125; 底层是怎么做的？从域中取数据，取出user对象，然后调用user对象的toString方法，转换成字符串，输出到浏览器。&lt;%--如果想输出对象的属性值，怎么办？--%&gt;$&#123;userObj.username&#125; 使用这个语法的前提是：User对象有getUsername()方法。EL表达式中的. 这个语法，实际上调用了底层的getXxx()方法。注意：如果没有对应的get方法，则出现异常。报500错误。$&#123;userObj.addr.zipcode&#125;以上EL表达式对应的java代码：user.getAddr().getZipcode() 细节EL表达式获取顺序是&#x3D;&#x3D;优先从小范围中读取数据&#x3D;&#x3D;。 pageContext &lt; request &lt; session &lt; application EL表达式中有四个隐含的隐式的范围： pageScope 对应的是 pageContext范围。 requestScope 对应的是 request范围。 sessionScope 对应的是 session范围。 applicationScope 对应的是 application范围。 EL表达式对null进行了预处理。如果是null，则向浏览器输出一个空字符串。 EL表达式取数据的时候有两种形式： 第一种：. （大部分使用这种方式） 第二种：[ ] （如果存储到域的时候，这个name中含有特殊字符，可以使用 [ ]） request.setAttribute(&quot;abc.def&quot;, &quot;zhangsan&quot;); 出现了特殊字符&quot;.&quot; $&#123;requestScope.abc.def&#125; 这样是无法取值的。 应该这样：$&#123;requestScope[&quot;abc.def&quot;]&#125; 掌握使用EL表达式，怎么从Map集合中取数据： Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); $&#123;map.key&#125; 掌握使用EL表达式，怎么从数组和List集合中取数据： String[] name = &#123;&quot;11&quot;, &quot;22&quot;, &quot;33&quot;&#125;; List&lt;string&gt; list = new Arraylist&lt;&gt;(); list.add(&quot;ttt&quot;); request.setAtribute(&quot;myname&quot;, name); request.setArtibute(&quot;mylist&quot;, list); $&#123;name[0]&#125; $&#123;name[1]&#125; $&#123;list[0]&#125; page指令当中，有一个属性，可以忽略EL表达式 &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;true&quot; %&gt;isELIgnored=&quot;true&quot; 表示忽略EL表达式isELIgnored=&quot;false&quot; 表示不忽略EL表达式。（这是默认值）isELIgnored=&quot;true&quot; 这个是全局的控制。可以使用反斜杠进行局部控制：\\$&#123;username&#125; 这样也可以忽略单独一条。 在EL表达式中, 没有request对象, requestScope只表示请求域, 不等同与对象, 而pageContext也是jsp九大内置对象 通过EL表达式获取应用的根： ​\t$&#123;pageContext.request.contextPath&#125; pageContext表示页面上下文 EL表达式中其他的隐式对象： 隐含对象 说明 pageScope 取得Page范围属性名称中的值 requestScope 取得Request范围属性名称中的值 sessionScope 取得Session范围属性名称中的值 applicationScope 取得Application范围属性名称中的值 pageContext 表示JSP中的PageContext param 同：ServletRequest.getParameter(String name) paramValues 同：ServletRequest.getParameterValues(String name) initparam 同：ServletRequest.getInitParameter(String name) //ServletContext是Servlet的上下文对象, 对应九大内置对象application, 而xml最终为servlet中String a = application.getInitParameter(&quot;pageSize&quot;); //获取xml中配置信息pageSize$&#123;initParamm.pageSize EL表达式的运算符 算术运算符 +、-、*、&#x2F;、% 关系运算符 &#x3D;&#x3D; !&#x3D; 相当于equal方法 &#x2F;&gt;&#x3D; &lt; &lt;&#x3D; 逻辑运算符 ! &amp;&amp; || not and or 条件运算符 ? : 取值运算符 [ ]和. empty运算符 empty运算符的结果是boolean类型, 判单是否是空 ${empty param.username} ${not empty param.username} ${!empty param.password} JSTL标签库什么是JSTL标签库？ Java Standard Tag Lib（Java标准的标签库） &#x3D;&#x3D;JSTL标签库通常结合EL表达式一起使用。目的是让JSP中的java代码消失。&#x3D;&#x3D; 标签是写在JSP当中的，但实际上最终还是要执行对应的java程序。（java程序在jar包当中。） 使用JSTLD标签库的步骤： 第一步：引入JSTL标签库对应的jar包。 tomcat10之后引入的jar包是： jakarta.servlet.jsp.jstl-2.0.0.jar jakarta.servlet.jsp.jstl-api-2.0.0.jar 在IDEA当中怎么引入？ 在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中。然后将其“Add Lib…” 一定是要和mysql的数据库驱动一样，都是放在WEB-INF&#x2F;lib目录下的。 什么时候需要将jar包放到WEB-INF&#x2F;lib目录下？如果这个jar是tomcat服务器没有的。 第二步：在JSP中引入要使用标签库。（使用taglib指令引入标签库。） JSTL提供了很多种标签，你要引入哪个标签？？？？重点掌握核心标签库。 &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 这个就是核心标签库。 prefix=&quot;这里随便起一个名字就行了，核心标签库，大家默认的叫做c，你随意。&quot; - 第三步：在需要使用标签的位置使用即可。表面使用的是标签，底层实际上还是java程序。### JSTL标签的原理`&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;`以上uri后面的路径实际上指向了一个xxx.tld文件。tld文件实际上是一个xml配置文件。在tld文件中描述了“标签”和“java类”之间的关系。以上核心标签库对应的tld文件是：c.tld文件。它在哪里。在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下，有一个c.tld文件。源码解析：配置文件tld解析 对该标签的描述 catch 标签的名字 org.apache.taglibs.standard.tag.common.core.CatchTag 标签对应的java类。 JSP 标签体当中可以出现的内容，如果是JSP，就表示标签体中可以出现符合JSP所有语法的代码。例如EL表达式。 对这个属性的描述 var 属性名 false false表示该属性不是必须的。true表示该属性是必须的。 false 这个描述说明了该属性是否支持EL表达式。false表示不支持。true表示支持EL表达式。 &lt;c:catch var&#x3D;””&gt; JSP…. ### jstl中的核心标签库core当中有哪些常用的标签呢？- c:if - &lt;c:if test=&quot;boolean类型，支持EL表达式&quot;&gt;&lt;/c: if&gt;- c:forEach `&lt;c:forEach items=&quot;集合，支持EL表达式&quot; var=&quot;集合中的元素&quot; varStatus=&quot;元素状态对象&quot;&gt; $&#123;元素状态对象.count&#125; &lt;/c: forEach&gt;` var指定循环中的变量, begin开始, end结束, step步长 `&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;2&quot;&gt; $&#123;i&#125; &lt;/c: forEach&gt;`- c:choose c:when c:otherwise &lt;c:choose&gt; &lt;c:when test&#x3D;”${param.age &lt; 18}”&gt; 青少年 &lt;c:when test&#x3D;”${param.age &lt; 35}”&gt; 青年 &lt;c:when test&#x3D;”${param.age &lt; 55}”&gt; 中年 &lt;c:otherwise&gt; 老年 ## 改造OA使用什么技术改造呢？- Servlet + JSP + EL表达式 + JSTL标签。进行改造。在前端HTML代码中，有一个标签，叫做base标签，这个标签可以设置整个网页的基础路径。- 这是Java的语法，也不是JSP的语法。是HTML中的一个语法。HTML中的一个标签。通常出现在head标签中。- &lt; base href=&quot;http://localhost:8080/oa/&quot;&gt;- 在当前页面中，凡是路径没有以“/”开始的，都会自动将base中的路径添加到这些路径之前。 - &lt; a href=&quot;ab/def&quot;&gt;&lt;/ a&gt; - 等同于：&lt; a href=&quot;http://localhost:8080/oa/ab/def&quot;&gt;&lt;/ a&gt;- 需要注意：在JS代码中的路径，保险起见，最好不要依赖base标签。JS代码中的路径最好写上全路径。- ```html &lt;base href=&quot;$&#123;pageContext.request.scheme&#125;://$&#123;pageContext.request.serverName&#125;:$&#123;pageContext.request.serverPort&#125;$&#123;pageContext.request.contextPath&#125;/&quot;&gt; &lt;%--scheme:http, 服务器名, 端口号--%&gt; Filter过滤器当前的OA项目存在什么缺陷？ DeptServlet、EmpServlet、OrderServlet。每一个Servlet都是处理自己相关的业务。在这些Servlet执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个Servlet类当中都需要编写，显然代码没有得到重复利用。包括每一个Servlet都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用。怎么解决这个问题? 可以使用Servlet规范中的Filter过滤器来解决这个问题。 Filter是什么，有什么用，执行原理是什么？ Filter可以在Servlet这个目标程序执行之前添加代码。也可以在目标Servlet执行之后添加代码。之前之后都可以添加过滤规则。 一般情况下，都是在&#x3D;&#x3D;过滤器当中编写公共代码&#x3D;&#x3D;。 会有一个过滤器链 一个过滤器怎么写呢？在Java中，过滤器通常是通过实现 javax.servlet.Filter 接口来创建的。这个接口定义了三个方法，分别是 init(), doFilter() 和 destroy()。下面是一个简单的示例，演示了如何实现一个过滤器： import javax.servlet.*;import java.io.IOException;public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // 这个方法在过滤器被初始化时调用，可以在这里进行一些初始化操作 // 例如获取配置信息等 &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 这个方法在每次请求被拦截时调用 // 可以在这里对请求或响应进行处理 // 这里简单地将请求信息输出到控制台 System.out.println(&quot;Request intercepted!&quot;); // 调用 filterChain.doFilter() 继续执行过滤器链中的下一个过滤器 // 如果没有下一个过滤器，则执行目标资源（例如Servlet或JSP） filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; // 这个方法在过滤器被销毁时调用 // 可以在这里进行一些资源释放操作 &#125;&#125; 在实现了过滤器之后，你需要在 web.xml 中配置该过滤器，告诉Servlet容器在何时、何地使用该过滤器。下面是一个简单的 web.xml 配置示例： &lt;web-app&gt; &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.example.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在这个示例中，&lt;filter-name&gt; 是过滤器的名字，&lt;filter-class&gt; 是过滤器的完整类名，&lt;url-pattern&gt; 定义了过滤器要拦截的URL模式。 需要注意的是，Servlet 3.0 规范引入了注解（Annotation）方式来配置 Servlet、Filter 和 Listener，所以你也可以使用注解来代替在 web.xml 中的配置。 或者使用注解：@WebFilter({“*.do”}) 注意： Servlet对象默认情况下，在服务器启动的时候是不会新建对象的。 Filter对象默认情况下，在服务器启动的时候会新建对象。 Servlet是单例的。Filter也是单例的。（单实例。） 目标Servlet是否执行，取决于两个条件： 第一：在过滤器当中是否编写了：chain.doFilter(request, response); 代码。 第二：用户发送的请求路径是否和Servlet的请求路径一致。 chain.doFilter(request, response); 这行代码的作用： 执行下一个过滤器，如果下面没有过滤器了，执行最终的Servlet。 注意：Filter的优先级，天生的就比Servlet优先级高。 &#x2F;a.do 对应一个Filter，也对应一个Servlet。那么一定是先执行Filter，然后再执行Servlet。 关于Filter的配置路径： &#x2F;a.do、&#x2F;b.do、&#x2F;dept&#x2F;save。这些配置方式都是精确匹配。 &#x2F;* 匹配所有路径。 *.do 后缀匹配。不要以 &#x2F; 开始 &#x2F;dept&#x2F;* 前缀匹配。 在web.xml文件中进行配置的时候，Filter的执行顺序是什么？ 依靠filter-mapping标签的配置位置，越靠上优先级越高。 过滤器的调用顺序，遵循栈数据结构。 使用@WebFilter的时候，Filter的执行顺序是怎样的呢？ 执行顺序是：比较Filter这个类名。 比如：FilterA和FilterB，则先执行FilterA。 比如：Filter1和Filter2，则先执行Filter1. Filter的生命周期？ 和Servlet对象生命周期一致。 唯一的区别：Filter默认情况下，在服务器启动阶段就实例化。Servlet不会。 Filter过滤器这里有一个设计模式： 责任链设计模式 责任链设计模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许你创建一个对象链。请求从链的一端进入，并沿着链的路径依次传递，直到有一个对象处理它为止。 Handler（处理者）：定义一个处理请求的接口，并维护一个后继（successor）指针，以链接到下一个处理程序。如果一个处理程序无法处理请求，则会将请求传递给下一个处理程序。 ConcreteHandler（具体处理者）：实现处理请求的具体逻辑。如果可以处理请求，则处理它；否则，将请求传递给下一个处理程序。 优点 降低了请求发送者和接收者之间的耦合。 可以灵活地添加、删除或重新排序处理程序，而不影响客户端的代码。 缺点 请求可能无法被处理。如果没有处理程序处理请求，则可能会出现问题。 可能会导致性能问题，特别是在链中有很多处理程序时。 过滤器最大的优点： 在程序编译阶段不会确定调用顺序。因为Filter的调用顺序是配置到web.xml文件中的，只要修改web.xml配置文件中filter-mapping的顺序就可以调整Filter的执行顺序。显然Filter的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。 责任链设计模式最大的核心思想： 在程序运行阶段，动态的组合程序的调用顺序。 Listener监听器Java的监听器（Listener）是一种设计模式，用于处理对象之间的事件通知和处理机制。在Java中，监听器通常与事件（Event）和事件源（Event Source）一起使用。事件源是生成事件的对象，而监听器则是响应这些事件的对象。 监听器是Servlet规范中的一员。就像Filter一样。Filter也是Servlet规范中的一员。 概念解析： 事件源（Event Source）：通常是一个对象，它产生事件的地方。事件源负责通知已注册的监听器，以便它们能够执行相应的操作。例如，按钮是一个常见的事件源，它可以产生点击事件。 事件（Event）：事件是事件源生成的对象，它封装了事件的相关信息，例如事件类型、发生时间等。 监听器接口（Listener Interface）：监听器接口定义了监听器对象需要实现的方法。这些方法通常是事件处理方法，用于处理特定类型的事件。 监听器（Listener）：监听器是实现了监听器接口的对象，它负责监听事件源，并在事件发生时执行相应的操作。 工作原理： 事件源生成事件。 事件源通知已注册的监听器。 监听器检测到事件，并调用相应的处理方法进行处理。 示例：// 定义事件类class ClickEvent &#123; private int x; private int y; public ClickEvent(int x, int y) &#123; this.x = x; this.y = y; &#125; // 获取坐标信息 public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125;&#125;// 定义监听器接口interface ClickListener &#123; void onClick(ClickEvent event);&#125;// 按钮类作为事件源class Button &#123; private ClickListener listener; // 注册监听器 public void setClickListener(ClickListener listener) &#123; this.listener = listener; &#125; // 模拟按钮被点击事件 public void click(int x, int y) &#123; if (listener != null) &#123; ClickEvent event = new ClickEvent(x, y); listener.onClick(event); &#125; &#125;&#125;// 监听器实现类class ButtonClickListener implements ClickListener &#123; @Override public void onClick(ClickEvent event) &#123; System.out.println(&quot;Button clicked at (&quot; + event.getX() + &quot;, &quot; + event.getY() + &quot;)&quot;); &#125;&#125;// 测试public class Main &#123; public static void main(String[] args) &#123; Button button = new Button(); ClickListener listener = new ButtonClickListener(); button.setClickListener(listener); // 模拟按钮点击事件 button.click(10, 20); &#125;&#125; 在这个示例中，Button 类是事件源，ClickEvent 类表示点击事件，ClickListener 是监听器接口，ButtonClickListener 是监听器实现类。当按钮被点击时，它会生成一个点击事件，并通知已注册的监听器进行处理。 Servlet规范中提供了哪些监听器？在Java Servlet中，有几个监听器（Listener）用于监听不同的事件。这些监听器分别是： ServletContextListener：用于监听Web应用的启动和关闭事件。当Web应用启动时，contextInitialized() 方法会被调用；当Web应用关闭时，contextDestroyed() 方法会被调用。这个监听器在整个Web应用生命周期中只会被调用一次。 ServletRequestListener：用于监听Servlet请求的创建和销毁事件。当一个Servlet请求被创建时，requestInitialized() 方法会被调用；当Servlet请求被销毁时，requestDestroyed() 方法会被调用。这个监听器在每个Servlet请求的生命周期中都会被调用。 HttpSessionListener：用于监听HTTP会话（Session）的创建和销毁事件。当一个HTTP会话被创建时，sessionCreated() 方法会被调用；当HTTP会话被销毁时，sessionDestroyed() 方法会被调用。这个监听器在每个HTTP会话的生命周期中都会被调用。 这些监听器之间的区别在于它们监听的事件类型不同，以及它们所处的生命周期不同。 ServletContextListener 监听整个Web应用的生命周期，ServletRequestListener 监听每个Servlet请求的生命周期，而 HttpSessionListener 监听每个HTTP会话的生命周期。 jakarta.servlet包下： ServletContextListener ServletContextAttributeListener ServletRequestListener ServletRequestAttributeListener jakarta.servlet.http包下： HttpSessionListener HttpSessionAttributeListener 该监听器需要使用@WebListener注解进行标注。 该监听器监听的是什么？是session域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在session域对象上。 HttpSessionBindingListener 该监听器不需要使用@WebListener进行标注。 假设User类实现了该监听器，那么User&#x3D;&#x3D;对象在被放入session的时候触发bind事件&#x3D;&#x3D;，User对象从session中删除的时候，触发unbind事件。 假设Customer类没有实现该监听器，那么Customer对象放入session或者从session删除的时候，不会触发bind和unbind事件。 HttpSessionIdListener session的id发生改变的时候，监听器中的唯一一个方法就会被调用。 HttpSessionActivationListener 监听session对象的钝化和活化的。 钝化：session对象从内存存储到硬盘文件。 活化：从硬盘文件把session恢复到内存。 实现一个监听器的步骤：以ServletContextListener为例。第一步：编写一个类实现ServletContextListener接口。并且实现里面的方法。 void contextInitialized(ServletContextEvent event)void contextDestroyed(ServletContextEvent event) 第二步：在web.xml文件中对ServletContextListener进行配置，如下： &lt;listener&gt; &lt;listener-class&gt;com.bjpowernode.javaweb.listener.MyServletContextListener&lt;/listener-class&gt;&lt;/listener&gt; 当然，第二步也可以不使用配置文件，也可以用注解，例如：@WebListener 注意：所有监听器中的方法都是不需要javaweb程序员调用的，由服务器来负责调用？什么时候被调用呢？ 当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了。）之后，被web服务器自动调用。 思考一个业务场景：. 请编写一个功能，记录该网站实时的在线用户的个数。 我们可以通过服务器端有没有分配session对象，因为一个session代表了一个用户。有一个session就代表有一个用户。如果你采用这种逻辑去实现的话，session有多少个，在线用户就有多少个。这种方式的话：HttpSessionListener够用了。session对象只要新建，则count++，然后将count存储到ServletContext域当中，在页面展示在线人数即可。 业务发生改变了，只统计登录的用户的在线数量，这个该怎么办？ session.setAttribute(“user”, userObj); 用户登录的标志是什么？session中曾经存储过User类型的对象。那么这个时候可以让User类型的对象实现HttpSessionBindingListener监听器，只要User类型对象存储到session域中，则count++，然后将count++存储到ServletContext对象中。页面展示在线人数即可。 实现oa项目中当前登录在线的人数使用HttpSessionBindingListener绑定用户用户对象 什么代表着用户登录了？ session.setAttribute(“user”, userObj); User类型的对象只要往session中存储过，表示有新用户登录。 什么代表着用户退出了？ session.removeAttribute(“user”); User类型的对象从session域中移除了。 或者有可能是session销毁了。（session超时）","tags":["Java JavaWeb"],"categories":["记录","技术"]},{"title":"Maven & Spring 学习","path":"/2024/02/07/一, 二 Maven & Spring/","content":"MavenMaven简介和入门Maven介绍 https://maven.apache.org/what-is-maven.html Maven 是一款为 Java 项目构建管理、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。 总结：Maven就是一个软件，掌握软件安装、配置、以及基本功能（项目构建、依赖管理）使用就是本课程的主要目标！ 1.2 Maven主要作用理解 场景概念 场景1：例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整！ 场景2：项目开发完成后，想要将项目打成.war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包！节省大量时间！ 依赖管理： Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。 构建管理： 项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程！ Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。 1.3 Maven安装和配置 https://maven.apache.org/docs/history.html **3.6.**3 Java 7 安装 安装条件：maven需要本机安装java环境、必需包含java_home环境变量！ 软件结构： 环境变量 环境变量：配置maven_home 和 path 命令测试 mvn -v # 输出版本信息即可，如果错误，请仔细检查环境变量即可！# 友好提示，如果此处错误，绝大部分原因都是java_home变量的事，请仔细检查！！ 配置文件 我们需要需改maven&#x2F;conf&#x2F;settings.xml配置文件，来修改maven的一些默认配置。 我们主要休要修改的有三个配置： 1.依赖本地缓存位置（本地仓库位置）2.maven下载镜像3.maven选用编译项目的jdk版本！ 配置本地仓库地址 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;--&gt;&lt;!-- conf/settings.xml 55行 --&gt;&lt;localRepository&gt;D:\\repository&lt;/localRepository&gt; 2. 配置国内阿里镜像 &lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 3. 配置jdk17版本项目构建 &lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;&lt;profile&gt; &lt;id&gt;jdk-17&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;17&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;17&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; idea配置本地maven 我们需要将配置好的maven软件，配置到idea开发工具中即可！ 注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！ 打开idea配置文件，构建工具配置 依次点击 file &#x2F; settings &#x2F; build &#x2F; build tool &#x2F; maven 选中本地maven软件 测试是否配置成功 注意：如果本地仓库地址不变化，只有一个原因，就是maven&#x2F;conf&#x2F;settings.xml配置文件编写错误！仔细检查即可！ 2.1梳理Maven工程GAVP属性 Maven工程相对之前的工程，多出一组gavp属性，gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。既然要填写的属性，我们先行了解下这组属性的含义! Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在maven仓库总做一个标识，类似人的《姓-名》。有了具体标识，方便maven软件对项目进行管理和互相引用！ GAV遵循一下规则： 1） **GroupID 格式**：com.&#123;公司/BU &#125;.业务线.[子业务线]，最多 4 级。 说明：&#123;公司/BU&#125; 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。 正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang com.atguigu.java 2） **ArtifactID 格式**：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。 正例：tc-client / uic-api / tair-tool / bookstore 3） **Version版本号格式推荐**：主版本号.次版本号.修订号 1.0.0 1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。 2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。 3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。 例如： 初始→1.0.0 修改bug → 1.0.1 功能调整 → 1.1.1等 Packaging定义规则： 指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！ packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。 packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。 packaging 属性为 pom，代表不会打包，用来做继承的父工程。 2.2 Idea构建Maven JavaSE工程 注意：此处省略了version，直接给了一个默认值1.0-SNAPSHOT 自己后期可以在项目中随意修改！ 2.3 Idea构建Maven JavaEE工程 手动创建 创建一个javasemaven工程 手动添加web项目结构文件 注意：结构和命名固定 修改pom.xml文件打包方式 修改位置：项目下&#x2F;pom.xml &lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;maven_parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 新增一列打包方式packaging --&gt;&lt;packaging&gt;war&lt;/packaging&gt; 刷新和校验 项目的webapp文件夹出现小蓝点，代表成功！！ 插件方式创建 安装插件JBLJavaToWeb file &#x2F; settings &#x2F; plugins &#x2F; marketplace 创建一个javasemaven工程 右键、使用插件快速补全web项目 2.3 Idea构建Maven JavaEE工程 手动创建 创建一个javasemaven工程 手动添加web项目结构文件 注意：结构和命名固定 修改pom.xml文件打包方式 修改位置：项目下&#x2F;pom.xml &lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;maven_parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 新增一列打包方式packaging --&gt;&lt;packaging&gt;war&lt;/packaging&gt; 刷新和校验 项目的webapp文件夹出现小蓝点，代表成功！！ 插件方式创建 安装插件JBLJavaToWeb file &#x2F; settings &#x2F; plugins &#x2F; marketplace 创建一个javasemaven工程 右键、使用插件快速补全web项目 2.4 Maven工程项目结构说明 Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用： |-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。 src&#x2F;main&#x2F;java：存放项目的 Java 源代码。 src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。 src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。 src&#x2F;main&#x2F;webapp&#x2F;index.html：Web 应用的入口页面。 src&#x2F;test&#x2F;java：存放项目的测试代码。 src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。 三、Maven核心功能依赖和构建管理3.1 依赖管理和配置Maven 依赖管理是 Maven 软件中最重要的功能之一。 Maven 的依赖管理能够帮助开发人员&#x3D;&#x3D;自动解决软件包依赖问题&#x3D;&#x3D;，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 重点: 编写pom.xml文件! maven项目信息属性配置和读取： &lt;!-- 模型版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;!-- 版本号 --&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念--&gt;&lt;packaging&gt;jar/pom/war&lt;/packaging&gt; 依赖管理和添加： &lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt;&lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 生效范围 - compile ：main目录 test目录 打包打包 [默认] - provided：main目录 test目录 Servlet - runtime： 打包运行 MySQL - test: test目录 junit --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖版本提取和维护: &lt;!--声明版本--&gt;&lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2依赖传递和冲突依赖传递指的是当一个模块或库 A 依赖于另一个模块或库 B，而 B 又依赖于模块或库 C，那么 A 会间接依赖于 C。 这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如 Maven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可用。 依赖传递的作用是： 减少重复依赖 自动管理依赖 确保依赖版本正确性 依赖传递演示： 项目中，需要导入jackson相关的依赖，通过之前导入经验，jackson需要导入三个依赖，分别为： 通过查看网站介绍的依赖传递特性：data-bind中，依赖其他两个依赖 最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖 &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 依赖冲突演示当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！ 依赖冲突避免出现重复依赖，并且终止依赖传递！ maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择, 同时也提供了手动解决的冲突的方式，不过不推荐！ 解决依赖冲突（如何选择重复依赖）方式： 自动选择原则 短路优先原则（第一原则） A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 则A依赖于X(version 0.0.2)。 依赖路径长度相同情况下，则“先声明优先”（第二原则） A—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 在中，先声明的，路径相同，会优先选择！ 小思考: 前提： A 1.1 -&gt; B 1.1 -&gt; C 1.1 F 2.2 -&gt; B 2.2 pom声明： F 2.2 A 1.1 B 2.2 F 2.2\tA 1.1\tB 2.2, 不会引入C 1.1, 因为发生了依赖冲突 3.3 依赖导入失败场景和解决方案在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种： 下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项，并且也无法重新下载！ 解决方案： 检查网络连接和 Maven 仓库服务器状态。 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！ 例如： pom.xml依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 文件： 脚本使用： 使用记事本打开set REPOSITORY_PATH=D:\\repository 改成你本地仓库地址即可！点击运行脚本，即可自动清理本地错误缓存文件！！ 3.4 扩展构建管理和插件配置构建概念项目构建是指将源代码、依赖库和资源文件等&#x3D;&#x3D;转换成可执行或可部署的应用程序的过程&#x3D;&#x3D;，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。 主动触发场景 重新编译 : 编译不充分, 部分文件没有被编译! 打包 : 独立部署到外部服务器软件,打包部署 部署本地或者私服仓库 : maven工程加入到本地或者私服仓库,供其他工程使用 命令方式构建语法: mvn 构建命令 构建命令…. 命令执行需要进入到项目的根目录, pom.xml平级 部署必须时jar形式 命令 描述 mvn clean 清理编译或打包后的项目结构,删除target文件夹 mvn compile 编译项目，生成target文件 mvn test 执行测试源码 (测试) mvn site 生成一个项目依赖信息的展示页面 mvn package 打包项目，生成war &#x2F; jar 文件 mvn install 打包后上传到maven本地仓库(本地部署) mvn deploy 只打包，上传到maven私服仓库(私服部署) 可视化方式构建 构建命令周期构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路! 他们的顺序是固定的 清理周期：主要是对项目编译生成文件进行清理 包含命令：clean 默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分 包含命令：compile - test - package - install &#x2F; deploy 报告周期 包含命令：site 打包: mvn clean package 本地仓库: mvn clean install 最佳使用方案打包: mvn clean package重新编译: mvn clean compile本地部署: mvn clean install 周期，命令和插件 周期→包含若干命令→包含若干插件! 我们相当于CEO, 有问题时先找经理 使用周期命令构建，简化构建过程！ 最终进行构建的是插件！ 自己配置插件: &lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 四、Maven继承和聚合特性4.1 Maven工程继承关系继承概念Maven 继承是指在 Maven 的项目中，让&#x3D;&#x3D;一个项目从另一个项目中继承配置信息&#x3D;&#x3D;的机制。 继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。 继承作用作用：在父工程中统一管理项目中的依赖信息,进行统一版本管理! 它的背景是： 对一个比较大型的项目进行了模块拆分。 一个 project 下面，创建了很多个 module。 每一个 module 都需要配置自己的依赖信息。 它背后的需求是： 多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一管理。 使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。 通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 继承语法父工程去管理子工程 父工程 &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 子工程 &lt;!-- 使用parent标签指定当前工程的父工程 --&gt;&lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;!-- 子工程的坐标 --&gt;&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt; 父工程依赖统一管理 父工程声明版本 &lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子工程引用版本 &lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --&gt;&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2 Maven工程聚合关系 聚合概念 Maven 聚合是指将多个项目组织到一个父级项目中，&#x3D;&#x3D;通过触发父工程的构建,统一按顺序触发子工程构建的过程&#x3D;&#x3D;!! 聚合作用 统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。 优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。 聚合语法 父项目中包含的子项目列表。 &lt;project&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;parent-project&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!--modules统一管理那些子工程的配置--&gt; &lt;modules&gt; &lt;module&gt;child-project1&lt;/module&gt; &lt;module&gt;child-project2&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 聚合演示 通过触发父工程构建命令、引发所有子模块构建！产生反应堆！ 五、Maven实战案例：搭建微服务Maven工程架构5.1 项目需求和结构分析 需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。 项目架构： 用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。 订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。 通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。 服务依赖： 用户服务 (1.0.1) spring-context 6.0.6 spring-core 6.0.6 spring-beans 6.0.6 jackson-databind &#x2F; jackson-core &#x2F; jackson-annotations 2.15.0 订单服务 (1.0.1) shiro-core 1.10.1 spring-context 6.0.6 spring-core 6.0.6 spring-beans 6.0.6 通用模块 (1.0.1) commons-io 2.11.0 5.2项目搭建和统一构建1. 父模块搭建 (micro-shop) 1. 创建父工程 ![](https://secure2.wostatic.cn/static/q4ub49tpGULm7q2tLaTu1J/image.png?auth_key=1709213482-7EtNHUEpy2DfYUybJneTqR-0-5e2db4e386be7d24bf2d7d0ed00895c4) 2. pom.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;!-- 父工程不打包，所以选择pom值--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jackson.version&gt;2.15.0&lt;/jackson.version&gt; &lt;shiro.version&gt;1.10.1&lt;/shiro.version&gt; &lt;commons.version&gt;2.11.0&lt;/commons.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring-context会依赖传递core/beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson-databind会依赖传递core/annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 父工程添加依赖，会自动传递给所有子工程，不推荐！ --&gt; &lt;/dependencies&gt; &lt;!-- 统一更新子工程打包插件--&gt; &lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 通用模块 (common-service) 创建模块 pom.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;common-service&lt;/artifactId&gt; &lt;!-- 打包方式默认就是jar！ --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 声明commons-io，继承父工程版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 用户模块 (user-service) 创建模块, 并转为webapp pom.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 添加spring-context 自动传递 core / beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加jackson-databind 自动传递 core / annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 订单模块 (order-service) 创建模块 pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;order-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Spring技术体系结构1.1 总体技术体系 单一架构 一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。 单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis 简化三层的业务开发 分布式架构 一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个 module。每一个工程都是运行在自己的 Tomcat 上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。 分布式架构，项目主要应用技术框架：SpringBoot (整合SSM), SpringCloud , 中间件等 1.2 框架概念和理解​\t框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。 框架是一个基础结构 框架的优点包括以下几点： 提高开发效率 降低开发成本：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。 提高应用程序的稳定性：框重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。 提供标准化的解决方案：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。 框架的缺点包括以下几个方面： 学习成本高：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。 可能存在局限性：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。 版本变更和兼容性问题：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。 架构风险：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性。 站在文件结构的角度理解框架，可以将框架总结：框架 &#x3D; jar包+配置文件 莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本！ 常用的单一架构JavaEE项目框架演进，从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis。 总之，框架已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。 二、SpringFramewrok介绍2.1 Spring 和 SpringFramework概念 https://spring.io/projects 广义的 Spring：Spring 技术栈（全家桶） 广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 狭义的 Spring：Spring Framework（基础框架） 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。 它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。 Spring全家桶的其他框架都是以SpringFramework框架为基础！ 对比理解： QQ 和 腾讯 腾讯 &#x3D; Spring QQ &#x3D; SpringFramework 2.2 SpringFramework主要功能模块 SpringFramework框架结构图： 模块化的思想是 Spring 中非常重要的思想。 Spring 框架是一个分层架构，每个模块既可以单独使用，又可与其他模块联合使用。 每个「绿框」，对应一个模块，总共 8 个模块；「黑色包」，表示要实现这个模块的 jar 包。 Core Container，我们刚才已经在文档里看到过了，就是 IoC 容器，是核心，可以看到它依赖于这 4 个 jar 包： Beans Core Context SpEL, spring express language 那这里我们就知道了，如果想要用 IoC 这个功能，需要把这 4 个 jar 包导进去。其中，Core 模块是 Spring 的核心，Spring 的所有功能都依赖于这个 jar 包，Core 主要是实现 IoC 功能，那么说白了 Spring 的所有功能都是借助于 IoC 实现的。 功能模块 功能介绍 Core Container 核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。 AOP&amp;Aspects 面向切面编程(对面向对象的优化) TX 声明式事务管理。 Spring MVC 提供了面向Web应用程序的集成功能。 2.3 SpringFramework 主要优势 丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。 模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。 简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。 不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。 因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。 Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。 三、Spring IoC容器和核心概念3.1 组件和组件管理概念3.1.1 什么是组件?回顾常规的三层架构处理请求流程： 每一层都是向下引用的关系 整个项目就是由各种组件搭建而成的： 3.1.2 我们的期待 有人替我们创建组件的对象 有人帮我们保存组件的对象 有人帮助我们自动组装 有人替我们管理事务 有人协助我们整合其他框架 …… 3.1.3 Spring充当组件管理角色（IoC）那么谁帮我们完成我们的期待，帮我们管理组件呢？ 当然是Spring 框架了！ 组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！ Spring具体的组件管理动作包含： 组件对象实例化 组件属性属性赋值 组件对象之间引用 组件对象存活周期管理 …… 我们只需要&#x3D;&#x3D;编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！&#x3D;&#x3D; 核心容器帮我们关系组件 注意：组件是是可复用的功能对象！ 组件一定是对象 对象不一定是组件 综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行&#x3D;&#x3D;业务编写&#x3D;&#x3D;！ 3.1.4 组件交给Spring管理优势 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。 如果在A中使用B, 则需要new一个B, 这样是强耦合, 有了Spring之后不需要他们之间建立直接关系, 降低了耦合 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等 3.2 Spring IoC容器和容器实现3.2.1 普通和复杂容器普通容器 生活中的普通容器 普通容器只能用来存储，没有更多功能。 程序中的普通容器 数组 集合：List 集合：Set 复杂容器 生活中的复杂容器 政府管理我们的一生，生老病死都和政府有关。 程序中的复杂容器 Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。 名称 时机 次数 创建对象 默认情况：接收到第一次请求 修改启动顺序后：Web应用启动过程中 一次 初始化操作 创建对象之后 一次 处理请求 接收到请求 多次 销毁操作 Web应用卸载之前 一次 我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。 总结：&#x3D;&#x3D;Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！&#x3D;&#x3D; 3.2.2 SpringIoC容器介绍Spring IoC 容器，负责实例化、配置和组装 bean（组件）。 Bean 其实就是包装了的 Object，无gd论是控制反转还是依赖注入，它们的主语都是 object，而 bean 就是由第三方包装好了的 object（想一下别人送礼物给你的时候都是要包装一下的，自己造的就免了）。 Bean 是 Spring 的主角，有种说法叫 Spring 就是面向 bean 的编程（Bean Oriented Programming, BOP 容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。 它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。 上图显示了 Spring 容器工作原理的高级视图。 创建配置文件 Spring生成容器, 应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。 @Component 和 @Bean 的区别是什么？ 作用对象不同: @Component 注解作用于类，而 @Bean 注解作用于方法。 @Component 通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean 告诉了 Spring 这是某个类的示例，当我需要用它的时候还给我。 @Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库(同理我们引用自己创建的类也是一样的方法)中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。 3.2.3 SpringIoC容器具体接口和实现类SpringIoc容器接口： 接口规范了容器的具体动作, 怎么装 BeanFactory 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！ ApplicationContext 是 BeanFactory 的子接口-&gt;它扩展了以下功能： 更容易与 Spring 的 AOP 功能集成 消息资源处理（用于国际化） 特定于应用程序给予此接口实现，例如Web 应用程序的 WebApplicationContext 简而言之， BeanFactory 提供了配置框架和基本功能，而 ApplicationContext 添加了更多特定于企业的功能。 ApplicationContext 是 BeanFactory 的完整超集！ ApplicationContext容器实现类： 实现类基于不同场景, 有不同的实现 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径(就是src或者resource路径)下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径(系统路径)读取 XML 格式的配置文件创建 IOC 容器对象 AnnotationConfigApplicationContext 通过读取Java配置类创建 IOC 容器对象 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 3.2.4 SpringIoC容器管理配置方式Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。 Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式 XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。 注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。 Java配置类方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。 为了迎合当下开发环境，我们将以配置类+注解方式为主进行讲解！ 何为注入，注入什么？ 配置文件把资源从外部注入到内部，容器加载了外部的文件、对象、数据，然后把这些资源注入给程序内的对象，维护了程序内外对象之间的依赖关系。 所以说，控制反转是通过依赖注入实现的。但是你品，你细品，它们是有差别的，像是「从不同角度描述的同一件事」： IoC 是设计思想，DI 是具体的实现方式； IoC 是理论，DI 是实践； 从而实现对象之间的解藕。 当然，IoC 也可以通过其他的方式来实现，而 DI 只是 Spring 的选择。 IoC 和 DI 也并非 Spring 框架提出来的，Spring 只是应用了这个设计思想和理念到自己的框架里去 3.3 Spring IoC &#x2F; DI概念总结 IoC容器 Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。 IoC（Inversion of Control）控制反转 IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序(程序员)直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。 这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。 DI (Dependency Injection) 依赖注入 DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。Java代码中的对象1和2关系对比容器中的 在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。 四、Spring IoC &#x2F; DI的实践和应用4.1 Spring IoC &#x2F; DI 实现步骤 我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！ 配置元数据（配置） 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。 基于 XML 的配置元数据的基本结构： &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--一个bean代表一个组件信息--&gt; &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt; &lt;!--id为表示, class为类信息, 用于反射--&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML &lt;bean/&gt; 定义的形式）创建的。 标签 &#x3D;&#x3D; 组件信息声明 id 属性是标识单个 Bean 定义的字符串。 class 属性定义 Bean 的类型并使用完全限定的类名。 实例化IoC容器 内部完成IoC 和 DI 提供给 ApplicationContext 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java CLASSPATH 等）加载配置元数据。 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作： //实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); 获取Bean（组件） ApplicationContext 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。 通过使用方法 T getBean(String name, Class&lt;T&gt; requiredType) ，您可以检索 bean 的实例。 允许读取 Bean 定义并访问它们，如以下示例所示： //创建ioc容器对象，指定配置文件，ioc也开始实例组件对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);//获取ioc容器的组件对象PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);//使用组件对象List&lt;String&gt; userList = service.getUsernameList(); 4.2 基于XML配置方式组件管理4.2.1 实验一： 组件（Bean）信息声明配置（IoC） 目标 Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML &lt;bean/&gt; 定义的形式）。 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！ 思路 通过new的方式就是通过构造函数的方式, 或则通过工厂实例化来通写好的方法创建 准备项目 创建maven工程（spring-ioc-xml-01） 导入SpringIoC相关依赖 pom.xml &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基于无参数构造函数 当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。 准备组件类 package com.atguigu.ioc;public class HappyComponent &#123; //默认包含无参数构造函数 public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125;&#125; ​\t2. xml配置文件编写 创建携带spring约束的xml配置文件 编写配置文件： 文件：resources&#x2F;spring-bean-01.xml &lt;!-- 实验一 [重要]创建bean --&gt;&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt; bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息 id属性：bean的唯一标识,方便后期获取Bean！ class属性：组件类的全限定符！ 注意：要求当前组件类必须包含无参数构造函数！ 基于静态工厂方法实例化 除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！ 准备组件类 public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; ​\t2. xml配置文件编写 文件：resources&#x2F;spring-bean-01.xml &lt;bean id=&quot;clientService&quot; class=&quot;examples.ClientService&quot; factory-method=&quot;createInstance&quot;/&gt; class属性：指定工厂类的全限定符！ factory-method: 指定静态工厂方法，注意，该方法必须是static方法。 基于实例工厂方法实例化 接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！ 准备组建类 public class DefaultServiceLocator &#123; private static ClientServiceImplclientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; ​\t2. xml配置文件编写 文件：resources&#x2F;spring-bean-01.xml &lt;!-- 将工厂类进行ioc配置 --&gt;&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;&lt;/bean&gt;&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;&lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt; factory-bean属性：指定当前容器中工厂Bean 的名称。 factory-method: 指定实例工厂方法名。注意，实例方法必须是非static的！ 图解IoC配置流程 4.2.2 实验二： 组件（Bean）依赖注入配置（DI） 目标 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。 思路 基于构造函数的依赖注入（单个构造参数） 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！ 准备组件类 public class UserDao &#123;&#125;public class UserService &#123; private UserDao userDao; public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 编写配置文件 文件：resources&#x2F;spring-02.xml &lt;beans&gt; &lt;!-- 引用类bean声明 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- 构造函数引用 --&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt; constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。 基于构造函数的依赖注入（多构造参数解析） 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！ 准备组件类 public class UserDao &#123;&#125;public class UserService &#123; private UserDao userDao; private int age; private String name; public UserService(int age , String name ,UserDao userDao) &#123; this.userDao = userDao; this.age = age; this.name = name; &#125;&#125; 编写配置文件 &lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg value=&quot;18&quot;/&gt; &lt;constructor-arg value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt;&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt;&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 index从0开始 构造函数(0,1,2....)--&gt;&lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;use rDao&quot; class=&quot;x.y.UserDao&quot;/&gt;&lt;/beans&gt; constructor-arg标签：指定构造参数和对应的值 constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值 基于Setter方法依赖注入 介绍 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！ 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。 准备组件类 public Class MovieFinder&#123;&#125;public class SimpleMovieLister &#123; private MovieFinder movieFinder; private String movieName; public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; public void setMovieName(String movieName)&#123; this.movieName = movieName; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 编写配置文件 &lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt; &lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值 --&gt; &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt; &lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值 --&gt; &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt; property标签： 可以给setter方法对应的属性赋值 property 标签： name属性代表set方法标识、ref代表引用bean的标识id、value属性代表基本属性值 总结： 依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！ 需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。 4.2.3 实验三： IoC容器创建和使用 介绍 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！ 如图： 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！ 容器实例化 //方式1:实例化并且指定配置文件//参数：String...locations 传入一个或者多个配置文件ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); //方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式] ApplicationContext context = new ClassPathXmlApplicationContext(); //设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);//后配置的文件,需要调用refresh方法,触发刷新配置iocContainer1.refresh(); Bean对象读取 //方式1: 根据id获取//没有指定类型,返回为Object,需要类型转化!HappyComponent happyComponent = (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;); //使用组件对象 happyComponent.doWork();//方式2: 根据类型获取//根据类型获取,但是要求, 同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);happyComponent.doWork();//方式3: 根据id和类型获取HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);happyComponent.doWork();根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 4.2.4 实验四： 高级特性：组件（Bean）作用域和周期方法配置 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; ​ 3. 周期方法配置 &lt;beans&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt; &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;&lt;/beans&gt; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象&#x3D;&#x3D;反射创建&#x3D;&#x3D;多个Bean对象实例。 &#x3D;&#x3D;具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！&#x3D;&#x3D; 配置文件中装对应的信息 ioc容器中解析配置文件, 解析成Java对应的实体, 存储bean信息的就叫beandefinition对象. 存储完后要实例化, 根据beanDefinition的信息实例化, 再根据scope实例化那些对象. 单例对应一个组件对象 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 ​ 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 作用域配置 配置scope范围 &lt;!--bean的作用域 准备两个引用关系的组件类即可！！--&gt;&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.ioc.HappyMachine&quot;&gt; &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;&gt; &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;&lt;/bean&gt; ​ 4. 作用域测试 @Testpublic void testExperiment08() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;); HappyMachine bean = iocContainer.getBean(HappyMachine.class); HappyMachine bean1 = iocContainer.getBean(HappyMachine.class); //多例对比 false System.out.println(bean == bean1); HappyComponent bean2 = iocContainer.getBean(HappyComponent.class); HappyComponent bean3 = iocContainer.getBean(HappyComponent.class); //单例对比 true System.out.println(bean2 == bean3);&#125; 4.2.5 实验五： 高级特性：FactoryBean特性和使用 FactoryBean简介 三个不同的组件, 再配置文件中配置, FactoryBean是一个标准化工厂, 程序员重写提供的getObject方法 FactoryBean 接口是Spring IoC容器实例化逻辑的可插拔性点。 用于配置复杂的Bean对象，可以将创建过程存储在FactoryBean 的getObject方法！ FactoryBean&lt;T&gt; 接口提供三种方法： T getObject(): 返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！ boolean isSingleton(): 如果此 FactoryBean 返回单例，则返回 true ，否则返回 false 。此方法的默认实现返回 true （注意，lombok插件使用，可能影响效果）。 Class&lt;?&gt; getObjectType(): 返回 getObject() 方法返回的对象类型，如果事先不知道类型，则返回 null 。 FactoryBean使用场景 代理类的创建 第三方框架整合, 比如MyBatis, 配置是一个复杂过程, 这就可以将其放在FactoryBean中完成 复杂对象实例化等 Factorybean应用 准备FactoryBean实现类 // 实现FactoryBean接口时需要指定泛型// 泛型类型就是当前工厂要生产的对象的类型public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125; @Override public HappyMachine getObject() throws Exception &#123; // 方法内部模拟创建、设置一个对象的复杂过程 HappyMachine happyMachine = new HappyMachine(); happyMachine.setMachineName(this.machineName); return happyMachine; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // 返回要生产的对象的类型 return HappyMachine.class; &#125;&#125; ​ 2. 配置FactoryBean实现类 &lt;!-- FactoryBean机制 --&gt;&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;&lt;bean id=&quot;happyMachine7&quot; class=&quot;com.atguigu.ioc.HappyFactoryBean&quot;&gt; &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt; &lt;property name=&quot;machineName&quot; value=&quot;iceCreamMachine&quot;/&gt;&lt;/bean&gt; ​ 3. 测试读取FactoryBean和FactoryBean.getObject对象 @Testpublic void testExperiment07() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;spring-bean-07.xml&quot;); //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象 HappyMachine happyMachine = iocContainer.getBean(&quot;happyMachine7&quot;,HappyMachine.class); System.out.println(&quot;happyMachine = &quot; + happyMachine); //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可! &amp;happyMachine7 这是一种固定的约束 Object bean = iocContainer.getBean(&quot;&amp;happyMachine7&quot;); System.out.println(&quot;bean = &quot; + bean);&#125; FactoryBean和BeanFactory区别 **FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！ 是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。 一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！ BeanFactory 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。 BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。 总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。 4.2.6 实验六： 基于XML方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！ 数据库准备 create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-xml-practice-02 依赖导入 &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 3. 实体类准备 public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; JdbcTemplate技术讲解 为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JdbcTemplate。 jdbc.properties 提取数据库连接信息 atguigu.url=jdbc:mysql://localhost:3306/studbatguigu.driver=com.mysql.cj.jdbc.Driveratguigu.username=rootatguigu.password=root ​ springioc配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; ​ 基于jdbcTemplate的CRUD使用 public class JdbcTemplateTest &#123; /** * 使用jdbcTemplate进行DML动作 */ @Test public void testDML()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //TODO 执行插入一条学员数据 String sql = &quot;insert into students (id,name,gender,age,class) values (?,?,?,?,?);&quot;; /* 参数1: sql语句 参数2: 可变参数,占位符的值 */ int rows = jdbcTemplate.update(sql, 9,&quot;十一&quot;, &quot;男&quot;, 18, &quot;二年三班&quot;); System.out.println(&quot;rows = &quot; + rows); &#125; /** * 查询单条实体对象 * public class Student &#123; * private Integer id; * private String name; * private String gender; * private Integer age; * private String classes; */ @Test public void testDQLForPojo()&#123; String sql = &quot;select id , name , age , gender , class as classes from students where id = ? ;&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //根据id查询 Student student = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; &#123; //自己处理结果映射 Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); stu.setGender(rs.getString(&quot;gender&quot;)); stu.setClasses(rs.getString(&quot;classes&quot;)); return stu; &#125;, 2); System.out.println(&quot;student = &quot; + student); &#125; /** * 查询实体类集合 */ @Test public void testDQLForListPojo()&#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构搭建和实现 持久层 //接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类public class StudentDaoImpl implements StudentDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; ​ 2. 业务层 //接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类public class StudentServiceImpl implements StudentService &#123; private StudentDao studentDao; public void setStudentDao(StudentDao studentDao) &#123; this.studentDao = studentDao; &#125; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; ​ 3. 表述层 public class StudentController &#123; private StudentService studentService; public void setStudentService(StudentService studentService) &#123; this.studentService = studentService; &#125; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.atguigu.dao.impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.atguigu.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;studentController&quot; class=&quot;com.atguigu.controller.StudentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; ioc容器相当于一个秘书, 帮我们管理对象 运行测试 public class ControllerTest &#123; @Test public void testRun()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125;&#125; XMLIoC方式问题总结 &#x3D;&#x3D;注入的属性必须添加setter方法、代码结构乱！&#x3D;&#x3D; 配置文件和Java代码分离、编写不是很方便！ XML配置文件解析效率低 4.3 基于 注解 方式管理 Bean4.3.1 实验一： Bean注解标记和扫描 (IoC) 注解理解 和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。 @标记相当于Bena的id,class就是当前类的全限定符 本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。 举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。 班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。 扫描理解 Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。 准备Spring项目和组件 准备项目pom.xml &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 准备组件类 普通组件 /** * projectName: com.atguigu.components * * description: 普通的组件 */public class CommonComponent &#123;&#125; ​ Controller组件 /** * projectName: com.atguigu.components * * description: controller类型组件 */public class XxxController &#123;&#125; ​ Service组件 /** * projectName: com.atguigu.components * * description: service类型组件 */public class XxxService &#123;&#125; ​ Dao组件 /** * projectName: com.atguigu.components * * description: dao类型组件 */public class XxxDao &#123;&#125; 组件添加标记注解 组件标记注解和区别 Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。 使用注解标记 普通组件 /** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123;&#125; ​ Controller组件 /** * projectName: com.atguigu.components * * description: controller类型组件 */@Controllerpublic class XxxController &#123;&#125; ​ Service组件 /** * projectName: com.atguigu.components * * description: service类型组件 */@Servicepublic class XxxService &#123;&#125; ​ Dao组件 /** * projectName: com.atguigu.components * * description: dao类型组件 */@Repositorypublic class XxxDao &#123;&#125; 配置文件确定扫描范围 情况1：基本扫描配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt; &lt;/beans&gt; ​ 情况2：指定排除组件 &lt;!-- 情况三：指定不扫描的组件 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.components&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt; &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; ​ 情况3：指定扫描组件 &lt;!-- 情况四：仅扫描指定的组件 --&gt;&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ioc.components&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 情况2: 可以排除注解 webioc装controller, rootioc装service和repository. 写一个标记就可以排除对应的controller 组件BeanName问题 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。 默认情况： 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。 使用value属性指定： @Controller(value = &quot;tianDog&quot;)public class SoldierController &#123;&#125; ​ 当注解中只设置一个属性时，value属性的属性名可以省略： @Service(&quot;smallDog&quot;)public class SoldierService &#123;&#125; 总结 注解方式IoC只是标记哪些类要被Spring管理 最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包 现阶段配置方式为 注解 （标记）+ XML（扫描） 4.3.2 实验二： 组件（Bean）作用域和周期方法注解 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; @PreDestroy //注解指定销毁方法 public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 ​ 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 ​ 3. 作用域配置 @Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例 二选一public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125; 4.3.3 实验三： Bean属性赋值：引用类型自动装配 (DI) 设定场景 SoldierController 需要 SoldierService SoldierService 需要 SoldierDao 同时在各个组件中声明要调用的方法。 SoldierController中声明方法 import org.springframework.stereotype.Controller;@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; public void getMessage() &#123; soldierService.getMessage(); &#125;&#125; ​ - SoldierService中声明方法 @Service(&quot;smallDog&quot;)public class SoldierService &#123; private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; ​ - SoldierDao中声明方法 @Repositorypublic class SoldierDao &#123; public void getMessage() &#123; System.out.print(&quot;I am a soldier&quot;); &#125;&#125; 自动装配实现 前提 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。 注意：不区分IoC的方式！XML和注解都可以！ @Autowired注解 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。 给Controller装配Service @Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired private SoldierService soldierService; public void getMessage() &#123; soldierService.getMessage(); &#125; &#125; ​ 4. 给Service装配Dao @Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; @Autowired注解细节 标记位置 成员变量 这是最主要的使用方式！ 与xml进行bean ref引用不同，他不需要有set方法！ 因为在xml中配置的属性实际上是调用的类中set方法, 注解方式直接使用属性接值 @Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; ​ 2. 构造器 @Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; @Autowired public SoldierController(SoldierService soldierService) &#123; this.soldierService = soldierService; &#125; …… ​ 3. setXxx()方法 @Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; @Autowired public void setSoldierService(SoldierService soldierService) &#123; this.soldierService = soldierService; &#125; …… 工作流程 首先根据所需要的组件类型到 IOC 容器中查找 能够找到唯一的 bean：直接执行装配 如果完全找不到匹配这个类型的 bean：装配失败 和所需类型匹配的 bean 不止一个 没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配 能够找到：执行装配 找不到：装配失败 使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配 能够找到：执行装配 找不到：装配失败 @Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired @Qualifier(value = &quot;maomiService222&quot;) // 根据面向接口编程思想，使用接口类型引入Service组件 private ISoldierService soldierService; 佛系装配 给 @Autowired 注解设置 required &#x3D; false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性 @Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装 @Autowired(required = false) private ISoldierService soldierService; 扩展JSR-250注解@Resource 理解JSR系列注解 JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列： JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解： @Deprecated: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。 @Override: 标识一个方法重写了父类中的方法。 @SuppressWarnings: 抑制编译时产生的警告消息。 @SafeVarargs: 标识一个有安全性警告的可变参数方法。 @FunctionalInterface: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。 JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括： @Resource: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。 @PostConstruct: 标识一个方法作为初始化方法。 @PreDestroy: 标识一个方法作为销毁方法。 @Resource.AuthenticationType: 标识注入的资源的身份验证类型。 @Resource.AuthenticationType: 标识注入的资源的默认名称。 JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有： @SupportedAnnotationTypes: 标识注解处理器所处理的注解类型。 @SupportedSourceVersion: 标识注解处理器支持的Java源码版本。 JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括： @Named: 标识一个被依赖注入的组件的名称。 @Inject: 标识一个需要被注入的依赖组件。 @Singleton: 标识一个组件的生命周期只有一个唯一的实例。 JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括： @RolesAllowed: 标识授权角色 @PermitAll: 标识一个活动无需进行身份验证。 @DenyAll: 标识不提供针对该方法的访问控制。 @DeclareRoles: 声明安全角色。 但是你要理解JSR是Java提供的技术规范，也就是说，他只是规定了注解和注解的含义，JSR并不是直接提供特定的实现，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。 JSR-250 @Resource注解 @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。 @Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【高于JDK11或低于JDK8需要引入以下依赖】 &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; ​ - @Resource使用 @Controllerpublic class XxxController &#123; /** * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找 * 3. 可以指定name名称查找! @Resource(name=&#x27;test&#x27;) == @Autowired + @Qualifier(value=&#x27;test&#x27;) */ @Resource private XxxService xxxService; //@Resource(name = &quot;指定beanName&quot;) //private XxxService xxxService; public void show()&#123; System.out.println(&quot;XxxController.show&quot;); xxxService.show(); &#125;&#125; 4.3.4 实验四： Bean属性赋值：基本类型属性赋值 (DI)@Value 通常用于注入外部化属性, 因为在使用注解加入到ioc容器后, 内部属性直接赋值即可, @Value就更多用于读取外部属性 声明外部配置 application.properties catalog.name&#x3D;MovieCatalog xml引入外部配置 &lt;!-- 引入一个外部配置文件--&gt;&lt;context:property-placeholder location=&quot;application.properties&quot; /&gt; @Value注解读取配置 package com.atguigu.components;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123; /* * 没有@Value之前: * &lt;bean id class * &lt;property name = &quot;name&quot; value = &quot;二狗子&quot; */ /** * 情况1: $&#123;key&#125; 取外部配置key对应的值! * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值 */ @Value(&quot;$&#123;application.username&#125;&quot;) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 4.3.5 实验五： 基于注解+XML方式整合三层架构组件 回顾: 注解 + 配置文件一起使用, ioc注解相当于一个bean标签 di 引用类型 常用的是@autowired, 配合qualifier 基本类型 @value(${key:value}) FactoryBean @component 第三方类依然用xml的bean配置 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML+注解方式进行组件管理！ 项目准备 项目创建 spring-annotation-practice-04 ​ 2. 实体类准备 @Datapublic class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes;&#125; 三层架构搭建和实现 持久层 //接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类@Repositorypublic class StudentDaoImpl implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; ​ 2. 业务层 //接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; ​ 3. 表述层 @Controllerpublic class StudentController &#123; @Autowired private StudentService studentService; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 扫描Ioc/DI注解 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.dao,com.atguigu.service,com.atguigu.controller&quot; /&gt;&lt;/beans&gt; 运行测试 public class ControllerTest &#123; @Test public void testRun()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125;&#125; 注解+XML IoC方式问题总结 自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！ XML格式解析效率低！ 4.4 基于配置类方式管理Bean4.4.1 完全注解开发理解​\tSpring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序， 使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。 两种方式思维转化： 4.4.2 实验一：配置类和扫描注解 xml+注解方式 配置文件application.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt; &lt;!-- 引入外部配置文件--&gt; &lt;context:property-placeholder location=&quot;application.properties&quot; /&gt;&lt;/beans&gt; 测试创建IoC容器 // xml方式配置文件使用ClassPathXmlApplicationContext容器读取ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); 配置类+注解方式（完全注解方式） 配置类 使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。 import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;//标注当前类是配置类，替代application.xml @Configuration//使用注解读取外部配置，替代 &lt;context:property-placeholder标签@PropertySource(&quot;classpath:application.properties&quot;)//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)public class MyConfiguration &#123; &#125; 测试创建IoC容器 // AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class); 可以使用 no-arg 构造函数实例化 AnnotationConfigApplicationContext ，然后使用 register() 方法对其进行配置。此方法在以编程方式生成 AnnotationConfigApplicationContext 时特别有用。以下示例演示如何执行此操作： // AnnotationConfigApplicationContext-IOC容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext();//外部设置配置类iocContainerAnnotation.register(MyConfiguration.class);//刷新后方可生效！！iocContainerAnnotation.refresh(); 总结： @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件 @ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描 @PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签 配合IoC&#x2F;DI注解，可以进行完整注解开发！ 4.4.3 实验二：@Bean定义组件 场景需求：将Druid连接池对象存储到IoC容器 需求分析：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！ xml方式实现： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置类方式实现： @Bean 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 &lt;beans/&gt; XML 配置的人来说， @Bean 注释与 &lt;bean/&gt; 元素起着相同的作用。 //标注当前类是配置类，替代application.xml @Configuration//引入jdbc.properties文件@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)public class MyConfiguration &#123; //如果第三方类进行IoC管理,无法直接使用@Component相关注解 //解决方案: xml方式可以使用&lt;bean标签 //解决方案: 配置类方式,可以使用方法返回值+@Bean注解 @Bean public DataSource createDataSource(@Value(&quot;$&#123;jdbc.user&#125;&quot;) String username, @Value(&quot;$&#123;jdbc.password&#125;&quot;)String password, @Value(&quot;$&#123;jdbc.url&#125;&quot;)String url, @Value(&quot;$&#123;jdbc.driver&#125;&quot;)String driverClassName)&#123; //使用Java代码实例化 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); //返回结果即可 return dataSource; &#125;&#125; 4.4.4 实验三：高级特性：@Bean注解细节 @Bean生成BeanName问题 默认就是方法名 @Bean注解源码： public @interface Bean &#123; //前两个注解可以指定Bean的标识 //可以是哦那个name或value标签指定名字 @AliasFor(&quot;name&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] name() default &#123;&#125;; //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。 //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标， //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。 boolean autowireCandidate() default true; //指定初始化方法 String initMethod() default &quot;&quot;; //指定销毁方法 String destroyMethod() default &quot;(inferred)&quot;;&#125; 指定@Bean的名称： @Configurationpublic class AppConfig &#123; @Bean(&quot;myThing&quot;) //指定名称 public Thing thing() &#123; return new Thing(); &#125;&#125; @Bean 注释方法。 使用此方法在指定为方法返回值的类型的 ApplicationContext 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 @Bean 方法声明： @Configurationpublic class AppConfig &#123; @Bean public TransferServiceImpl transferService() &#123; return new TransferServiceImpl(); &#125;&#125; 前面的配置完全等同于下面的Spring XML： &lt;beans&gt; &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;&lt;/beans&gt; @Bean 初始化和销毁方法指定 @Bean 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 bean 元素上的 init-method 和 destroy-method 属性，如以下示例所示： public class BeanOne &#123; public void init() &#123; // initialization logic &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = &quot;init&quot;) public BeanOne beanOne() &#123; return new BeanOne(); &#125; @Bean(destroyMethod = &quot;cleanup&quot;) public BeanTwo beanTwo() &#123; return new BeanTwo(); &#125;&#125; @Bean Scope作用域 可以指定使用 @Bean 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。 默认作用域为 singleton ，但您可以使用 @Scope 注释覆盖此范围，如以下示例所示： @Configurationpublic class MyConfiguration &#123; @Bean @Scope(&quot;prototype&quot;) public Encryptor encryptor() &#123; // ... &#125;&#125; @Bean方法之间依赖 准备组件 public class HappyMachine &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125;&#125; public class HappyComponent &#123; //引用新组件 private HappyMachine happyMachine; public HappyMachine getHappyMachine() &#123; return happyMachine; &#125; public void setHappyMachine(HappyMachine happyMachine) &#123; this.happyMachine = happyMachine; &#125; public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125;&#125; Java配置类实现： 方案1： 直接调用方法返回 Bean 实例：在一个 @Bean 方法中直接调用其他 @Bean 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如： @Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; @Bean public HappyComponent happyComponent()&#123; HappyComponent happyComponent = new HappyComponent(); //直接调用方法即可! happyComponent.setHappyMachine(happyMachine()); return happyComponent; &#125;&#125; 方案2： 参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系，例如： package com.spring.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;/** * @author: Qyingli * @projectName: SSM-Spring-Part * @package: com.spring.config * description:java的配置类,替代xml配置文件 * 1. 包扫描注解配置 * 2. 外部引用的配置文件 * 3. 第三方依赖的Bean组件 * * 步骤1: 添加@Configuration 代表我们是配置类 * 步骤2: 实现上面的三个功能注释 */@Configuration //声明为配置类@ComponentScan(&#123;&quot;com.spring.ioc_01&quot;&#125;) //扫描包@PropertySource(value = &quot;classpath:jdbc.properties&quot;) //引用外部配置public class JavaConfiguration &#123; @Value(&quot;$&#123;qyingli.url&#125;&quot;) private String url; @Value(&quot;$&#123;qyingli.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;qyingli.username&#125;&quot;) private String username; @Value(&quot;$&#123;qyingli.password&#125;&quot;) private String password; /** * * &lt;bean -》 一个方法 * * 方法的返回值类型 == bean组件的类型或者他的接口和父类 * 方法的名字 = bean id * * 方法体可以自定义实现过程即可！ * 最重要一步： @Bean 会真正让配置类的方法创建的组件存储到ioc容器！！ * * * 问题1： beanName的问题 * 默认： 方法名 * 指定： name / value属性起名字，覆盖方法名 * 问题2： 周期方法如何指定 * 原有注解方案： PostConstruct + PreDestroy 注解指定 * bean属性指定： initMethod / destroyMethod指定 * 问题3： 作用域 * 和以前还是一样@Scope注解，默认是单例 * * 问题4： 如何引用其他的ioc组件 * 直接调用对方的bean方法即可 * 直接形参变量进行引入，要求必须有对应的组件，如果有多个，形参名 = 组件id标识即可 */ //@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) @Bean(name = &quot;ergouzi&quot;) public DruidDataSource dataSource1()&#123; //实现具体的实例化过程 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driver); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean(name = &quot;lvdandan&quot;) public DruidDataSource dataSource2()&#123; //实现具体的实例化过程 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driver); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; //JdbcTemplate -&gt; DataSource @Bean public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); //需要DataSource 需要ioc容器的其他组件 //方案1： 如果其他组件也是@Bean方法，可以直接调用 | 看似直接调用, 实际上是从ioc容器获取组件, 不推荐 jdbcTemplate.setDataSource(dataSource1()); return jdbcTemplate; &#125; @Bean public JdbcTemplate jdbcTemplate1(DataSource lvdandan, DataSource ergouzi)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); //需要DataSource 需要ioc容器的其他组件 //方案2： 形参列表声明想要的组件类型，可以是一个也可以是多个！ ioc容器也会注入 //如果没有：形参变量注入。要求必须有对应的类型的组件(DataSource)，如果没有抛异常！ //如果有多个：可以使用形参名称等同于对应的beanId标识即可 jdbcTemplate.setDataSource(lvdandan); return jdbcTemplate; &#125;&#125; 4.4.5 实验四：高级特性：@Import扩展 @Import 注释允许从另一个配置类加载 @Bean 定义，如以下示例所示： 有多个配置类时, ioc容器得加载每一个配置类. @import可以将注解加载到一个配置类当中 @Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B b() &#123; return new B(); &#125;&#125; 现在，在实例化上下文时不需要同时指定 ConfigA.class 和 ConfigB.class ，只需显式提供 ConfigB ，如以下示例所示： public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class);&#125; 此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 @Configuration 类。 4.4.6 实验五：基于注解+配置类方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用注解+配置类方式进行组件管理！ 项目准备 项目创建 spring-java-practice-06 依赖导入 三层架构搭建和实现 持久层 //接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类@Repositorypublic class StudentDaoImpl implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层 //接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层 @Controllerpublic class StudentController &#123; @Autowired private StudentService studentService; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置类 @Configuration@ComponentScan(basePackages = &quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; @Bean(destroyMethod = &quot;close&quot;) public DruidDataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driver); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125;&#125; 运行测试 public class ControllerTest &#123; @Test public void testRun()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125;&#125; 注解+配置类 IoC方式总结 完全摒弃了XML配置文件 自定义类使用IoC和DI注解标记 第三方类使用配置类声明方法+@Bean方式处理 完全注解方式（配置类+注解）是现在主流配置方式 4.5 三种配置方式总结4.5.1 XML方式配置总结 所有内容写到xml格式配置文件中 声明bean通过&lt;bean标签 &lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref 引入外部的properties文件可以通过&lt;context:property-placeholder IoC具体容器实现选择ClassPathXmlApplicationContext对象 4.5.2 XML+注解方式配置总结 注解负责标记IoC的类和进行属性装配 xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围 标记IoC注解：@Component,@Service,@Controller,@Repository 标记DI注解：@Autowired @Qualifier @Resource @Value IoC具体容器实现选择ClassPathXmlApplicationContext对象 4.5.3 完全注解方式配置总结 完全注解方式指的是去掉xml文件，使用配置类 + 注解实现 xml文件替换成使用@Configuration注解标记的类 标记IoC注解：@Component,@Service,@Controller,@Repository 标记DI注解：@Autowired @Qualifier @Resource @Value &lt;context:component-scan -&gt; 指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代 &lt;context:property-placeholder引入外部配置文件 -&gt; @PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代 &lt;bean 标签使用 -&gt; @Bean注解和方法实现 IoC具体容器实现选择AnnotationConfigApplicationContext对象 4.6 整合Spring5-Test5搭建测试环境 整合测试环境作用 好处1：不需要自己创建IOC容器对象了 好处2：任何需要的bean都可以在测试类中直接享受自动装配 导入相关依赖 &lt;!--junit5测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 整合测试注解使用 //@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;) //指定配置文件xml@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;) //指定配置类public class Junit5IntegrationTest &#123; @Autowired private User user; @Test public void testJunit5() &#123; System.out.println(user); &#125;&#125; 五、Spring AOP面向切面编程5.1 场景设定和问题复现 准备AOP项目 项目名：spring-aop-annotation pom.xml 声明接口 /** * + - * / 运算的标准接口! */public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 接口实现 /** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */public class CalculatorPureImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; 声明带日志接口实现 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！ package com.atguigu.proxy;/** * 在每个方法中,输出传入的参数和计算后的返回结果! */public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 代码问题分析 代码缺陷 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！ 解决思路 核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 将重复的代码统一提取，并且&#x3D;&#x3D;[动态插入]&#x3D;&#x3D;到每个业务方法！ 技术困难 解决问题的困难：提取重复附加功能代码到一个类中，可以实现 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！ 5.2 解决 技术代理模式 代理模式 二十三种设计模式中的一种，属于结构型模式。 它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 无代理场景： 有代理场景： 生活中的代理： 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 太监是大臣和皇上之间的代理 ​ ​ 相关术语： 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介) 动词：指做代理这个动作，或这项工作 名词：扮演代理这个角色的类、对象、方法 目标：被代理“套用”了核心逻辑代码的类、对象、方法。(房东) ​ 代理在开发中实现的方式具体有两种：静态代理，[动态代理技术] 静态代理: 房东每次去都点找小红 动态代码: 自动分配中介给房东 静态代理 主动创建代理类： /** * @author: Qyingli * @projectName: SSM-Spring-Part * @package: com.spring.statics * description: 静态代理类[中介] , 自己创建代理类 */public class StaticProxyCalculator implements Calculator &#123; private Calculator calculator; //使用构造函数传入目标(房东) public StaticProxyCalculator(Calculator target) &#123; this.calculator = target; &#125; @Override public int add(int i, int j) &#123; //非核心业务 中介使用 System.out.println(&quot;i = &quot; + i + &quot;, j = &quot; + j); //调用目标 int result = calculator.add(1, 1); System.out.println(&quot;result = &quot; + result); return result; &#125;&#125; ​ 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 ​ 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。3. 动态代理 动态代理技术分类 - JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须**实现接口**！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子） - cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹） ![image-20240305120349860](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202403051203062.png) JDK动态代理技术实现（了解） ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img003.2fe524a2.png) 代理工程：基于jdk代理技术，生成代理对象 /** * jdk动态代理工厂 */public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); //使用了匿名内部类 InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; ​ 测试代码： @Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 代理总结 代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！ 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！ 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！ 需要自己编写代理工厂等！&#x3D;&#x3D;经典白雪&#x3D;&#x3D; 但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架， 他会简化动态代理的实现！！！ 5.3 面向切面编程思维（AOP） 面向切面编程思想AOP AOP：Aspect Oriented Programming面向切面编程 AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。 不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。 日志代码往往横向地散布在所有对象层次中，而与它对应的&#x3D;&#x3D;对象的核心功能毫无关系对于其他类型的代码&#x3D;&#x3D;，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。 所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。底层就是代理技术 &#x3D;&#x3D;使用AOP，可以在不修改原来代码的基础上添加新功能。&#x3D;&#x3D; 类似来说就像洋葱, 将每一层中重复的代码抽离出来, 整合到一个模块当中 AOP思想主要的应用场景 AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。 常见的AOP应用场景： 日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。 事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。 安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。 性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。 异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。 缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。 动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。 AOP术语名词介绍 1-横切关注点 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 AOP把软件系统分为两个部分：&#x3D;&#x3D;核心关注点和横切关注点。&#x3D;&#x3D;业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。 横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2-通知(增强)Advice 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ​ ​ 3-连接点 joinpoint ​ 这也是一个纯逻辑概念，不是语法定义的。 ​ &#x3D;&#x3D;指那些被拦截到的点。&#x3D;&#x3D;在 Spring 中，可以被动态代理拦截目标类的方法 ​ ​ 4-切入点 pointcut ​ 定位连接点的方式，或者可以理解成&#x3D;&#x3D;被选中的连接点！&#x3D;&#x3D; ​ 是一个表达式，比如execution(* com.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点。 ​ ​ 5-切面 aspect ​ 切入点和通知的结合。是一个类。 ​ ​ 6-目标 target ​ 被代理的目标对象。 ​ 7-代理 proxy ​ 向目标对象应用通知之后创建的代理对象。 ​ 8-织入 weave ​ 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。 AOP的整个过程解释: 5.4 Spring AOP框架介绍和关系梳理 AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！ 代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！ Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！ 5.5 Spring AOP基于注解方式实现和细节5.5.1 Spring AOP底层技术组成 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。 5.5.2 初步实现 加入依赖 &lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework &lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 准备接口 public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 纯净实现类 /** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */@Componentpublic class CalculatorPureImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; 声明切面类 package com.atguigu.advice;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123; // @Before注解：声明当前方法是前置通知方法 // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上 @Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;); &#125; @AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;); &#125; @AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;); &#125; @After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;); &#125; &#125; 开启aspectj注解支持 xml方式 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 进行包扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; /&gt; &lt;!-- 开启aspectj框架注解支持--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; ​ 2. 配置类方式 @Configuration@ComponentScan(basePackages = &quot;com.atguigu&quot;)//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!@EnableAspectJAutoProxypublic class MyConfig &#123;&#125; 测试效果 //@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; calculator.add(1,1); &#125;&#125; ​ 输出结果： [AOP前置通知] 方法开始了[AOP返回通知] 方法成功返回了[AOP后置通知] 方法最终结束了 5.5.3 获取通知细节信息 JointPoint接口 可以知道是哪个方法的通知信息. 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。 要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息） 要点2：通过目标方法签名对象获取方法名 要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组 package com.spring.advance;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.lang.reflect.Modifier;/** * * @author: 赵伟风 * description: 定义四个增强方法,获取目标方法的信息 返回值 异常对象 * * 1.定义方法 - 增强代码 * 2.使用注解指定对应的位置 * 3.配置切点表达式选中方法 * 4.切面和ioc的配置 * 5.开启aspectj注解的支持 * * NOTE: 增强方法中获取目标方法信息 * 1. 全部增强方法中,获取目标方法的信息(方法名,参数,访问修饰符,所属的类的信息...) * (JoinPoint jointPoint) import org.aspectj.lang.JoinPoint; * joinPoint包含目标方法的信息! * 2. 返回的结果 - @AfterReturning * (Object result) result接收返回结果 * @AfterReturning(value = &quot;execution(* com..impl.*.*(..))&quot;,returning = &quot;形参名即可&quot;) * 3. 异常的信息 - @AfterThrowing * (Throwable t) t接收异常信息 * @AfterThrowing(value = &quot;execution(* com..impl.*.*(..))&quot;,throwing = &quot;形参名即可&quot;) *///@Component//@Aspectpublic class MyAdvance &#123; @Before(&quot;com.spring.pointcut.MyPointCut.myPointcut()&quot;) public void before(JoinPoint jointPoint)&#123; //1.获取方法属于的类的信息 String simpleName = jointPoint.getTarget().getClass().getSimpleName(); //2.获取方法名称 int modifiers = jointPoint.getSignature().getModifiers(); String s = Modifier.toString(modifiers); String name = jointPoint.getSignature().getName(); //获取方法名 //3.获取参数列表 Object[] args = jointPoint.getArgs(); //获取目标方法参数 &#125;\t//使用result接受方法的返回结果 @AfterReturning(value = &quot;com.spring.pointcut.MyPointCut.myPointcut()&quot;, returning = &quot;result&quot;) public void afterReturning(JoinPoint jointPoint, Object result)&#123; &#125; @After(&quot;com.spring.pointcut.MyPointCut.myPointcut()&quot;) public void after(JoinPoint jointPoint)&#123; &#125;\t//使用throwalbe接受异常信息 @AfterThrowing(value = &quot;com.spring.pointcut.MyPointCut.myPointcut()&quot;, throwing = &quot;throwable&quot;) public void afterThrowing(JoinPoint jointPoint,Throwable throwable)&#123; &#125;&#125; 方法返回值 在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！ // @AfterReturning注解标记返回通知方法// 在返回通知中获取目标方法返回值分两步：// 第一步：在@AfterReturning注解中通过returning属性设置一个名称// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参@AfterReturning( value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;, returning = &quot;targetMethodReturnValue&quot;)public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);&#125; 异常对象捕捉 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象 // @AfterThrowing注解标记异常通知方法// 在异常通知中获取目标方法抛出的异常分两步：// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们@AfterThrowing( value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;, throwing = &quot;targetMethodException&quot;)public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());&#125; 5.5.4 切点表达式语法 切点表达式作用 AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。 ​ 2. 切点表达式语法 切点表达式总结 ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img011.dde1a79a.png) 语法细节 - 第一位：execution( ) 固定开头 - 第二位：方法访问修饰符 public private 直接描述对应修饰符即可 ​ - 第三位：方法返回值 int String void 直接描述返回值类型 ​ 注意： ​ 特殊情况 不考虑 访问修饰符和返回值 ​ execution(* * ) 这是错误语法 ​ execution(*) &#x3D;&#x3D; 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了​ - 第四位：指定包的地址 固定的包: com.atguigu.api | service | dao单层的任意命名: com.atguigu.* = com.atguigu.api com.atguigu.dao * = 任意一层的任意命名任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a ..任意层,任意命名 用在包上!注意: ..不能用作包开头 public int .. 错误语法 com..找到任何包下: *.. ​ - 第五位：指定类名称 固定名称: UserService任意类名: *部分任意: com..service.impl.*Impl任意包任意类: *..* ​ - 第六位：指定方法名称 语法和类名一致任意访问修饰符,任意类的任意方法: * *..*.* ​ - 第七位：方法参数 第七位: 方法的参数描述 具体值: (String,int) != (int,String) 没有参数 () 模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊: 第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String) 字符串开头,int结尾 (String..int) 包含int类型(..int..) 切点表达式案例 * 1.查询某包某类下，访问修饰符是公有，返回值是int的全部方法 * public int xx.xx.jj.*(..), x为包, j为类 * 2.查询某包下类中第一个参数是String的方法 * * xx.xx.jj.*(String..) * 3.查询全部包下，无参数的方法！ * * *..*.*() * 4.查询com包下，以int参数类型结尾的方法 * * com..*.*(..int) * 5.查询指定包下，Service开头类的私有返回值int的无参数方法 * private int xx.xx.Service*.*() * */ 5.5.5 重用（提取）切点表达式 重用切点表达式优点 // @Before注解：声明当前方法是前置通知方法// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);&#125;@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;);&#125;@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;);&#125;@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);&#125; ​ 上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！ ​ 出现了冗余，如果需要切换也不方便统一维护！ ​ 我们可以将切点提取，在增强上进行引用即可！ 2. 同一类内部引用 提取 // 切入点表达式重用@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))&quot;)public void declarPointCut() &#123;&#125; ​ 注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！ ​ 引用 @Before(value = &quot;declarPointCut()&quot;)public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123; 不同类中引用 不同类在引用切点，只需要添加类的全限定符+方法名即可！ @Before(value = &quot;com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()&quot;)public Object roundAdvice(ProceedingJoinPoint joinPoint) &#123; 切点统一管理 建议：将切点表达式统一存储到一个类中进行集中管理和维护！ @Componentpublic class AtguiguPointCut &#123; @Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;) public void atguiguGlobalPointCut()&#123;&#125; @Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;) public void atguiguSecondPointCut()&#123;&#125; @Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;) public void transactionPointCut()&#123;&#125;&#125; 5.5.6 环绕通知 环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。 // 使用@Around注解标明环绕通知方法@Around(value = &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)public Object manageTransaction( // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参， // Spring会将这个类型的对象传给我们 ProceedingJoinPoint joinPoint) &#123; // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组 Object[] args = joinPoint.getArgs(); // 通过ProceedingJoinPoint对象获取目标方法的签名对象 Signature signature = joinPoint.getSignature(); // 通过签名对象获取目标方法的方法名 String methodName = signature.getName(); // 声明变量用来存储目标方法的返回值 Object targetMethodReturnValue = null; try &#123; // 在目标方法执行前：开启事务（模拟） log.debug(&quot;[AOP 环绕通知] 开启事务，方法名：&quot; + methodName + &quot;，参数列表：&quot; + Arrays.asList(args)); // 过ProceedingJoinPoint对象调用目标方法 // 目标方法的返回值一定要返回给外界调用者 targetMethodReturnValue = joinPoint.proceed(args); // 在目标方法成功返回后：提交事务（模拟） log.debug(&quot;[AOP 环绕通知] 提交事务，方法名：&quot; + methodName + &quot;，方法返回值：&quot; + targetMethodReturnValue); &#125;catch (Throwable e)&#123; // 在目标方法抛异常后：回滚事务（模拟） log.debug(&quot;[AOP 环绕通知] 回滚事务，方法名：&quot; + methodName + &quot;，异常：&quot; + e.getClass().getName()); &#125;finally &#123; // 在目标方法最终结束后：释放数据库连接 log.debug(&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot; + methodName); &#125; return targetMethodReturnValue;&#125; 5.5.7 切面优先级设置 相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用 @Order 注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 实际意义 实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。 ​ 此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。 5.5.8 CGLib动态代理生效 在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试： @Servicepublic class EmployeeService &#123; public void getEmpList() &#123; System.out.print(&quot;方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList&quot;); &#125;&#125; 测试： @Autowiredprivate EmployeeService employeeService;@Testpublic void testNoInterfaceProxy() &#123; employeeService.getEmpList();&#125; 没有接口： 有接口： 使用总结： ​ a. 如果目标类有接口,选择使用jdk动态代理 ​ b. 如果目标类没有接口,选择cglib动态代理 ​ c. 如果有接口,接口接值 ​ d. 如果没有接口,类进行接值 5.5.9 注解实现小结AOP的第一步是先写核心代码, 再去定义非核心代码 5.6 Spring AOP基于XML方式实现(了解) 准备工作 加入依赖 和基于注解的 AOP 时一样。 准备代码 把测试基于注解功能时的Java类复制到新module中，去除所有注解。 配置Spring配置文件 &lt;!-- 配置目标类的bean --&gt;&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt; &lt;!-- 配置切面类的bean --&gt;&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt; &lt;!-- 配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt; &lt;!-- aop:aspect标签：配置切面 --&gt; &lt;!-- ref属性：关联切面类的bean --&gt; &lt;aop:aspect ref=&quot;logAspect&quot;&gt; &lt;!-- aop:before标签：配置前置通知 --&gt; &lt;!-- method属性：指定前置通知的方法名 --&gt; &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt; &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:after-returning标签：配置返回通知 --&gt; &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt; &lt;aop:after-returning method=&quot;printLogAfterCoreSuccess&quot; pointcut-ref=&quot;logPointCut&quot; returning=&quot;targetMethodReturnValue&quot;/&gt; &lt;!-- aop:after-throwing标签：配置异常通知 --&gt; &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt; &lt;aop:after-throwing method=&quot;printLogAfterCoreException&quot; pointcut-ref=&quot;logPointCut&quot; throwing=&quot;targetMethodException&quot;/&gt; &lt;!-- aop:after标签：配置后置通知 --&gt; &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:around标签：配置环绕通知 --&gt; &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试 @SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; System.out.println(calculator); calculator.add(1,1); &#125;&#125; 5.7 Spring AOP对获取Bean的影响理解5.7.1 根据类型装配 bean 情景一 bean 对应的类没有实现任何接口 根据 bean 本身的类型获取 bean 测试：IOC容器中同类型的 bean 只有一个 正常获取到 IOC 容器中的那个 bean 对象 测试：IOC 容器中同类型的 bean 有多个 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 情景二 bean 对应的类实现了接口，这个接口也只有这一个实现类 测试：根据接口类型获取 bean 测试：根据类获取 bean 结论：上面两种情况其实都能够正常获取到 bean，而且是同一个对象 情景三 声明一个接口 接口有多个实现类 接口所有实现类都放入 IOC 容器 测试：根据接口类型获取 bean 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 测试：根据类获取bean 正常 情景四 声明一个接口 接口有一个实现类 创建一个切面类，对上面接口的实现类应用通知 测试：根据接口类型获取bean 正常 测试：根据类获取bean 无法获取 原因分析： 应用了切面后，真正放在IOC容器中的是代理类的对象 目标类并没有被放到IOC容器中，所以根据目标类的类型从IOC容器中是找不到的 情景五 声明一个类 创建一个切面类，对上面的类应用通知 用的是cglib 测试：根据类获取 bean，能获取到 debug查看实际类型： 5.7.2 使用总结 对实现了接口的类应用切面, 这时候放入ioc容器的是接口的代理类而不是接口本身 对没实现接口的类应用切面new 如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！ 理解AOP思维, 横切关注点 框架封装了代理技术 注解方式进行AOP配置 六、Spring 声明式事务6.1 声明式事务概念Spring 框架提供了强大而灵活的事务管理功能，旨在帮助开发者管理应用程序中的事务。事务管理是确保一组操作要么全部成功，要么全部失败的一种机制，这在处理数据库操作时尤为重要。 事务管理的基本概念 事务（Transaction）：一组逻辑上的操作单元，这些操作要么全部执行成功，要么全部执行失败回滚。 ACID 属性： 原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败回滚。 一致性（Consistency）：事务完成后，数据库从一个一致性状态转到另一个一致性状态。 隔离性（Isolation）：事务之间彼此隔离，避免相互干扰。 持久性（Durability）：事务完成后，其结果是持久的，即使系统崩溃也不会丢失。 Spring 事务管理的类型Spring 支持两种主要的事务管理类型： 编程式事务管理：开发者显式地在代码中控制事务的开始、提交和回滚。 声明式事务管理：通过注解或 XML 配置进行事务管理，减少了样板代码，使事务管理更加简洁和易维护。 声明式事务管理声明式事务管理是 Spring 事务管理的推荐方式。它主要使用注解或 XML 配置来定义事务的范围和属性。 使用注解进行事务管理 @Transactional 注解：这个注解可以应用在类或方法上，表示该类或方法中的所有操作都在一个事务中运行。 import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class UserService &#123; @Transactional public void createUser(User user) &#123; // 方法中的所有操作将在一个事务中运行 userRepository.save(user); accountRepository.save(user.getAccount()); &#125;&#125; 事务属性：@Transactional 注解可以配置多种属性，如： propagation：事务的传播行为，例如 REQUIRED、REQUIRES_NEW 等。 isolation：事务的隔离级别，例如 READ_COMMITTED、SERIALIZABLE 等。 timeout：事务的超时时间（秒）。 readOnly：是否为只读事务。 rollbackFor：指定遇到哪些异常时回滚事务。 noRollbackFor：指定遇到哪些异常时不回滚事务。 @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, timeout = 30, readOnly = false)public void createUser(User user) &#123; userRepository.save(user); accountRepository.save(user.getAccount());&#125; 使用 XML 配置进行事务管理可以在 Spring 的 XML 配置文件中定义事务管理： &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;createUser&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;READ_COMMITTED&quot; timeout=&quot;30&quot; read-only=&quot;false&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;userServiceMethods&quot; expression=&quot;execution(* com.example.service.UserService.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;userServiceMethods&quot;/&gt;&lt;/aop:config&gt; 事务管理器Spring 提供了多种事务管理器实现，以支持不同类型的数据访问技术： DataSourceTransactionManager：用于 JDBC 事务管理。 HibernateTransactionManager：用于 Hibernate 事务管理。 JpaTransactionManager：用于 JPA 事务管理。 JtaTransactionManager：用于 JTA（Java 事务 API）事务管理，适用于分布式事务。 配置事务管理器通常在 Spring 的配置文件中定义事务管理器： &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 总结Spring 的事务管理机制提供了一种简洁而强大的方式来确保数据操作的一致性和完整性。通过使用声明式事务管理，开发者可以专注于业务逻辑，而不用担心底层的事务处理细节。这种方式不仅减少了样板代码，还增强了代码的可读性和维护性。 6.1.1 编程式事务 编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 PlatformTransactionManager)来实现编程式事务。 编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。 Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 业务代码 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 6.1.2 声明式事务 声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。&#x3D;&#x3D;对编程式的封装&#x3D;&#x3D; 开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！ 使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。 区别： 编程式事务需要手动编写代码来管理事务 而声明式事务可以通过配置文件或注解来控制事务。 将业务类的非核心代码抽出, 放入事务增强中, 但具体的实现不在里面, 而是用事务管理器接口(小霸王游戏机卡带), 里面有不同的方法, 最终的实现在不同的模块中, 比如是哪个数据库, 就把实现配到ioc容器当中 我们只需要选择合适的事务管理器实现加到ioc容器 指定那些方法需要添加事务即可 6.1.3 Spring事务管理器 Spring声明式事务对应依赖 spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等） spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等 Spring声明式事务对应事务管理器接口 事务管理器 -&gt; 事务管理器方法 -&gt; 具体实现 我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！ DataSourceTransactionManager类中的主要方法： doBegin()：开启事务 doSuspend()：挂起事务 doResume()：恢复挂起的事务 doCommit()：提交事务 doRollback()：回滚事务 6.2 基于注解的声明式事务6.2.1 准备工作 外部配置文件 jdbc.properties spring配置文件 @Configuration@ComponentScan(&quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; //druid连接池 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean //jdbcTemplate public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125;&#125; 准备dao&#x2F;service层 dao @Repositorypublic class StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void updateNameById(String name,Integer id)&#123; String sql = &quot;update students set name = ? where id = ? ;&quot;; int rows = jdbcTemplate.update(sql, name, id); &#125; public void updateAgeById(Integer age,Integer id)&#123; String sql = &quot;update students set age = ? where id = ? ;&quot;; jdbcTemplate.update(sql,age,id); &#125;&#125; ​ service @Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试环境搭建 /** * projectName: com.atguigu.test * * description: */@SpringJUnitConfig(JavaConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 6.2.2 基本事务控制 配置事务管理器 数据库相关的配置 /** * projectName: com.atguigu.config * * description: 数据库和连接池配置类 */@Configuration@ComponenScan(&quot;com.atguigu&quot;)@PropertySource(value = &quot;classpath:jdbc.properties&quot;)@EnableTransactionManagementpublic class DataSourceConfig &#123; /** * 实例化dataSource加入到ioc容器 * @param url * @param driver * @param username * @param password * @return */ @Bean public DataSource dataSource(@Value(&quot;$&#123;atguigu.url&#125;&quot;)String url, @Value(&quot;$&#123;atguigu.driver&#125;&quot;)String driver, @Value(&quot;$&#123;atguigu.username&#125;&quot;)String username, @Value(&quot;$&#123;atguigu.password&#125;&quot;)String password)&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; /** * 实例化JdbcTemplate对象,需要使用ioc中的DataSource * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; /** * 装配事务管理实现对象 * @param dataSource * @return */ @Bean public TransactionManager transactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 使用声明事务注解@Transactional /** * projectName: com.atguigu.service * */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; @Transactional public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); int i = 1/0; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试事务效果 /** * projectName: com.atguigu.test * * description: *///@SpringJUnitConfig(locations = &quot;classpath:application.xml&quot;)@SpringJUnitConfig(classes = DataSourceConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 6.2.3 事务属性：只读 只读介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 设置方式 // readOnly = true把当前事务设置为只读 默认是false!@Transactional(readOnly = true) 针对DML动作设置只读模式 会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed @Transactional注解放在类上 生效原则 如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。 对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。 用法举例 在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。 然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。 @Service@Transactional(readOnly = true)public class EmpService &#123; // 为了便于核对数据库操作结果，不要修改同一条记录 @Transactional(readOnly = false) public void updateTwice(……) &#123; …… &#125; // readOnly = true把当前事务设置为只读 // @Transactional(readOnly = true) public String getEmpName(Integer empId) &#123; …… &#125; &#125; 6.2.4 事务属性：超时时间 需求 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。 此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：&#x3D;&#x3D;超时回滚，释放资源。&#x3D;&#x3D; 设置超时时间 @Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo()&#123; studentDao.updateAgeById(100,1); //休眠4秒,等待方法超时! try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试超时效果 执行抛出事务超时异常 6.2.5 事务属性：事务异常 最大的异常是Throwable-&gt;下面是Eroor 和 Exception, Exception下分为运行时异常和编译异常 默认情况 &#x3D;&#x3D;默认只针对运行时异常回滚，编译时异常不回滚。&#x3D;&#x3D;&#x3D;情景模拟代码如下： @Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 设置回滚异常 rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚! /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1);&#125; 设置不回滚的异常 在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。 noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! @Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 6.2.6 事务属性：事务隔离级别 事务隔离级别 数据库事务的隔离级别是指在&#x3D;&#x3D;多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定&#x3D;&#x3D;。常见的隔离级别包括： 读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读(一个事务读取了另外一个事务未提交的数据)、不可重复读(一个事务读取了另一个事务提交的修改的数据)和幻读(….插入的数据)等问题。实现简单但不太安全，一般不用。 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。 不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。 事务隔离级别设置 package com.atguigu.service;import com.atguigu.dao.StudentDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Transactional;import java.io.FileInputStream;import java.io.FileNotFoundException;/** * projectName: com.atguigu.service */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 6.2.7 事务属性：事务传播行为 事务传播行为要研究的问题 较晚执行的事务是否会加入较早执行的事务, 由事务的传播行为决定 举例代码： @Transactionalpublic void MethodA()&#123; // ... MethodB(); // ...&#125;//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！@Transactional(propagation = Propagation.REQUIRES_NEW)public void MethodB()&#123; // ...&#125; propagation属性 @Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是： Propagation propagation() default Propagation.REQUIRED; ​ propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供： 名称 含义 REQUIRED 默认值 如果父方法有事务，就加入，如果没有就新建自己独立！ REQUIRES_NEW 不管父方法是否有事务，我都新建事务，都是独立的！ 测试 声明两个业务方法 @Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125; /** * 声明两个独立修改数据库的事务业务方法 */ @Transactional(propagation = Propagation.REQUIRED) public void changeAge()&#123; studentDao.updateAgeById(99,1); &#125; @Transactional(propagation = Propagation.REQUIRED) public void changeName()&#123; studentDao.updateNameById(&quot;test2&quot;,1); int i = 1/0; &#125;&#125; ​ 2. 声明一个整合业务方法 @Servicepublic class TopService &#123; @Autowired private StudentService studentService; @Transactional public void topService()&#123; studentService.changeAge(); studentService.changeName(); &#125;&#125; ​ 3. 添加传播行为测试 @SpringJUnitConfig(classes = AppConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Autowired private TopService topService; @Test public void testTx() throws FileNotFoundException &#123; topService.topService(); &#125;&#125; ​ 注意： ​ 在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。 4. 其他传播行为值（了解） 1. Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。 2. Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。 3. Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。 4. Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。 5. Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。 6. Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。 7. Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。 七、Spring核心掌握总结重点是各种注解的记忆 核心点 掌握目标 spring框架理解 spring家族和spring framework框架 spring核心功能 ioc&#x2F;di , aop , tx spring ioc &#x2F; di 组件管理、ioc容器、ioc&#x2F;di , 三种配置方式 spring aop aop和aop框架和代理技术、基于注解的aop配置 spring tx 声明式和编程式事务、动态事务管理器、事务注解、属性","tags":["Java","Spring","Maven"],"categories":["记录","技术"]},{"title":"Java学习笔记 -第三阶段","path":"/2024/02/04/Java第三阶段/","content":"网络编程INetAddress类 Socket在古代，由于通信不便利，一些聪明的人就利用鸽子会飞且飞得比较快、会辨认方向的优点，对其进行了驯化，用来进行消息的传递——也就是所谓的“飞鸽传书”。而在 Java 中，网络套接字（Socket）扮演了同样的角色。 套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。 套接字允许应用程序将 I&#x2F;O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。 ping与telnetping，一种计算机网络工具，用来测试数据包能否透过 IP 协议到达特定主机。ping 会向目标主机发出一个 ICMP 的请求回显数据包，并等待接收回显响应数据包。 telnet，Internet 远程登录服务的标准协议和主要方式，可以让我们坐在家里的计算机面前，登录到另一台远在天涯海角的远程计算机上。 使用 telnet 登录远程计算机时，需要远程计算机上运行一个服务，它一直不停地等待那些希望和它进行连接的网络请求；当接收到一个客户端的网络连接时，它便唤醒正在监听网络连接请求的服务器进程，并为两者建立连接。连接会一直保持，直到某一方中止。 Socket实例package com.java3.netcode;import java.io.IOException;import java.io.InputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class INetAddress &#123; public static void main(String[] args) throws UnknownHostException &#123; InetAddress inetAddress = InetAddress.getLocalHost(); System.out.println(inetAddress); try (Socket socket = new Socket(&quot;bbs.newsmth.net&quot;, 23);) &#123; InputStream is = socket.getInputStream(); Scanner scanner = new Scanner(is, &quot;gbk&quot;); while (scanner.hasNextLine()) &#123; String line = scanner.nextLine(); System.out.println(line); &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ServerSocket实例我们模拟一个远程服务，通过 java.net.ServerSocket 实现。代码示例如下 TCP字节流编程 案例一 package com.java3.netcode.TCP;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.*;public class SocketTCPServer &#123; public static void main(String[] args) throws IOException &#123; //本机9999端口监听, 等待连接 //seversocket可以通过accept获取多个socket 多并发 ServerSocket socketServer = new ServerSocket(9999); System.out.println(&quot;socketServer等待连接&quot;); //客户端连接, 返回Socket对象 Socket socket = socketServer.accept(); System.out.println(&quot;socket2&quot; + socket.getClass()); //通过socket.getInputStream()读取客户端输入 InputStream inputStream = socket.getInputStream(); //io读取 byte[] buf = new byte[1024]; int len = 0; while((len = inputStream.read(buf)) != -1) &#123; System.out.println(new String(buf, 0, len)); &#125; //向客户端发送数据 OutputStream outputStream = socket.getOutputStream(); outputStream.write(&quot;hello client!&quot;.getBytes()); //设置结束标志 socket.shutdownOutput(); //关闭 inputStream.close(); outputStream.close(); socket.close(); System.out.println(&quot;close2&quot;); &#125;&#125; package com.java3.netcode.TCP;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.*;public class SocketTCPClient &#123; public static void main(String[] args) throws IOException &#123; //连接服务端ip, 端口 Socket socket = new Socket(InetAddress.getLocalHost(), 9999); System.out.println(&quot;socket1&quot; + socket.getClass()); //连接成功后, 生成Socket, 通过socket.getOutputStream( //得到和socket对象关联的输出流对象 OutputStream outputStream = socket.getOutputStream(); //通过输出流, 写入数据到数据通道 outputStream.write(&quot;hello world&quot;.getBytes()); //shotdown socket.shutdownOutput(); //接受服务端的数据 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = inputStream.read(bytes); while ( len &gt; 0) &#123; System.out.println(new String(bytes, 0, len)); len = inputStream.read(bytes); &#125; //关闭 outputStream.close(); inputStream.close(); socket.close(); System.out.println(&quot;close1&quot;); &#125;&#125; 使用字符流完成使用到转换流 //读取BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); System.out.println(reader.readLine());//写入 BufferedWriter buff = new BufferedWriter(new OutputStreamWriter(outputStream)); buff.write(&quot;hello server&quot;); buff.newLine(); buff.flush();// 结束标志 传输文件 String pathName = &quot;C:\\\\Users\\\\Qyingli\\\\Pictures\\\\1704866132027.jpg&quot;; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(pathName)); //文件转为字节数组 byte [] data = Toarray.streamToByteArray(bis); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); bos.write(data, 0, data.length); bos.close(); socket.shutdownOutput(); &#x2F;&#x2F;接受 //通过socket.getInputStream()读取客户端输入 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); byte[] bytes = Toarray.streamToByteArray(bis); //写入文件 String pathWrite = &quot;C:\\\\Users\\\\Qyingli\\\\Pictures\\\\17.jpg&quot;; BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(pathWrite)); bos.write(bytes, 0, bytes.length); //关闭 bos.close(); netstat指令 netstat -an 可以查看当前主机网络情况, 包括端口监听情况和网络连接情况 netstat -an | more 可以分页显示 dos下执行 反射一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 new 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。” Writer writer = new Writer();writer.setName(&quot;沉默王二&quot;); 像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 new 关键字创建对象了。 我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为反射。 Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);Method method = clazz.getMethod(&quot;setName&quot;, String.class);Constructor constructor = clazz.getConstructor();Object object = constructor.newInstance();method.invoke(object,&quot;沉默王二&quot;); 反射相对复杂,, 实现成本比正射高的多 破坏封装：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。 性能开销：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。 反射应用场景 开发通用框架：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。 动态代理：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。 注解：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。 一个例子: Writer类, 两个字段, 对应的方法 public class Writer &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 public class ReflectionDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Writer writer = new Writer(); writer.setName(&quot;沉默王二&quot;); System.out.println(writer.getName()); //第一步, 获取反射类Class对象 Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;); //第二步, 通过Class对象获取构造方法Constructor对象 Constructor constructor = clazz.getConstructor(); //第三步, 通过Constructor对象初始化反射类对象 Object object = constructor.newInstance(); //第四步, 获取要调用的方法的Menthod对象 Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class); setNameMethod.invoke(object, &quot;沉默王二&quot;); Method getNameMethod = clazz.getMethod(&quot;getName&quot;); System.out.println(getNameMethod.invoke(object)); &#125;&#125;//输出沉默王二沉默王二 第一步, 获取反射类Class对象 Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;); ava 中，Class 对象是一种特殊的对象，它代表了程序中的类和接口。 Java 中的每个类型（包括类、接口、数组以及基础类型）在 JVM 中都有一个唯一的 Class 对象与之对应。这个 Class 对象被创建的时机是在 JVM 加载类时，由 JVM 自动完成。 Class 对象中包含了与类相关的很多信息，如类的名称、类的父类、类实现的接口、类的构造方法、类的方法、类的字段等等。这些信息通常被称为元数据（metadata）。 除了前面提到的，通过类的全名获取 Class 对象，还有以下两种方式: 如果你有一个类的实例，你可以通过调用该实例的getClass()方法获取 Class 对象。例如：String str = &quot;Hello World&quot;; Class cls = str.getClass(); 如果你有一个类的字面量（即类本身），你可以直接获取 Class 对象。 例如：Class cls = String.class; 第二步, 通过Class对象获取构造方法Constructor对象 第三步, 通过Constructor对象初始化反射类对象 第四步, 获取要调用的方法的Menthod对象 第五步, 通过invoke执行 掌握反射的基本使用方法确实不难，但要理解整个反射机制还是需要花一点时间去了解一下 Java 虚拟机的类加载机制的。 想使用反射，首先需要获得反射类的 Class 对象，每一个类，不管它最终生成了多少个对象，这些对象只会对应一个 Class 对象，这个 Class 对象是由 Java 虚拟机生成的，由它来获悉整个类的结构信息。 就是说，java.lang.Class 是所有反射 API 的入口 而方法的反射调用，最终是由 Method 对象的 invoke() 方法完成的 ivoke() 方法实际上是委派给 MethodAccessor 接口来完成的。 MethodAccessor 接口有三个实现类，其中的 MethodAccessorImpl 是一个抽象类，另外两个具体的实现类继承了这个抽象类。 NativeMethodAccessorImpl：通过本地方法来实现反射调用； DelegatingMethodAccessorImpl：通过委派模式来实现反射调用； invoke() 方法在执行的时候，会先调用 DelegatingMethodAccessorImpl，然后调用 NativeMethodAccessorImpl，最后再调用实际的方法 为什么要用委派实现? 之所以采用委派实现，是为了能够在本地实现和动态实现之间切换。动态实现是另外一种反射调用机制，它是通过生成字节码的形式来实现的。如果反射调用的次数比较多，动态实现的效率就会更高，因为本地实现需要经过 Java 到 C&#x2F;C++ 再到 Java 之间的切换过程，而动态实现不需要；但如果反射调用的次数比较少，反而本地实现更快一些。 常用API获取反射类的Class对象Class.forName()，参数为反射类的完全限定名。 Class c1 = Class.forName(&quot;com.itwanger.s39.ReflectionDemo3&quot;);System.out.println(c1.getCanonicalName());Class c2 = Class.forName(&quot;[D&quot;);System.out.println(c2.getCanonicalName());Class c3 = Class.forName(&quot;[[Ljava.lang.String;&quot;);System.out.println(c3.getCanonicalName());//输出com.itwanger.s39.ReflectionDemo3double[]java.lang.String[][] 类名 + .class，只适合在编译前就知道操作的 Class。 Class c1 = ReflectionDemo3.class;System.out.println(c1.getCanonicalName());Class c2 = String.class;System.out.println(c2.getCanonicalName());Class c3 = int[][][].class;System.out.println(c3.getCanonicalName());//输出com.itwanger.s39.ReflectionDemo3java.lang.Stringint[][][] 使用类对象的getClass()方法 String str = new String(&quot;Hello&quot;);Class clz = str.getClass(); 通过反射创建类对象通过反射来创建对象的方式有两种： 用 Class 对象的 newInstance() 方法。 用 Constructor 对象的 newInstance() 方法 Class c1 = Writer.class;Writer writer = (Writer) c1.newInstance();Class c2 = Class.forName(&quot;com.itwanger.s39.Writer&quot;);Constructor constructor = c2.getConstructor();Object object = constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。 获取构造器, 属性, 方法Class 对象提供了以下方法来获取构造方法 Constructor 对象： getConstructor()：返回反射类的特定 public 构造方法，可以传递参数，参数为构造方法参数对应 Class 对象；缺省的时候返回默认构造方法。 getDeclaredConstructor()：返回反射类的特定构造方法，不限定于 public 的。 getConstructors()：返回类的所有 public 构造方法。 getDeclaredConstructors()：返回类的所有构造方法，不限定于 public 的 Class c2 = Class.forName(&quot;com.itwanger.s39.Writer&quot;);Constructor constructor = c2.getConstructor();Constructor[] constructors1 = String.class.getDeclaredConstructors();for (Constructor c : constructors1) &#123; System.out.println(c);&#125; 大体上和获取构造方法类似，把关键字 Constructor 换成 Field, Method即可。 Class clz = Apple.class;Field[] fields = clz.getFields();for (Field field : fields) &#123; System.out.println(field.getName());&#125; 坦克大战第一部分Java绘图坐标体系上传错误: 关闭数据万象服务 绘图原理 通讯系统项目开发流程需求分析 需求分析师: 懂技术 + 行业 出一个需求分析报告(白皮书), 该项目功能, 客户具体要求 设计阶段 架构师&#x2F;项目经理 设计工作(UML类图, 流程图, 模块设计, 数据库, 架构) 原型开发 组建团队 实现阶段 程序员 完成架构师的模块功能 测试自己的模块 测试阶段 测试工程师 单元测试, 测试用例 ​\t白盒测试, 黑盒测试, 集成测试 实施阶段 实施工程师 项目正确的部署到客户的平台, 保证正常运行 维护阶段 发现bug解决, 项目升级 多用户版及时通信系统需求分析 用户登录 拉取在线用户列表 无异常退出 私聊 群聊 发文件 服务器推送新闻 思路分析 每个线程持有一个socket 通讯用对象流 服务器线程太多时, 需要一个集合来管理 客户端也可能与服务端有多个连接, 也需要一个管理线程的集合","tags":["Java"],"categories":["记录"]},{"title":"Java学习笔记 -第二阶段","path":"/2023/12/22/Java第二阶段/","content":"第十章 面向对象高级类变量和类方法(静态)可以在类任何地方用 类变量可以用类名访问 内存布局 static变量是对象共享,不管static变量在哪里 static变量在类加载的时候就生成了 访问类名.类变量名 对象名.类变量名(推荐) 细节 什么时候使用? 当我们需要让某個类的所有对象都共享一个变量 生命周期随着类 类方法使用 当方法中不涉及 到任何和对象相关的成员,则可以将方法设计成静态方法,提高开发效率(不需要创 建对象就可以使用). 比如工具类方法Math, Array 类方法细节 类方法和普通方法都是随着类的加载而加载,将结构信息存储在方法区 类方法中无this参数, 也没有super 普通方法可对象有关,需要通过对象调用(必须在堆中开辟空间) 类方法只能访问静态变量和方法, 而普通成员都可以 main方法语法 Java虚拟机需要调用类的main方法,所以访问权限必须是public Java虚拟机在执行main方法时不必创建对象,所以方法必须是static 该方法接受String类型的数组参数, 该数组中保存执行Java命令时传递给所有运行类的参数 Java执行的程序参数1 参数2 参数3 args[]可以接收参数以字符串输出 main方法中不能使用非静态成员 代码块代码块属于类中成员,类似于方法, 将逻辑语句封装在方法体中. 没有方法名, 返回, 参数, 只有方法体, 不通过对象或者类显式调用, 而是加载类时, 或创建对象时隐式调用 [修饰符]&#123;&#125;; 只能写static 分号可以省略 好处 相当于另一种形式的构造器, 或者是对构造器的补充, 可以做初始化的操作 应用场景: 如果多个构造器中都有重复的语句, 可以抽取出来到初始化代码块中, 提高复用率 细节 static代码块作用就是对类进行初始化, 随着类的加载而执行, 只执行一次. 普通代码对象创建时执行 类什么时候加载! ! ! : 创建对象实例 创建子类对象实例, 父类会先加载 使用类的静态成员方法 普通的代码块, 在创建对象实例时, 会被隐式调用, 被创建一次就会被调用一次. 如果只是使用静态的成员时, 普通的代码块不会被调用 创建一次对象时, 在一个类的调用顺序是 ! ! !: 静态代码静态属性初始化 普通代码和属性初始化 构造方法 构造器的最前面隐含了super()和调用和普通代码块, super(); 本类普通代码块 构造器语句; 具有继承关系时, 他们的调用顺序: 单例设计模式 它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。 //饿汉式(对象创建了,还没有用)public class Singleton &#123; // 在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快 private Static String name; private static Singleton instance = new Singleton(); //1.构造器私有化 //2.在内部创建,静态是为了在静态方法中调用 private Singleton(String name) &#123; this.name = name; &#125; public static Singleton getInstance() &#123; return instance; //2. 公共静态方法返回对象 &#125; &#125;//懒汉式(使用时再创建)public class Singleton &#123; // 类加载时不初始化 private static Singleton instance; private Singleton() &#123; &#125; // 调用时初始化，线程不安全，需要加锁处理 //提供公共方法返回对象 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; final关键字需要用到final的情况: 当不希望类被继承 不希望父类的某个方法被子类覆盖&#x2F;重写 不希望某个局部变量被修改 细节 final修饰的属性又叫常量, 一般用XX_XX命名 创建时必须初始化 定义时 构造器中 代码块中 final修饰的属性是静态的, 则初始化的位置只能是: 定义时 静态代码块中, 不能在构造器中赋值, 静态的加载在构造器之前 final类不能继承, 但可以实例化对象 如果类不是final类, 但是含有final方法, 则该方法不能重写, 但可以继承 一般来说, 如果类已经是final了, 方法就没必要再修饰final了. 因为类无法被继承, 自然也就不会重写 final不能修饰构造器 final和static搭配使用, 效率更高, 不会导致类加载. 包装类(integer, double, float, BOOlean都是final). String也是 抽象类 Java中的抽象类是一种特殊类型的类，它不能被实例化。抽象类通常用于定义一个通用的接口，该接口可以被其他类实现或继承。 父类方法不确定性： 例如定义一个动物类，动物类有吃的方法，但是方法中不知道这时动物吃什么． 这时可以将类作为抽象类 public abstract class Animal &#123; public abstract void makeSound(); // 抽象方法 public void move() &#123; // 具体方法 System.out.println(&quot;The animal moves.&quot;); &#125; &#125; 要使用抽象类，可以创建一个继承自抽象类的具体类，并实现所有的抽象方法。 public class Dog extends Animal &#123; @Override public void makeSound() &#123; // 实现抽象方法 System.out.println(&quot;The dog barks.&quot;); &#125; &#125; 细节 abstract只能修饰类和方法 一个类如果继承了抽象类, 则必须要将其实现, 除非他自己也是abstract 抽象方法不能使用private, final, static来修饰, 因为这些关键字和重写是冲突的 static不能和final一起出现, 因为static必须在调用时使用 抽象类实践, 模板设计模式 模板方法模式是一种行为型设计模式，它在一个方法中定义了一个算法的骨架，将某些步骤延迟到子类中实现。 这种模式使得子类在不改变算法结构的情况下，重新定义算法的某些特定步骤 父类定义骨架, 子类只需要关注自己需要重写的部分 在模板方法模式中，抽象类中定义了一个模板方法，该方法包含了算法的主要逻辑。模板方法内部可以调用其他已经定义好的方法（这些方法通常是抽象的，需要在子类中实现），也可以调用一些具体的方法（这些方法通常在抽象类中实现）。 子类继承抽象类并实现抽象方法，以提供模板方法所需的具体逻辑。通过这种方式，子类可以在不改变算法结构的情况下，对算法的某些特定步骤进行定制。 模板方法模式的优势在于，它使得算法的主体逻辑只存在于一个地方，即抽象类中。这有助于代码的复用和维护。同时，通过将算法的某些步骤延迟到子类中实现，可以方便地对算法进行扩展和定制。 模板方法模式的使用场景包括： 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 接口普通类: 只有具体实现 抽象类: 具体实现和规范(抽象方法) 接口: 只有规范 , 约束和实现分离 接口就是规范, 接口是一种引用类型，是一种特殊的抽象类。它定义了一组方法，但没有具体实现这些方法。接口可以被看作是类的模板，它定义了类应该具有的特性。 关键字 interface public interface Animal &#123; public void eat(); public void travel();&#125; 定义了一个名为MyInterface的接口，它包含了两个抽象方法和一个常量。实现这个接口的类必须提供method1()和method2()的具体实现。CONSTANT是一个常量，它的值不能被修改。 接口的实现类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 ...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...1 public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 细节 接口中所有方法都是public, 接口中抽象方法可以不用abstract修饰 抽象类实现接口, 可以不用实现接口的方法 一个类可以实现多个接口 public class AA implements BB, CC&#123;&#125; 接口中所有属性只能是final, 而且是public static final interface IB &#123;int n = 10&#125; //等价于public static final 接口中属性的访问形式: 接口名.属性名 接口不能继承其他类, 但是可以继承多个别的接口 interface A extends B, C &#123;&#125; 接口的修饰符只能是public和默认 接口和继承实现: 实现是对继承的补充 interface Fishable &#123;void swimming();&#125;interface Birdable &#123;void flying();&#125;class Monkey &#123;private String name;public Monkey(String name) &#123;this.name = name;&#125;public void climbing() &#123;System.out.println(name + &quot; 会爬树...&quot;);&#125;public String getName() &#123;return name;&#125;&#125;class LittleMonkey extends Monkey implements Fishable,Birdable &#123;public LittleMonkey(String name) &#123;super(name);&#125;@Overridepublic void swimming() &#123;System.out.println(getName() + &quot; 通过学习，可以像鱼儿一样游泳...&quot;);&#125;@Overridepublic void flying() &#123;System.out.println(getName() + &quot; 通过学习，可以像鸟儿一样飞翔...&quot;);&#125;&#125; 接口和继承解决的问题不同 继承的主要价值在于: 解决代的复用性和可维护性 接口的主要价值在于: 设计, 设计好各种规范(方法), 让其他类去实现这些方法. 接口比继承更加灵活 继承满足is - a的关系, 而接口满足like - a 的关系 接口多态两个类都实现了同一个方法, 创建对象时, 引用对象指向接口 interface IP &#123; &#125;calss Monster implements IP &#123;&#125;class Car implements IP &#123;&#125;//Monster和Car都实现了接口IPIP ip01 = new Monster();IP ip02 = new Car();//引用IP, 但运行时接口实现的实例 接口多态传递 interface IH &#123; void hi();&#125;interface IG extends IH&#123;&#125;class Teacher implements IG &#123; @override public void hi() &#123; &#125;&#125;public class interFace &#123; public static void main(String[] args) &#123; IG ig = new Teacher();//接口类型的变量可以指向实现了该接口类型的对象实例 //如果IH继承了IH接口,而Teacher实现了IG接口,实际上相当于Teacher类也实现了IH接口 IH ih = new Teacher(); &#125;&#125; 内部类 Java中的内部类是一种特殊的类，它被定义在另一个类的内部。根据其作用域的不同，可以分为四种类型的内部类： 静态内部类：使用static关键字定义的内部类，它与外部类实例无关，可以直接使用类名来访问。 成员内部类：作为外部类的一个成员变量，必须先创建外部类的对象才能创建内部类的对象。 局部内部类：在方法中定义的内部类，只能在定义它的方法中使用。 匿名内部类：没有名称的内部类，同时是一个对象, 通常用于实现某个接口或继承某个类，并且只使用一次。 从语法上来看, 既有定义类的特征, 也有创建对象 内部类的优势在于它可以方便地访问外部类的成员变量和方法，同时也可以避免一些因为封装而导致的代码复杂度增加的问题。此外，匿名内部类可以使代码更加简洁，避免了创建无名类的烦恼。 为了实现抽象类 public class OuterClass &#123; // 成员内部类 class InnerClass &#123; // 成员变量和方法 &#125; // 静态内部类 static class StaticInnerClass &#123; // 成员变量和方法 &#125; // 局部内部类 void someMethod() &#123; class LocalInnerClass &#123; // 成员变量和方法 &#125; &#125; // 匿名内部类 class outerClass &#123; object1 = new Type(parameterList) &#123; public void hi(int i) &#123; System.out.println(i); &#125; &#125;.hi(3);&#125; //创建了一个匿名类对象object1, 匿名类是表达式形式定义的, 所以结尾是`;`结束 //匿名类也是对象, 可以直接调用内部方法. //匿名内部类可以当参数传递 public static void main(String [] args) &#123; f1(new L() &#123; @Overide public void show() &#123; System.out.println(&quot;hahah&quot;); &#125; &#125; ); public static void f1(L l)&#123; l.show(); &#125; &#125; interface L &#123; void show(); &#125; 第十一章 枚举和注解枚举class Season &#123; private String name; private String desc;//描述&#125;//对于季节而言, 只有四个, 但是这样定义类可以创建很多个, 不能体现季节是固定的四个对象;//季节这样的类//1. 固定的值//2. 只读, 不需要修改 枚举是特殊的类, 一组常量的集合 枚举类型可以包含方法和属性，并且可以重写方法。 枚举类型是单例的，即每个枚举值在整个程序中只会出现一次。 自定义枚举 将构造器私有化, 防止被new 去掉set方法, 防止属性被修改 在Season内部直接创建固定的对象 加入final修饰 calss Season(String name, String desc) &#123; private String name; private String desc;//描述 public final static Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;); public final static Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;); public final static Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;); public final static Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;); private static Season(String name, String desc) &#123; this.name = name; this.desc = desc; &#125;&#125; 关键字enum 使用关键字 enum 替代 class SPRING(“春天”, “温暖”) 解读 常量名(实参列表) 如果有多个常量(对象)， 使用 ,号间隔即可 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面 如果我们使用的是无参构造器，创建常量对象，则可以省略 Season(String name, String desc) &#123;enum Season(String name, String desc) &#123;//枚举对象必须放在最前面 SPRING(&quot;春天&quot;, &quot;温暖&quot;), SPRING(&quot;春天&quot;, &quot;温暖&quot;), SPRING(&quot;春天&quot;, &quot;温暖&quot;); private String name; private String desc;//描述 private static Season(String name, String desc) &#123; this.name = name; this.desc = desc; &#125;&#125; 细节 当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个final类 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略 enum类方法 toString: Enum 类已经重写重写过了, 返回的是当前对象名, 子类可以重写该方法, 用于返回对象的属性信息 name:返回当前对象名(常量名) , 子类不可以重写 oridinal: 返回当前对象的位置号, 默认从0开始 values: 返回当前枚举类中所有的常量 valueOf: 将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！ )compareTo：比较两个枚举常量，比较的就是编号 调用: enum Week &#123; &#125;Week week[] = new Week.valus();// 将Week中的值给week[];//增强for循环, 将week中的值取出, 传给weeksfor(weeks:week) &#123; System.out.println(weeks);&#125; enum实现接口 使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。 枚举类和普通类一样，可以实现接口，如下形式。 enum 类名 implements 接口 1，接口 2 {接口实现} 注解 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置 Annotation介绍使用 Annotation 时要在其前面增加 @ 符号, 并把该Annotation 当成一个修饰符使用。 用于修饰它支持的程序元 素 三个基本的 Annotation: @Override 限定某个方法，是重写父类方法, 该注解只能用于方法 @Override表示指定重写父类的方法(从编译层面验证), 如果父类没有fly方法, 则会报错 如果不写, 父类依然有public void fly() {}, 依然构成重写 只能修饰方法 Target是修饰注解的注解, 称为元注解 @Deprecated用于表示某个程序元素(类, 方法等)已过时 可以修饰方法, 类, 字段, 包, 参数等等 做新旧版本的兼容和过度 @SuppressWarnings:抑制编译器警告 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息 在@SuppressWarnings( {“XXXX”} )中，可以写入你希望抑制(不显示)警告信息 关于 SuppressWarnings 作用范围是和你放置的位置相关, 比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main , 通常我们可以放置具体的语句, 方法, 类 需求文档-&gt;理解-&gt;代码 第十二章 异常(Exception) Java中的异常机制是一种处理程序中的错误或异常情况的方式。当程序中出现异常时，Java运行时系统会抛出一个异常对象，程序会停止正常的执行流程，转向处理异常的代码。 异常是指中断程序正常执行的一个不确定的事件。当异常发生时，程序的正常执行流程就会被打断。一般情况下，程序都会有很多条语句，如果没有异常处理机制，前面的语句一旦出现了异常，后面的语句就没办法继续执行了。” “有了异常处理机制后，程序在发生异常的时候就不会中断，我们可以对异常进行捕获，然后改变程序执行的流程。” “除此之外，异常处理机制可以保证我们向用户提供友好的提示信息，而不是程序原生的异常信息——用户根本理解不了。” 异常体系 Java中的异常可以分为两类： 编译型异常（Checked Exceptions) 这类异常在编译时被检查，必须在方法或构造函数上使用throws关键字进行声明。检查型异常通常表示程序可以预料到的情况，例如文件找不到、网络连接失败等。 运行时异常（Unchecked Exceptions）。 这类异常是运行时异常，不需要在方法或构造函数上使用throws关键字进行声明。非检查型异常通常表示程序无法预料到的情况，例如除以零、数组越界等逻辑错误, 是程序员应该避免的。 错误 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的 常见异常常见的运行时异常包括 NullPointerException 空指针异常 ArithmeticException 数学运算异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ClassCastException 类型转换异常 NumberFormatException 数字格式不正确异常[] 常见的编译异常 SQLException&#x2F;&#x2F;操作数据库时,查询表可能发生异常 IOException&#x2F;&#x2F;操作文件时,发生的异常 FileNotFoundException&#x2F;&#x2F;当操作一个不存在的文件时,发生异常 ClassNotFoundException&#x2F;&#x2F;加载类,而该类不存在时,异常 EOFException&#x2F;&#x2F;操作文件,到文件末尾,发生异常 IllegalArguementException&#x2F;&#x2F;参数异常 处理异常的方式捕获异常（Catch)程序员在代码中捕获发生的异常, 自行处理 捕获异常：在方法或构造函数中，可以使用try-catch语句来捕获并处理异常。当try块中的代码发生异常时，程序会跳转到对应的catch块中执行处理逻辑。 int a = 1;int b = 0;try &#123;// try监控异常 System.out.println(a/b);&#125; catch (ArithmeticExection e) &#123; //cactch捕获异常, 内部参数为捕获的异常类型 System.out.println(&quot;出现异常&quot;);&#125; finally &#123; //处理异常 System.out.println(&quot;finally&quot;);&#125;//多重捕获块//异常类型从小到大try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; 数组空指针异常(NullPointer), return ++i&#x2F;&#x2F; 3, 先执行final ,i&#x3D;4, 在return i&#x3D;3; 抛出异常（Throws）。将发生的异常抛出, 交给调用者(方法)来处理, 最顶级的处理者是JVM 抛出异常：当方法或构造函数无法处理异常时，可以使用throw语句抛出异常。这个异常对象会被传递给调用者，直到找到能够处理该异常的catch块或者被最终抛出到应用程序的顶层。 Java中的异常处理机制可以帮助程序员更好地控制程序的执行流程，避免程序出现意外终止或无法控制的行为。通过合理地使用异常处理，可以提高程序的健壮性和可靠性。 public void f() throws Exception &#123;// Exception统称 //1. 这里的异常是编译异常 //2. 使用throws, 让f方法的调用者(方法)处理异常 //3. throws后面的异常类型可以是方法中产生的异常类型, 也可以是他的父类 //4. throws关键字后面也可以是异常列表, 即可以抛出多个异常 FileInputStream fis = new FileInputStream(&quot;d://aa.txt&quot;);&#125; 细节 子类重写父类的方法时, 对抛出异常的规定: 子类所抛出的异常要和父类一致, 或者为父类抛出异常类型的子类型 在throws过程中, 如果有try - catch处理, 就停止throws 自定义异常 当程序中出现了某些“错误”, 但该错误信息并没有在Throw able子类中描述处理, 这个时侯后可以自己设计异常类, 用于描述错误信息 步骤 定义类: 自定义异常类名,继承Exception或RuntimeException 如果继承Exception, 属于编译异常, Runtime属于运行异常 //自定义的一个异常class AgeException extends RuntimeException &#123;\tpublic AgeException (String message) &#123; super(message); &#125; &#125;public static void main(String args) &#123; int age = 138; if (!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123; throw new AgeException (&quot;年龄异常&quot;); &#125; //不符合取反就进入异常处理, 符合就退出 &#125; throw和throws区别 执行showExce时, 抛出异常, 不再执行接下来的语句, 到catch输出B, 再到final. 有final一定会执行, 但只有catch没有return则按顺序执行 十三章 常用类包装类(Wrapper) 针对八种基本数据类型相应的引用类型—包装类 有了类的特点，就可以调用类中的方法 包装类和基本数据类型的转换 手动装箱 int n1 = 100; Integer integer = new Integer(n1); Integer integer = Integer.valueOf(n1); 两种方式 手动拆箱 int i &#x3D; integer.intValue(); 自动装箱 Integer integer2 = n2; 自动拆箱 int n3 = integer3; 包装类和String类转换 包装类转String Integer i = 100; String str1 = i + “ ”;&#x2F;&#x2F;将Integer 100 转为String String str1 = i.toString() String转包装类 String str4 = “12345”; Integer i = Integer.parseInt(str4); String类 String对象用于保存字符串 字符串常量对象使用双引号 字符串的字符使用Unicode, 一个字符(汉英)占两个字节 String类有很多构造器, 构造器的重载 String类实现了接口Serializable(String可以串行化: 可以再网络传输), 接口Comparable(比较大小) String是final类, 不能继承 String有属性private, final, char, value[]; 用于存放字符串内容 value[]是一个final类型, 即不可以指向新的地址, 但是里面的字符是可以变化的. 本身的值和地址不在一个地方 创建String对象的两种方式 直接赋值 String S &#x3D; xxx 调用构造器 String S2 &#x3D; new String(“ ”); String 方法 StringBuffer类 可变的字符序列, 可以对字符内容进行增删 StringBuffer是一个容器 很多方法与String相同, 但StringBuffer是可变长度的 对比String String保存的是字符串常量, 不能更改, 每次的更新是更改地址, 效率低 Buffer保存变量, 不用更新地址, char[] value放在堆中 构造器和转换 StringBuffer stringBuffer = new StringBuffer();String str = &quot;hello&quot;;StringBuffer stringBuffer = new StringBuffer(str);//返回了str值给stringBufeerStringBuffer stringBuffer = new StringBuffer(100);StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;); 两者中间转化 //StringBuffer -&gt; String //String str = &quot;hello tom&quot;;//方式 1 使用构造器//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响StringBuffer stringBuffer = new StringBuffer(str);//方式 2 使用的是 append 方法StringBuffer stringBuffer1 = new StringBuffer();stringBuffer1 = stringBuffer1.append(str);//StringBuffer -&gt;String//StringBuffer stringBuffer3 = new StringBuffer(&quot;韩顺平教育&quot;);//方式 1 使用 StringBuffer 提供的 toString 方法String s = stringBuffer3.toString();//方式 2: 使用构造器来搞定String s1 = new String(stringBuffer3); 常见方法StringBuffer s = new StringBuffer(&quot;hello&quot;);//增s.append(&#x27;,&#x27;);// &quot;hello,&quot;s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot; System.out.println(s);//&quot;hello,张三丰赵敏100true10.5&quot;//删/** 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符* 解读: 删除 11~14 的字符 [11, 14) * 从零开始, 包含11不包含14*/s.delete(11, 14);System.out.println(s);//&quot;hello,张三丰赵敏true10.5//改//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)s.replace(9, 11, &quot;周芷若&quot;);System.out.println(s);//&quot;hello,张三丰周芷若 true10.5&quot;//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1int indexOf = s.indexOf(&quot;张三丰&quot;);System.out.println(indexOf);//6//插入//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移s.insert(9, &quot;赵敏&quot;);System.out.println(s);//&quot;hello,张三丰赵敏周芷若 true10.5&quot;//长度System.out.println(s.length());//22System.out.println(s) StringBuilder类 StringBuilder 继承 AbstractStringBuilder 类 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件) StringBuilder 是 final 类, 不能被继承 StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value; &#x2F;&#x2F; 因此，字符序列是堆中 StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用 比较和选择 三个的比较 选择 Date类第一代日期类 Date: 精确到毫秒, 代表特定的时间 SimpleDateFomat: 格式和解析日期的类 格式: 日期 &#x3D;&gt; 文本 解析: 文本 &#x3D;&gt; 规范化 //1. 获取当前系统时间//2. 这里的 Date 类是在 java.util 包//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换Date d1 = new Date(); //获取当前系统时间System.out.println(&quot;当前日期=&quot; + d1);Date d2 = new Date(9234567); //通过指定毫秒数得到时间System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒//1. 创建 SimpleDateFormat 对象，可以指定相应的格式//2. 这里的格式使用的字母是规定好，不能乱写SimpleDateFormat sDF = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;);String format = sDF.format(d1); // format:将日期转换成指定格式的字符串System.out.println(&quot;当前日期=&quot; + format);//1. 可以把一个格式化的 String 转成对应的 Date//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常String s = &quot;1996 年 01 月 01 日 10:20:30 星期一&quot;;Date parse = sDF.parse(s);System.out.println(&quot;parse=&quot; + sDF.format(parse)); 第二代日期类Calendar Calendar 是一个抽象类， 并且构造器是 private 可以通过 getInstance() 来获取实例 Calendar c = Calendar.getInstance(); System.out.println(&quot;C&quot; + c); 提供大量的方法和字段提供给程序员 Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活) 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR &#x3D;&#x3D;改成&#x3D;&gt; Calendar.HOUR_OF_DAY Calendar c &#x3D; Calendar.getInstance(); &#x2F;&#x2F;创建日历类对象&#x2F;&#x2F;比较简单，自由 //2.获取日历对象的某个日历字段System.out.println(&quot;年：&quot; + c.get(Calendar.YEAR));// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号System.out.println(&quot;月：&quot; + (c.get(Calendar.MONTH) + 1));System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));System.out.println(&quot;分钟：&quot; + c.get(Calendar.MINUTE));System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND)); //Calender 没有专门的格式化方法，所以需要程序员自己来组合显示System.out.println(c.get(Calendar.YEAR) + &quot;-&quot; + (c.get(Calendar.MONTH) + 1) + &quot;-&quot; +c.get(Calendar.DAY_OF_MONTH) + &quot; &quot; + c.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; + c.get(Calendar.MINUTE) + &quot;:&quot; + c.get(Calendar.SECOND)); 第三代日期类 LocalDate(年月日) LocalTime(时分秒) LocalDateTime(日期 + 时间) LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()System.out.println(ldt);//2. 使用 DateTimeFormatter 对象来进行格式化// 创建 DateTimeFormatter 对象DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);String format = dateTimeFormatter.format(ldt);System.out.println(&quot;格式化的日期=&quot; + format);System.out.println(&quot;年=&quot; + ldt.getYear());System.out.println(&quot;月=&quot; + ldt.getMonth());System.out.println(&quot;月=&quot; + ldt.getMonthValue());System.out.println(&quot;日=&quot; + ldt.getDayOfMonth());System.out.println(&quot;时=&quot; + ldt.getHour());System.out.println(&quot;分=&quot; + ldt.getMinute());System.out.println(&quot;秒=&quot; + ldt.getSecond());LocalDate now = LocalDate.now(); //可以获取年月日LocalTime now2 = LocalTime.now();//获取到时分秒//提供 plus 和 minus 方法可以对当前时间进行加或者减//看看 890 天后，是什么时候 把 年月日-时分秒LocalDateTime localDateTime = ldt.plusDays(890);System.out.println(&quot;890 天后=&quot; + dateTimeFormatter.format(localDateTime));//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出LocalDateTime localDateTime2 = ldt.minusMinutes(3456);System.out.println(&quot;3456 分钟前 日期=&quot; + dateTimeFormatter.format(localDateTime2)) Instant时间戳类似Date提供了一系列和Date类转换的方法 Instant -&gt; Date Date date = Date.from(instant); Date -&gt; Instant Instant instant = date.toInstant(); 更多方法 集合Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。 很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。 可以动态保存任意多个对象 提供了一系列方便的操作对象 使用集合添加, 删除新元素的示意代码 集合体系早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。 集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合 集合类分为两大类: 集合主要是两组(单列集合 , 双列集合) Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合 Map 接口的实现子类 是双列集合，存放的 Key-Value对(K-V) 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序，这些算法实现了多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。 List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 总结Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 Collection接口和常用方法 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表 Collection 方法 Collection接口常用方法用实现子类ArrayList来演示 List list = new Arraylist();//addlist.add(&quot;jack&quot;);list.add(10);//相当于list.add(new Integer(10));list.add(true);//remove//list.remove(0);//删除第一个元素list.remove(true);//指定删除某个元素//contains: 查找元素System.out.println(list.contains(&quot;jack&quot;));//T//size:获取元素个数System.out.println(list.size());// isEmpty:判断是否为空System.out.println(list.isEmpty());//F// clear:清空list.clear();System.out.println(&quot;list=&quot; + list);// addAll:添加多个元素ArrayList list2 = new ArrayList();list2.add(&quot;红楼梦&quot;);list2.add(&quot;三国演义&quot;);list.addAll(list2);System.out.println(&quot;list=&quot; + list);// containsAll:查找多个元素是否都存在System.out.println(list.containsAll(list2));//T// removeAll：删除多个元素list.add(&quot;聊斋&quot;);list.removeAll(list2);System.out.println(&quot;list=&quot; + list);//[聊斋] 遍历 Iterator对象称为迭代器, 主要用于遍历Collection集合中的元素 所有实现了Collection接口的集合类都有一个iterator()方法, 用于返回一个实现了Iterator接口的对象, 即可以返回一个迭代器 Iterator结构 Iterator仅用于遍历集合, 不存放对象, 将得到的返回 public static void main(String[] args) &#123;Collection col = new ArrayList();col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));//System.out.println(&quot;col=&quot; + col); //现在希望能够遍历 col 集合//1. 先得到 col 对应的 迭代器Iterator iterator = col.iterator(); //2. 使用 while 循环遍历//ctrl + j, 快速生成 while =&gt; ititwhile (iterator.hasNext()) &#123;//判断是否还有数据Object obj = iterator.next();System.out.println(&quot;obj=&quot; + obj);&#125; //3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素// iterator.next();//NoSuchElementException //4. 如果希望再次遍历，需要重置我们的迭代器iterator = col.iterator();System.out.println(&quot;===第二次遍历===&quot;);while (iterator.hasNext()) &#123;Object obj = iterator.next();System.out.println(&quot;obj=&quot; + obj);&#125;&#125;&#125; class Book &#123;private String name;private String author;private double price;&#125; 增强for增强for就是简化版的iterator, 只能用于遍历集合或数组 基本语法 for (元素类型 元素名: 集合名或数组名) &#123; 访问元素&#125;List list = new ArrayList();list.add(new Dog(&quot;小黑&quot;, 3));list.add(new Dog(&quot;大黄&quot;, 100));list.add(new Dog(&quot;大壮&quot;, 8));//先使用 for 增强for (Object dog : list) &#123;System.out.println(&quot;dog=&quot; + dog);&#125;//使用迭代器System.out.println(&quot;===使用迭代器来遍历===&quot;);Iterator iterator = list.iterator();while (iterator.hasNext()) &#123;Object dog = iterator.next();System.out.println(&quot;dog=&quot; + dog)&#125; 1. List List接口时Collection的子接口 List集合类中元素类有序(即添加顺序和取出顺序一致), 且可以重复 List集合中的每个元素都有对应的顺序索引, 即支持索引 list.get(2) 取出第二个元素 List容器中的元素都对应一个整数型的序号记载其在容器中的位置, 可以根据序号取出元素 // int indexOf(Object obj):返回 obj 在集合中首次出现的位置System.out.println(list.indexOf(&quot;tom&quot;));//2// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置list.add(&quot;tom&quot;);System.out.println(list.lastIndexOf(&quot;tom&quot;));// Object remove(int index):移除指定 index 位置的元素，并返回此元素list.remove(0);System.out.println(&quot;list=&quot; + list);// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换.list.set(1, &quot;marri&quot;);// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合// 注意返回的子集合 fromIndex &lt;=subList &lt; toIndexList returnlist = list.subList(0, 2); 对list排序 //冒泡排序public static void sort(List list) &#123; int size = list.size(); for (int i = 0; i &lt; size - 1; i++) for(int j = 0; j &lt; size - 1 - i; j++) &#123; //先将list中对象取出 Book book1 = (Book)list.get(j); //list中存的都是Object, 先转为Book Book book2 = (Book)list.get(j + 1); if (boo1.getPrice() &gt; book2.getPrice()) &#123; list.set(j, book2); list.set(j + 1, book1); &#125; &#125;&#125; ArrayList细节 ArrayList 是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素； ArrayList可以加入null ArrayList是由数组实现数据存储的 ArrayList基本等于Vector, 除了ArrayList线程不安全 源码分析结论: ArrayList中维护了一个Object类型的数组elementData.[debug看源码]transient Object[] elementData; &#x2F;&#x2F;transient 表示瞬间,短暂的,表示该属性不会被序列 当创建ArrayList对象时, 如果使用的是无参构造器, 则初始elementData容量为0, 第1次添加元素, 则扩容elementData为10, 如需要再次扩容,则扩容elementData为1.5倍.(JDK1.8) 如果使用的是指定大小的构造器, 则初始elementData容量为指定大小, 超过指定大小时, 如果需要扩容, 则直接扩容elementData为1.5倍。 自己Debug 每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。 数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。 数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。 vector底层结构和源码剖析 List的实现类还有一个 Vector，是一个元老级的类，比 ArrayList 出现得更早。ArrayList 和 Vector 非常相似，只不过 Vector 是线程安全的，像 get、set、add 这些方法都加了 synchronized 关键字，就导致执行效率会比较低，所以现在已经很少用了。 加了同步方法的类，注定会被淘汰掉，就像StringBuilder取代StringBufferopen in new window那样。JDK 源码也说了： 如果不需要线程安全，建议使用ArrayList代替Vector。 与ArrayList对比 LinkedList 底层剖析操作机制 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。 链表可分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。 与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。 操作使用以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 LinkedList 继承了 AbstractSequentialList 类。 LinkedList 实现了 Queue 接口，可作为队列使用。 LinkedList 实现了 List 接口，可进行列表的相关操作。 LinkedList 实现了 Deque 接口，可作为队列使用。 LinkedList 实现了 Cloneable 接口，可实现克隆。 LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。 LinkedList 类位于 java.util 包中，使用前需要引入它，语法格式如下： // 引入 LinkedList 类import java.util.LinkedList; LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); // 普通创建方法或者LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表 ** // 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites); &#125;&#125; 在访问结尾元素, 或者增删首位元素时, 链表效率更高 迭代元素使用for循环 // 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int size = sites.size(), i = 0; i &lt; size; i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125; 增强for // 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; 2. Set 无序, 添加和取出顺序不一致, 没有索引 不允许重复元素, 虽多包含一个null JDK API中Set接口实现类有: 常用方法和Collection一样 Set接口实现类: HashSet HashSet实现了Set接口 HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。 public HashSet() &#123; map = new HashMap&lt;&gt; () &#125; Hash Map底层是(数组 + 链表 + 红黑树) 实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么ArrayList和LinkedList可能更适合；如果我们需要存储键值对并根据键进行查找，那么HashMap可能更适合。 // 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 System.out.println(sites); &#125;&#125; 迭代// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; 也可以用迭代器 LinkedHashSet LinkedHashSet是HashSet的子类 底层是LindedHashMap, 底层维护了一个数组 + 双向链表 LindedHashSet根据元素的hashCode值来决定元素的存储位置, 同时使用链表维护元素的次序, 这使得元素看起来是以插入顺序保存的 TreeSet TreeSet 是 Java 集合框架的一部分，它是一个基于树结构的实现，用于存储唯一元素。由于其内部实现，TreeSet 提供了对元素的自然排序（基于元素的 Comparable 接口）或根据提供的 Comparator 进行排序。 基本信息 唯一性：TreeSet 只允许存储唯一的元素。如果你尝试添加一个已经存在的元素，那么该操作不会有任何效果，即该元素不会被添加到集合中。 排序：TreeSet 默认按照元素的自然顺序进行排序。如果你想按照自定义的顺序进行排序，可以提供一个 Comparator 对象。 查询操作：由于 TreeSet 是基于树结构的，所以在对集合进行查询时（例如，查找元素是否存在或获取元素的大小），这些操作通常比在 ArrayList 或 LinkedList 等基于数组的数据结构上执行得更快。 不允许 null 值：与 HashSet 不同，TreeSet 不允许存储 null 值。 试分析HashSet和TreeSet分别如何实现去重的 HashSet的去重机制: hashCode()+equals(), 底层先通过存入对象,进行运算得到一个hash值, 通过hash值得到对应的索引, 如果发现table索引所在的位置,没有数据, 就直接存放,如果有数据, 就进行equals比较[遍历比较], 如果比较后, 不相同加入, 否则就不加入. TreeSet的去重机制: 如果你传入了一个Comparator匿名对象, 就使用实现的compare去重, 如果方法返回0, 就认为是相同的元素&#x2F;数据, 就不添加 如果你没有传入一个Comparator匿名对象,则以你添加的对象实现的Compareable接口的compareTo去重. 常用方法： add(E e): 添加元素到集合中。 remove(Object o): 从集合中移除指定的元素（如果存在）。 contains(Ob ject o): 检查集合是否包含指定的元素。 size(): 返回集合中的元素数量。 first(), last(): 返回集合中的最小和最大元素（如果存在）。 3. Map Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value Key是输入的具体对象, Value也是输入, Set中是常量 Map 中的key 和 value可以是任何引用类型的数据,会封装到HashMap$Node对象中 Map中的key 不允许重复, Map 中的value 可以重复 Map的key 可以为null, 但只能有一个, value可以为null, 可以多个. 常用String类作为Map的key key 和value之间存在单向一对一关系,即通过指定的key总能找到对应的value HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 HashMap HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。 可以使用迭代器或者 for-Each 方法遍历 HashMap 中的键值对。 HashMap 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的 (键值对数量 &#x2F; 哈希表大小) 的比率。默认的初始容量是 16，负载因子是 0.75。 添加// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites); &#125;&#125; 访问// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites.get(3)); &#125;&#125; 删除 remove(key); 删除所有用clear(); 迭代可以使用 for-each 来迭代 HashMap 中的元素。 如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。 // 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); // 输出 key 和 value for (Integer i : Sites.keySet()) &#123; System.out.println(&quot;key: &quot; + i + &quot; value: &quot; + Sites.get(i)); &#125; // 返回所有 value 值 for(String value: Sites.values()) &#123; // 输出每一个value System.out.print(value + &quot;, &quot;); &#125; //(2) 迭代器 Iterator iterator = Sites.keyset.iterator(); while (iterator.hasNext()) &#123; Object key = iterator.next(); System.out.println(key + &quot;-&quot; + map.get(key)); &#125; System.out.println(&quot;---取出所有的 value 迭代器----&quot;); Iterator iterator2 = Sites.values.iterator(); while (iterator2.hasNext()) &#123; Object value = iterator2.next(); System.out.println(&quot;value&quot; + value); &#125; &#125;&#125; Hash Map小结 Map接口的常用实现类: Hash Map, Hashtable和Properties HashMap是Map接口使用频率最高的实现类 key不能重复, value可以. 允许使用null键和值 与HashSet一样, 不保证映射顺序 HashMap没有实现同步, 线程不安全 一个table数组, 每个数组元素是一个链表, 链表存储键值对 扩容机制 扩容机制[和HashSet相同] HashMap底层维护了Node类型的数组table,默认为null 当创建对象时,将加载因子(loadfactor)初始化为0.75. 当添加key-val时, 通过key的哈希值得到在table的索引。然后判断该索引处是否有元素.如果没有元素直接添加。如果该索引处有元素, 继续判断该元素的key是否和准备加入的key相等, 如果相等, 则直接替换val; 如果不相等需要判断是树结构还是链表结构, 做出相应处理。 如果添加时发现容量不够,则需要扩容。 第1次添加, 则需要扩容table容量为16, 临界值(threshold)为12 以后再扩容, 则需要扩容table容量为原来的2倍(16*2), 临界值为原来的2倍, 即24(12*2), 依次类推. 在Java8中, 如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8), 并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64), 就会进行树化(红黑树) LinkedHashMapLinkedHashMap 是 HashMap 的子类，它使用链表来记录插入&#x2F;访问元素的顺序。 LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。 // 创建一个 LinkedHashMap，插入的键值对为 沉默 王二 陈清扬LinkedHashMap&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();linkedHashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);linkedHashMap.put(&quot;王二&quot;, &quot;wanger&quot;);linkedHashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);// 遍历 LinkedHashMapfor (String key : linkedHashMap.keySet()) &#123; String value = linkedHashMap.get(key); System.out.println(key + &quot; 对应的值为：&quot; + value);&#125;/*沉默 对应的值为：cenzhong王二 对应的值为：wanger陈清扬 对应的值为：chenqingyang*/ TreeMapTreeMap实现了 SortedMap 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。 // 创建一个 TreeMap 对象Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();// 向 TreeMap 中添加键值对treeMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);treeMap.put(&quot;王二&quot;, &quot;wanger&quot;);treeMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);// 查找键值对String name = &quot;沉默&quot;;if (treeMap.containsKey(name)) &#123; System.out.println(&quot;找到了 &quot; + name + &quot;: &quot; + treeMap.get(name));&#125; else &#123; System.out.println(&quot;没有找到 &quot; + name);&#125;// 修改键值对name = &quot;王二&quot;;if (treeMap.containsKey(name)) &#123; System.out.println(&quot;修改前的 &quot; + name + &quot;: &quot; + treeMap.get(name)); treeMap.put(name, &quot;newWanger&quot;); System.out.println(&quot;修改后的 &quot; + name + &quot;: &quot; + treeMap.get(name));&#125; else &#123; System.out.println(&quot;没有找到 &quot; + name);&#125;// 删除键值对name = &quot;陈清扬&quot;;if (treeMap.containsKey(name)) &#123; System.out.println(&quot;删除前的 &quot; + name + &quot;: &quot; + treeMap.get(name)); treeMap.remove(name); System.out.println(&quot;删除后的 &quot; + name + &quot;: &quot; + treeMap.get(name));&#125; else &#123; System.out.println(&quot;没有找到 &quot; + name);&#125;// 遍历 TreeMapfor (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());&#125;//与HashMap 不同的是，TreeMap 会按照键的顺序来进行排序。// 创建一个 TreeMap 对象Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();// 向 TreeMap 中添加键值对treeMap.put(&quot;c&quot;, &quot;cat&quot;);treeMap.put(&quot;a&quot;, &quot;apple&quot;);treeMap.put(&quot;b&quot;, &quot;banana&quot;);// 遍历 TreeMapfor (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());&#125;/*a: appleb: bananac: cat*/ HashTable 存放的元素是键值对:即K-V hashtable的键和值都不能为null hashTable 使用方法基本上和HashMap一样 hashTable 是线程安全的,hashMap是线程不安全的 Properties Properties类继承自Hashtable类并且实现了Map接口, 也是使用一种键值对的形式来保存数据。 他的使用特点和Hashtable类似 Properties 还可以用于 从 xxx.properties 文件中, 加载数据到Properties类对象, 并进行读取 和修改 开发中选择集合实现类 先判断存储的类型(一组对象或一组键值对) 一组对象:Collection接口 允许重复:List增删多: LinkedList[底层维护了一个双向链表]改查多: ArrayList[底层维护Object类型的可变数组] 不允许重复:Set无序: HashSet [底层是HashMap,维护了一个哈希表 即(数组+链表+红黑树)]排序: TreeSet插入和取出顺序一致: LinkedHashSet,维护数组+双向链表 一组键值对:Map 键无序: HashMap[底层是:哈希表 jdk7:数组+链表,jdk8:数组+链表+红黑树] 键排序: TreeMap 键插入和取出顺序一致: LinkedHashMap 读取文件 Properties Collections工具类 Java中的java.util.Collections类是一个工具类，提供了用于操作集合（如List、Set等）的各种静态方法。这些方法允许执行各种操作，例如排序、替换元素、检查是否包含某个元素等 常用工具类方法排序操作 reverse(List list)：反转顺序 shuffle(List list)：洗牌，将顺序打乱 sort(List list)：自然升序 sort(List list, Comparator c)：按照自定义的比较器排序 swap(List list, int i, int j)：将 i 和 j 位置的元素交换位置 List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;沉默王四&quot;);list.add(&quot;沉默王五&quot;);list.add(&quot;沉默王六&quot;);System.out.println(&quot;原始顺序：&quot; + list);// 反转Collections.reverse(list);System.out.println(&quot;反转后：&quot; + list);// 洗牌Collections.shuffle(list);System.out.println(&quot;洗牌后：&quot; + list);// 自然升序Collections.sort(list);System.out.println(&quot;自然升序后：&quot; + list);// 交换Collections.swap(list, 2,4);System.out.println(&quot;交换后：&quot; + list); 查找操作 binarySearch(List list, Object key)：二分查找法，前提是 List 已经排序过了 max(Collection coll)：返回最大元素 max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素 min(Collection coll)：返回最小元素 min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素 fill(List list, Object obj)：使用指定对象填充 frequency(Collection c, Object o)：返回指定对象出现的次数 System.out.println(&quot;最大元素：&quot; + Collections.max(list));System.out.println(&quot;最小元素：&quot; + Collections.min(list));System.out.println(&quot;出现的次数：&quot; + Collections.frequency(list, &quot;沉默王二&quot;));// 没有排序直接调用二分查找，结果是不确定的System.out.println(&quot;排序前的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王二&quot;));Collections.sort(list);// 排序后，查找结果和预期一致System.out.println(&quot;排序后的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王二&quot;));Collections.fill(list, &quot;沉默王八&quot;);System.out.println(&quot;填充后的结果：&quot; + list); 恐怕 JDK 的设计者是这个世界上最好的老师了，文档写得不能再详细了，代码写得不能再优雅了，基本上都达到了性能上的极致。 第十五章 泛型一段引入 //有泛型ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;沉默王二&quot;);String str = list.get(0);//如果没有泛型, 用Object数组设计Arraylist类class Arraylist &#123; private Object[] objs; private int i = 0; public void add(Object obj) &#123; objs[i++] = obj; &#125; public Object get(int i) &#123; return objs[i]; &#125;&#125;//在Arraylist中存放数据Arraylist list = new Arraylist();list.add(&quot;沉默王二&quot;);list.add(new Date());String str = (String)list.get(0);// 原来返回的是Object, 取出时必须转型 使用类型参数解决了元素的不确定性——参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换了。 使用形式: List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); 手动设计一个泛型class Arraylist&lt;E&gt; &#123; private Object[] elementData; private int size = 0; public Arraylist(int initialCapacity) &#123; this.elementData = new Object[initialCapacity]; &#125; public boolean add(E e) &#123; // 使用了泛型 elementData[size++] = e; return true; &#125; public E elementData(int index) &#123; //定义了泛型, 为泛型方法 return (E) elementData[index]; &#125;&#125; 个泛型类就是具有一个或多个类型变量的类。 Arraylist 类引入的类型变量为 E（Element，元素的首字母），使用尖括号 &lt;&gt; 括起来，放在类名的后面。代表我们可以用具体的类型(比如字符串)替换类型变量E来实例化泛型类 Arraylist&lt;String&gt; list = new Arraylist&lt;String&gt;();list.add(&quot;沉默王三&quot;);String str = list.get(0); 在一个非泛型的类（或者泛型类）中定义泛型方法。 class Arraylist&lt;E&gt; &#123; public &lt;T&gt; T[] toArray(T[] a) &#123; return (T[]) Arrays.copyOf(elementData, size, a.getClass()); &#125;&#125; Arraylist&lt;String&gt; list = new Arraylist&lt;&gt;(4);list.add(&quot;沉&quot;);list.add(&quot;默&quot;);list.add(&quot;王&quot;);list.add(&quot;二&quot;);String [] strs = new String [4]; strs = list.toArray(strs);// 可以直接接收了for (String str : strs) &#123; //遍历时可以直接用String System.out.println(str);&#125; 泛型限定符一个例子, //定义三个类, 之间继承class Wanglaoer &#123; public String toString() &#123; return &quot;王老二&quot;; &#125;&#125;class Wanger extends Wanglaoer&#123; public String toString() &#123; return &quot;王二&quot;; &#125;&#125;class Wangxiaoer extends Wanger&#123; public String toString() &#123; return &quot;王小二&quot;; &#125;&#125; 使用extends重新设计下Arraylist class Arraylist&lt;E extends Wanger&gt; &#123;&#125; 向 Arraylist 中添加 Wanglaoer 元素的时候，编译器会提示错误：Arraylist 只允许添加 Wanger 及其子类 Wangxiaoer 对象，不允许添加其父类 Wanglaoer。 也就是限定符 extends 可以缩小泛型的类型范围。 类型擦除//继承了wanger这个类, 即限定类class Arraylist2&lt;E extends Wanger&gt; &#123; private Object[] elementData; private int size = 0; public Arraylist2(int initialCapacity) &#123; this.elementData = new Object[initialCapacity]; &#125; public boolean add(E e) &#123; elementData[size++] = e; return true; &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125;&#125; 反编译后: (将Java字节码（.class文件）转换回其原始的Java源代码的过程。) // Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.kpdus.com/jad.html// Decompiler options: packimports(3) // Source File Name: Arraylist2.javapackage com.cmower.java_demo.fanxing;// Referenced classes of package com.cmower.java_demo.fanxing:// Wangerclass Arraylist2&#123; public Arraylist2(int initialCapacity) &#123; size = 0; elementData = new Object[initialCapacity]; &#125; public boolean add(Wanger e) // E变成wanger &#123; elementData[size++] = e; return true; &#125; Wanger elementData(int index) &#123; return (Wanger)elementData[index]; &#125; private Object elementData[]; private int size;&#125; 类型变量 &lt;E extends Wanger&gt; 不见了，E 被替换成了 Wanger Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 Object） 类型擦除的问题//方法重载public class Cmower &#123; public static void method(Arraylist&lt;String&gt; list) &#123; System.out.println(&quot;Arraylist&lt;String&gt; list&quot;); &#125; public static void method(Arraylist&lt;Date&gt; list) &#123; System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;); &#125;&#125; 但由于擦除后都是Arraylist, 编译器会报错 泛型通配符使用英文的问号（?）来表示。 在我们创建一个泛型对象时，可以使用关键字 extends 限定子类，也可以使用关键字 super 限定父类。 // 定义一个泛型类 Arraylist&lt;E&gt;，E 表示元素类型class Arraylist&lt;E&gt; &#123; // 私有成员变量，存储元素数组和元素数量 private Object[] elementData; private int size = 0; // 构造函数，传入初始容量 initialCapacity，创建一个指定容量的 Object 数组 public Arraylist(int initialCapacity) &#123; this.elementData = new Object[initialCapacity]; &#125; // 添加元素到数组末尾，返回添加成功与否 public boolean add(E e) &#123; elementData[size++] = e; return true; &#125; // 获取指定下标的元素 public E get(int index) &#123; return (E) elementData[index]; &#125; // 查找指定元素第一次出现的下标，如果找不到则返回 -1 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 判断指定元素是否在数组中出现 public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; // 将数组中的元素转化成字符串输出 public String toString() &#123; StringBuilder sb = new StringBuilder(); for (Object o : elementData) &#123; if (o != null) &#123; E e = (E)o; sb.append(e.toString()); sb.append(&#x27;,&#x27;).append(&#x27; &#x27;); &#125; &#125; return sb.toString(); &#125; // 返回数组中元素的数量 public int size() &#123; return size; &#125; // 修改指定下标的元素，返回修改前的元素 public E set(int index, E element) &#123; E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125;&#125; 泛型擦除的原因，Arraylist&lt;Wanger&gt; list = new Arraylist&lt;Wangxiaoer&gt;(); 这样的语句是无法通过编译的，尽管 Wangxiaoer 是 Wanger 的子类。 但如果我们确实需要这种 “向上转型” 的关系，该怎么办呢？这时候就需要通配符来发挥作用了。 利用&lt;? extends Wanger&gt; 形式的通配符，可以实现泛型的向上转型，来看例子 Arraylist&lt;? extends Wanger&gt; list2 = new Arraylist&lt;&gt;(4); //list2 是一个 Arraylist，其类型是 Wanger 及其子类。list2.add(null);// list2.add(new Wanger());// list2.add(new Wangxiaoer());Wanger w2 = list2.get(0);// Wangxiaoer w3 = list2.get(1); list2 并不允许通过 add(E e) 方法向其添加 Wanger 或者 Wangxiaoer 的对象，唯一例外的是 null。 虽然不能通过 add(E e) 方法往 list2 中添加元素，但可以给它赋值。 Arraylist&lt;Wanger&gt; list = new Arraylist&lt;&gt;(4);Wanger wanger = new Wanger();list.add(wanger);Wangxiaoer wangxiaoer = new Wangxiaoer();list.add(wangxiaoer);Arraylist&lt;? extends Wanger&gt; list2 = list; //把 list 的值赋予了 list2，此时 list2 == list。由于 list2 不允许往其添加其他元素，所以此时它是安全的——我们可以从容地对 list2 进行 get()、indexOf() 和 contains()。Wanger w2 = list2.get(1);System.out.println(w2);System.out.println(list2.indexOf(wanger));System.out.println(list2.contains(new Wangxiaoer())); &lt;? super Wanger&gt; 形式的通配符，可以向 Arraylist 中存入父类是 Wanger 的元素，来看例子 Arraylist&lt;? super Wanger&gt; list3 = new Arraylist&lt;&gt;(4);list3.add(new Wanger());list3.add(new Wangxiaoer());// Wanger w3 = list3.get(0); 要注意的是，无法从 Arraylist&lt;? super Wanger&gt; 这样类型的 list3 中取出数据。 小结 Java 中，泛型是一种强类型约束机制，可以在编译期间检查类型安全性，并且可以提高代码的复用性和可读性 定义一个泛型类 public class Box&lt;T&gt; &#123; private T value; public Box(T value) &#123; this.value = value; &#125; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125;&#125; 可以在类中任何需要使用类型的地方使用 T 代替具体的类型。通过使用泛型，我们可以创建一个可以存储任何类型对象的盒子。 Box&lt;Integer&gt; intBox = new Box&lt;&gt;(123);Box&lt;String&gt; strBox = new Box&lt;&gt;(&quot;Hello, world!&quot;); 类型擦除编译时会将泛型类型擦除，将泛型类型替换成 Object 类型。这是为了向后兼容，避免对原有的 Java 代码造成影响。 List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();intList.add(123);int value = intList.get(0); Java 编译器会将泛型类型 List&lt;Integer&gt; 替换成 List&lt;Object&gt;，将 get 方法的返回值类型 Integer 替换成 Object，生成的字节码与下面的代码等价： 通配符用于表示某种未知的类型，例如 List&lt;?&gt; 表示一个可以存储任何类型对象的 List，但是不能对其中的元素进行添加操作。 通配符可以用来解决类型不确定的情况，例如在方法参数或返回值中 通配符可以使方法更加通用，同时保证类型安全。 下限通配符下限通配符（Lower Bounded Wildcards）用 super 关键字来声明，其语法形式为 &lt;? super T&gt;，其中 T 表示类型参数。它表示的是该类型参数必须是某个指定类的超类（包括该类本身）。 可以将指定类型的子类型添加到集合中，保证了元素的完整性。 假设有一个类 Animal，以及两个子类 Dog 和 Cat。现在我们有一个 List&lt;? super Dog&gt; 集合，它的类型参数必须是 Dog 或其父类类型。我们可以向该集合中添加 Dog 类型的元素，也可以添加它的子类。但是，不能向其中添加 Cat 类型的元素，因为 Cat 不是 Dog 的子类。 虽然使用下限通配符可以添加某些子类型元素，但是在读取元素时，我们只能确保其是 Object 类型的，无法确保其是指定类型或其父类型。因此，在读取元素时需要进行类型转换，如下所示： List&lt;? super Dog&gt; animals = new ArrayList&lt;&gt;();animals.add(new Dog());// 读取元素时需要进行类型转换Object animal = animals.get(0);Dog dog = (Dog) animal; 上限通配符上限通配符 &lt;? extends T&gt;，表示通配符只能接受 T 或 T 的子类。使用上限通配符可以提高程序的类型安全性。 Java 的泛型机制是一种非常强大的类型约束机制，可以在编译时检查类型安全性，并提高代码的复用性和可读性。但是，在使用泛型时也需要注意类型擦除和通配符等问题，以确保代码的正确性。 第十六章 多线程简介单线程同一时刻, 只允许执行一个 多线程:同一个时刻, 可以执行多个线程, 比如一个QQ可以同时打开多个窗口 普通方法调用和多线程 并发 同一时刻, 多个任务交替执行, 造成一种同时发生的错觉. 单核CPU实现的多任务就是并发 并行 同一时刻, 多个任务同时执行, 多核CPU 程序, 进程, 线程 操作系统中运行的程序就是进制 一个进程可以有多个线程, 如播放器的声音, 图像, 字幕 Process与Thread 说起进程,就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 而进程则是执行程序的依次执行过程，它是一个动态的概念。是系统资源分配的单位。 通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。 注意： 很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。 核心概念 线程就是独立的执行路径。 在程序运行时,即使没有自己创建线程,后台也会有多个线程,比如主线程,GC线程。 main()称之为主线程,为系统的入口,用于执行整个程序。 在一个进程中,如果开辟了多个线程,线程的运行是由调度器（cpu）安排调度的,调度器是与操作系统紧密相关的,先后顺序是不能人为干预的。 对同一份资源操作时mm会存在资源抢夺的问题,需要加入并发控制。 线程会带来额外的开销,如CPU调度时间,并发控制开销。 每个线程在自己的工作内存交互,内存控制不当会造成数据不一致。 线程实现继承Thread类（重要） 自定义线程类继承Thread类； 重写run()方法，编写线程执行体； 创建线程对象，调用start()方法启动线程。 package com.hspedu.threaduse;public class Thread01 &#123; public static void main(String[] args) throws InterruptedException &#123; //创建Cat对象，可以当做线程使用 Cat cat = new Cat(); /* (1) public synchronized void start() &#123; start0(); &#125; (2) //start0() 是本地方法，是JVM调用, 底层是c/c++实现 //真正实现多线程的效果， 是start0(), 而不是 run private native void start0(); */ cat.start();//启动线程-&gt; 最终会执行cat的run方法 //cat.run();//run方法就是一个普通的方法, 没有真正的启动一个线程(启动的是main)，就会把run方法执行完毕，才向下执行 //说明: 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行 //这时 主线程和子线程是交替执行.. System.out.println(&quot;主线程继续执行&quot; + Thread.currentThread().getName());//名字main for(int i = 0; i &lt; 60; i++) &#123; System.out.println(&quot;主线程 i=&quot; + i); //让主线程休眠 Thread.sleep(1000); &#125; &#125;&#125;//1. 当一个类继承了 Thread 类， 该类就可以当做线程使用//2. 我们会重写 run方法，写上自己的业务代码//3. run Thread 类 实现了 Runnable 接口的run方法class Cat extends Thread &#123; int times = 0; @Override public void run() &#123;//重写run方法，写上自己的业务逻辑 while (true) &#123; //该线程每隔1秒。在控制台输出 “喵喵, 我是小猫咪” System.out.println(&quot;喵喵, 我是小猫咪&quot; + (++times) + &quot; 线程名=&quot; + Thread.currentThread().getName()); //让该线程休眠1秒 ctrl+alt+t try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(times == 80) &#123; break;//当times 到80, 退出while, 这时线程也就退出.. &#125; &#125; &#125;&#125; 实现Runnable接口 Java是单继承, 如果一个类已经继承了一个父类, 这时就不能再继承Thread了 Java设计者提供了另外一个创建线程, Runnable public class ThreadRun &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); //dog.start(); 不能使用 //创建Thread对象, 将dog放入调用 Threadalbe thread = new Threadalbe(dog); thread.start(); &#125; &#125;class Dog implements Runnable &#123; int count = 0; @Override public void run() &#123; while(true ) &#123; System.out.println(&quot;hahah&quot; + (++count) + &quot; 线程名=&quot; + Thread.currentThread().getName()); //休眠 try &#123; Thead.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 并发问题&#x2F;多个线程操作同一个资源的情况下,线程不安全,数据紊乱 package github.smt.demo01;//多个线程同时操作同一个对象 买火车票案例public class TestThread04 implements Runnable&#123; // 票数 private int ticketNums = 10; public static void main(String[] args) &#123; TestThread04 thread04 = new TestThread04(); new Thread(thread04,&quot;张三&quot;).start(); new Thread(thread04,&quot;李四&quot;).start(); new Thread(thread04,&quot;王五&quot;).start(); new Thread(thread04,&quot;赵六&quot;).start(); &#125; @Override public void run() &#123; while (true)&#123; if(ticketNums &lt;= 0)&#123; break; &#125; // 捕获异常 try &#123; Thread.sleep(200); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;---》拿到了第&quot; + ticketNums-- + &quot;张票&quot;); &#125; &#125;&#125; 并发 龟兔赛跑 package com.java_2.Thread.threaduse;public class Race implements Runnable &#123; private static String winner; //static只有一个赢家 public static void main(String[] args) &#123; Race thread = new Race(); new Thread(thread, &quot;兔子&quot;).start(); new Thread(thread, &quot;乌龟&quot;).start(); &#125; @Override public void run() &#123; for ( int i = 0; i &lt; 100; i++ ) &#123; //模拟兔子睡觉 if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; i &gt; 50) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;//判断是否有赢家 boolean flags = winner(i); if ( flags == true) &#123; break; &#125; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + &quot; &quot; + &quot;running:&quot; + i); &#125; &#125; public boolean winner (int step) &#123; if (winner != null) &#123; return true; &#125; else if (step &gt;= 99) &#123; winner = Thread.currentThread().getName(); System.out.println(Thread.currentThread().getName() + &quot;win&quot;); return true; &#125; return false; &#125;&#125; 实现Callable接口 实现Callable接口，需要返回值类型； 重写call方法，需要抛出异常； 创建目标对象； 创建执行服务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1); 提交执行：Future result1 &#x3D; ser.submit(11); 获取结果：boolean r1 &#x3D; result1.get(); 关闭服务：ser.shutdownNow(); 对比 继承Thread类: 子类继承Thread类具备多线程能力； 启动线程:子类对象.start()； 不建议使用:避免OOP单继承局限性。 实现Runnable接口 实现接口Runnable具有多线程能力； 启动线程:传入目标对象+Thread对象.start()； Race thread = new Race(); //目标对象 new Thread(thread, &quot;兔子&quot;).start();//Thread对象.start(); new Thread(thread, &quot;乌龟&quot;).start(); 推荐使用:避免单继承局限性,灵活方便,方便同一个对象被多个线程使用。 静态代理Java 静态代理是一种实现代理设计模式的方法，其中代理类和目标类实现相同的接口。静态代理中，代理类和目标类在编译时就已经确定，代理类将客户端的请求转发给-&gt;目标类，并将结果返回给客户端。 具体类实现方法, 代理类调用方法 // 定义接口 public interface Calculator &#123; int add(int a, int b); int subtract(int a, int b); &#125; // 实现接口的具体类 public class ConcreteCalculator implements Calculator &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int subtract(int a, int b) &#123; return a - b; &#125; &#125; // 定义代理类，实现相同的接口，转发请求到目标类 public class CalculatorProxy implements Calculator &#123; private Calculator calculator; public CalculatorProxy(Calculator calculator) &#123; this.calculator = calculator; &#125; @Override public int add(int a, int b) &#123; System.out.println(&quot;Before add&quot;); int result = calculator.add(a, b); System.out.println(&quot;After add&quot;); return result; &#125; @Override public int subtract(int a, int b) &#123; System.out.println(&quot;Before subtract&quot;); int result = calculator.subtract(a, b); System.out.println(&quot;After subtract&quot;); return result; &#125; &#125; 创建目标类的实例 创建代理类的实例，将目标类的实例传入代理类构造函数中，实现代理关系 调用代理类的方法，实际上是转发请求到目标类的方法，**并在前后添加日志输出等操作 ** public class Main &#123; public static void main(String[] args) &#123; // 创建目标类的实例 Calculator calculator = new ConcreteCalculator(); // 创建代理类的实例，将目标类的实例传入代理类构造函数中，实现代理关系 Calculator proxy = new CalculatorProxy(calculator); / int result = proxy.add(1, 2); // 输出 &quot;Before add&quot; 和 &quot;After add&quot;，结果为 3 System.out.println(&quot;Result: &quot; + result); // 输出结果为 3 &#125; &#125; Lambda表达式Lambda 表达式是 Java 8 引入的一项重要特性，它允许以更简洁和灵活的方式编写匿名函数，从而实现函数式编程的特性。 Lambda 表达式的语法形式如下： (parameters) -&gt; expression或(parameters) -&gt; &#123; statements; &#125; 其中： (parameters) 指定了 Lambda 表达式的参数列表。 -&gt; 是 Lambda 操作符，将参数列表与 Lambda 表达式的主体分隔开。 expression 或 &#123; statements; &#125; 是 Lambda 表达式的主体，可以是单个表达式或一个代码块。 Lambda 表达式可以替代匿名内部类的语法，通常用于简化函数式接口的实现，这是因为 Lambda 表达式只能用于函数式接口，即只有一个抽象方法的接口。 例如，对于一个函数式接口 Runnable，可以使用 Lambda 表达式来实现它： Runnable runnable = () -&gt; System.out.println(&quot;Hello, Lambda!&quot;); Lambda 表达式的主要优点包括： 更简洁：可以减少冗余的代码，提高代码的可读性和可维护性。 支持函数式编程：使 Java 更接近于函数式编程语言，支持函数作为一等公民。 Lambda 表达式在 Java 中的广泛应用使得编写函数式风格的代码变得更加方便和简单。 理解Functional Interface (函数式接口) 是学习Java 8 lambda表达式的关键 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数s式接口。 public interface Runnable&#123; public abstract void run();&#125;对于函数式接口，我们可以通过Lambda表达式来创建该接口的对象 线程状态 线程方法 停止线程 线程休眠 try &#123; Thread.sleep(200);&#125;catch (InterruptedException e)&#123; e.printStackTrace();&#125; 线程礼让 礼让线程, 让当前线程正在执行的线程暂停, 但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度, 不一定成功, 看CPU状态 package com.java_2.Thread.threaduse;public class ThreadMyYeild &#123; public static void main(String[] args) &#123; MyYelid myyeild1 = new MyYelid(); new Thread(myyeild1, &quot;1&quot;).start(); new Thread(myyeild1, &quot;2&quot;).start(); //没有yelid 应该是12开始然后结束 //有yelid后, 可能会出现1开始,1结束,再开始2 &#125;&#125;class MyYelid implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始&quot;); Thread.yield(); System.out.println(Thread.currentThread().getName() + &quot;线程结束&quot;); &#125; &#125; 线程插队 join合并线程, 等待此线程执行完成后, 再执行其他线程, 其他线程阻塞 类似插队 /** * 测试join * 插队 */public class Demo20_JoinThread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 500; i++) &#123; System.out.println(&quot;线程vip&quot; + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //启动我们的线程 Demo20_JoinThread joinThread = new Demo20_JoinThread(); Thread thread = new Thread(joinThread); thread.start(); //主线程 //主线程到500是必须等thread执行完才能继续 for (int i = 0; i &lt; 500; i++) &#123; if (i == 200) &#123; thread.join();//插队 &#125; System.out.println(&quot;main&quot; + i); &#125; &#125;&#125; 线程状态观测 /** * 观察测试线程状态 */public class Demo21_ThreadState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;//&quot;); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state); //观察启动后 thread.start(); state = thread.getState(); System.out.println(state);//Run while (state != Thread.State.TERMINATED) &#123;//只要现成不终止,就一直输出状态 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state); &#125; //死亡后的线程不能再启动了,启动会报异常 //thread.start(); &#125;&#125; 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程, 线程调度器按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示,范围从1~10. Thread.MIN_PRIORITY &#x3D; 1; Thread.MAX_PRIORITY &#x3D; 10; Thread.NORM_PRIORITY &#x3D; 5; 使用以下方式改变或获取优先级 getPriority() . setPriority(int xxx) public class TestThreadPriority &#123; public static void main(String[] args) &#123; // 主线程默认优先级 System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread thread1 = new Thread(myPriority); Thread thread2 = new Thread(myPriority); Thread thread3 = new Thread(myPriority); Thread thread4 = new Thread(myPriority); Thread thread5 = new Thread(myPriority); // 先设置优先级，再启动 thread1.start(); thread2.setPriority(1); thread2.start(); thread3.setPriority(4); thread3.start(); // MAX_PRIORITY=10 thread4.setPriority(Thread.MAX_PRIORITY); thread4.start(); thread5.setPriority(8); thread5.start(); &#125;&#125;class MyPriority implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority()); &#125;&#125; 优先级越高, 先执行的概率越高 守护线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 作用如: 后台记录操作日志,监控内存,垃圾回收等待 .. public class TestDemoThread &#123; public static void main(String[] args) &#123; God god = new God(); You you = new You(); Thread thread = new Thread(god); // 默认false表示是用户线程，正常线程都是用户线程 thread.setDaemon(true);//该为守护线程 // 耶稣守护线程启动 thread.start(); // 你 用户线程启动 new Thread(you).start(); &#125;&#125;class God implements Runnable&#123; @Override public void run() &#123; while (true)&#123; System.out.println(&quot;耶稣都救不了你！&quot;); &#125; &#125;&#125;class You implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;------你好，世界！------&quot;); for (int i = 0; i &lt; 36500; i++) &#123; System.out.println(&quot;每天都很开心！&quot;); &#125; System.out.println(&quot;------再见，世界！------&quot;); &#125;&#125; 用户线程结束后, 守护线程不一定结束, 等待程序停止后结束 线程同步 主要用于确保多个线程在访问共享资源时能够正确地协调它们的行为，以避免出现数据不一致或数据损坏的情况。 线程同步的形成条件: 队列 + 锁 由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问 冲突问题,为了保证数据在方法中被访问时的正确性, 在访问时加入 锁机制synchronized, 当一个线程获得对象的排它锁, 独占资源, 其他线程必须等待, 使用后释放锁即可.存在以下问题: 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下, 加锁, 释放锁会导致比较多的上下文切换 和 调度延时, 引起性能问题; 如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置, 引起性能问题. public class TestUnsafeBuyTicket &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,&quot;张三&quot;).start(); new Thread(buyTicket,&quot;李四&quot;).start(); new Thread(buyTicket,&quot;王五&quot;).start(); &#125;&#125;class BuyTicket implements Runnable&#123; // 票 private int ticketNums = 10; boolean flag = true; @Override public void run() &#123; // 买票 while(flag)&#123; try&#123; buy(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; // 买票 private /*synchronized*/ void buy()&#123; //如果加入synchronized会线程同步 // 判断是否有票 if(ticketNums &lt;= 0)&#123; flag = false; return; &#125; // 延迟 try&#123; Thread.sleep(1); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; // 买票 System.out.println(Thread.currentThread().getName() + &quot;拿到&quot; + ticketNums--); &#125;&#125; 每个线程在自己的工作内存交互,内存控制不当会造成数据不一致。 比如票数只有1的时候, 三个线程看到都可以抢票, 最终会导致负数票数 同步方法 同步代码块 synchronized (Object) &#123; //得到对象的锁, 才能操作同步代码&#125;//static方法synchronized (当前类.class) &#123; &#125; 放在方法声明中, 表示整个方法为同步方法 public synchronized void m(String name) &#123; //需要同步的代码&#125; 同步原理每个进程进入run方法时, 会先拿到锁, 使用完成后, 释放锁 锁互斥锁 Java语言中, 引入了对象互斥锁的概念, 来保证共享数据操作的完整性。 每个对象都对应于一个可称为“互斥锁”的标记, 这个标记用来保证在任一时刻, 只能有一个线程访问该对象。 关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时, 表明该对象在任一时刻只能由一个线程访问 同步的局限性: 导致程序的执行效率要降低 同步方法(非静态的)的锁可以是this, 也可以是其他对象(要求是同一个对象) 同步方法(静态的)的锁为当前类本身。 细节 同步方法如果没有使用static修饰:默认锁对象为thi 如果方法使用static修饰,默认锁对象:当前类.class 实现的落地步骤: 需要先分析上锁的代码 选择同步代码块或同步方法 要求多个线程的锁对象为同一个即可! 线程死锁 多个线程都占用了对方的锁资源, 但不肯想让, 导致了死锁 package com.java_2.Thread.threaduse;public class DeadLock &#123; public static void main(String[] args) &#123; //测试死锁 Dead dead = new Dead(true); Dead dead2 = new Dead(false); new Thread(dead, &quot;张三&quot;).start(); new Thread(dead2, &quot;李四&quot;).start(); &#125;&#125;class Dead implements Runnable &#123; //static保证只有一个对象 static Object lock1 = new Object(); static Object lock2 = new Object(); boolean flag = true; public Dead(boolean flag) &#123; this.flag = flag; &#125; @Override //如果flag为真, 进入1, 如果为假进入2, //如果同时两个线程, 一真一假, 则会进入死锁 public void run( ) &#123; if (flag) &#123; synchronized (lock1) &#123;//对象互斥锁, 下面时同步代码 System.out.println(&quot;进入1&quot;); synchronized (lock2) &#123;// 获得对象监视权 System.out.println(Thread.currentThread().getName() + &quot;进入2&quot;); &#125; &#125; &#125; else &#123; synchronized (lock2) &#123; System.out.println(&quot;进入2&quot;); synchronized (lock1) &#123; //获得监视权 System.out.println(Thread.currentThread().getName() + &quot;进入1&quot;); &#125; &#125; &#125; &#125;&#125; 释放锁 当前线程的同步方法、同步代码块执行结束案例:上厕所,完事出来 当前线程在同步代码块、同步方法中遇到break、return。案例:没有正常的完事,经理叫他修改bug,不得已出来 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束案例:没有正常的完事,发现忘带纸,不得已出来 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法,当前线程暂停,并释放锁。案例:没有正常完事,觉得需要酝酿下,所以出来等会再进去 十七章 IO流 文件文件就是保存数据的地方 流的特点 先进先出：最先写入输出流的数据最先被输入流读取到。 顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile除外） 只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流 文件流文件再程序中是以流的形式来操作的 流: 数据在数据源(文件)和程序(内存)之间经历的路径 IO流原理及分类 I&#x2F;O是Input&#x2F;Output的缩写, I&#x2F;O技术是非常实用的技术, 用于处理数据传输。如读&#x2F;写文件,网络通讯等。 Java程序中, 对于数据的输入&#x2F;输出操作以”流(stream)”的方式进行。 java.io包下提供了各种“流”类和接口, 用以获取不同种类的数据, 并通过方法输入或输出数据 IO流原理输入input: 读取外部数据 输出output: 将(程序)内存数据输出到硬盘 根据传输方式划分 字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。 字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。 虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。 InputStream 类 int read()：读取数据 int read(byte b[], int off, int len)：从第 off 位置开始读，读取 len 长度的字节，然后放入数组 b 中 long skip(long n)：跳过指定个数的字节 int available()：返回可读的字节数 void close()：关闭流，释放资源 OutputStream 类 void write(int b)： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃（这块后面再讲） void write(byte b[], int off, int len)： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入 void flush()： 强制刷新，将缓冲区的数据写入 void close()：关闭流 Reader 类 int read()：读取单个字符 int read(char cbuf[], int off, int len)：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中 long skip(long n)：跳过指定个数的字符 int ready()：是否可以读了 void close()：关闭流，释放资源 Writer 类 void write(int c)： 写入一个字符 void write( char cbuf[], int off, int len)： 将数组 cbuf 中的从 off 位置开始，长度为 len 的字符写入 void flush()： 强制刷新，将缓冲区的数据写入 void close()：关闭流 字节流和字符流的区别 字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。 字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。 字符流源码 , 利用到了缓冲区 操作对象划分文件操作算是 IO 中最典型的操作了，也是最频繁的操作。 那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为： 文件、数组、管道、基本数据类型、缓冲、打印、对象序列化&#x2F;反序列化，以及转换等。 文件流: IO流的起点与终点 IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。 java.io.File 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。 File 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 怎么理解上面两句话？其实很简单！ 第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！ 第二句是说 File 可以表示D:\\\\文件目录1与D:\\\\文件目录1\\\\文件.txt，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的。 创建文件对象相关构造器和方法创建文件和目录 比较常用的构造方法有三个： 1、 File(String pathname) ：通过给定的路径来创建新的 File 实例。 2、 File(String parent, String child) ：从父路径（字符串）和子路径创建新的 File 实例。 3、 File(File parent, String child) ：从父路径（File）和子路径名字符串创建新的 File 实例。 String pathname = &quot;e:\\ ew.txt&quot;;//方式1createNewFile 创建新文件File file = new File(pathname); try &#123; file.createNewFile();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;//方式2//e:\\ ews2.txt@Testpublic void create02() &#123;File parentFile = new File(&quot;e:\\\\&quot;);String fileName = &quot;news2.txt&quot;;//这里的 file 对象，在 java 程序中，只是一个对象//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件File file = new File(parentFile, fileName);try &#123; file.createNewFile(); System.out.println(&quot;创建成功~&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//方式 3 new File(String parent,String child) //根据父目录+子路径构建@Testpublic void create03() &#123; //String parentPath = &quot;e:\\\\&quot;; String parentPath = &quot;e:\\\\&quot;; String fileName = &quot;news4.txt&quot;; File file = new File(parentPath, fileName); try &#123; file.createNewFile(); System.out.println(&quot;创建成功~&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 获取文件信息获取功能的方法 1、getAbsolutePath() ：返回此 File 的绝对路径。 2、getPath() ：结果和 getAbsolutePath 一致。 3、getName() ：返回文件名或目录名。 4、length() ：返回文件长度，以字节为单位。 File file = new File(&quot;e:\\ ews1.txt&quot;);//调用相应的方法，得到对应信息System.out.println(&quot;文件名字=&quot; + file.getName());//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectorySystem.out.println(&quot;文件绝对路径=&quot; + file.getAbsolutePath());System.out.println(&quot;文件父级目录=&quot; + file.getParent());System.out.println(&quot;文件大小(字节)=&quot; + file.length());System.out.println(&quot;文件是否存在=&quot; + file.exists());//TSystem.out.println(&quot;是不是一个文件=&quot; + file.isFile());//TSystem.out.println(&quot;是不是一个目录=&quot; + file.isDirectory());//F 判断功能的方法1、 exists() ：判断文件或目录是否存在。 2、 isDirectory() ：判断是否为目录。 3、isFile() ：判断是否为文件。 File file = new File(&quot;/Users/username/example&quot;);// 判断文件或目录是否存在if (file.exists()) &#123; System.out.println(&quot;文件或目录存在&quot;);&#125; else &#123; System.out.println(&quot;文件或目录不存在&quot;);&#125;// 判断是否是目录if (file.isDirectory()) &#123; System.out.println(&quot;是目录&quot;);&#125; else &#123; System.out.println(&quot;不是目录&quot;);&#125;// 判断是否是文件if (file.isFile()) &#123; System.out.println(&quot;是文件&quot;);&#125; else &#123; System.out.println(&quot;不是文件&quot;);&#125; 目录的操作和文件删除 createNewFile() ：文件不存在，创建一个新的空文件并返回true，文件存在，不创建文件并返回false。 delete() ：删除文件或目录。如果是目录，只有目录为空才能删除。 mkdir() ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。 mkdirs() ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。 String path = &quot;&quot;;File file = new File(path)//删除 if(file.exists()) &#123; file.delete();&#125; else &#123; file.mkdirs(); file.mkdisr();//不能创建多级目录&#125;//java中, 目录也被当做文件 目录的遍历 String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。 File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。 File directory = new File(&quot;/Users/itwanger/Documents/Github/paicoding&quot;);// 列出目录下的文件名String[] files = directory.list();System.out.println(&quot;目录下的文件名：&quot;);for (String file : files) &#123; System.out.println(file);&#125;// 列出目录下的文件和子目录File[] filesAndDirs = directory.listFiles();System.out.println(&quot;目录下的文件和子目录：&quot;);for (File fileOrDir : filesAndDirs) &#123; if (fileOrDir.isFile()) &#123; System.out.println(&quot;文件：&quot; + fileOrDir.getName()); &#125; else if (fileOrDir.isDirectory()) &#123; System.out.println(&quot;目录：&quot; + fileOrDir.getName()); &#125;&#125; listFiles在获取指定目录下的文件或者子目录时必须满足下面两个条件： 指定的目录必须存在 指定的必须是目录。否则容易引发 NullPointerException 异常 字节流: Java IO的基石必须得明确一点，一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。 字节输出流（OutputStream）java.io.OutputStream 是字节输出流的超类（父类），我们来看一下它定义的一些共性方法： 1、 close() ：关闭此输出流并释放与此流相关联的系统资源。 2、 flush() ：刷新此输出流并强制缓冲区的字节被写入到目的地。 3、 write(byte[] b)：将 b.length 个字节从指定的字节数组写入此输出流。 4、 write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 也就是说从off个字节数开始一直到len个字节结束 FileInputStream和Output例子// 声明一个 int 类型的变量 b，用于存储读取到的字节int b;// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据FileInputStream fis1 = new FileInputStream(&quot;fis.txt&quot;);// 循环读取文件中的数据while ((b = fis1.read()) != -1) &#123;// 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1。 // 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台 System.out.println((char)b);&#125;// 关闭 FileInputStream 对象，释放资源fis1.close();//////////////////// 声明一个 int 类型的变量 b，用于存储读取到的字节int b;// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据FileInputStream fis1 = new FileInputStream(&quot;fis.txt&quot;);// 循环读取文件中的数据while ((b = fis1.read()) != -1) &#123; // 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台 System.out.println((char)b);&#125;// 关闭 FileInputStream 对象，释放资源fis1.close(); 写入字节数组 // 使用文件名称创建流对象FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 字符串转换为字节数组byte[] b = &quot;abcde&quot;.getBytes(); // 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。fos.write(b,2,2);// 关闭资源fos.close(); 数据追加, 换行上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续追加新数据，该怎么办呢？以及如何实现换行呢？ 使用FileOutputStream的另外两个构造方法 使用文件名和追加标志创建FileOutputStream对象 boolean append = true; //附加的意思, false表示清除数据FileOutputStream fos = new FileOutputStream(&quot;examle.txt&quot;, append);//将数据追加到末尾 换行 String content = &quot;测试\\r &quot;; //使用换行符FileOutputStream fos = new FileOutputStream(&quot;examle.txt&quot;, append);fos.write(content.getBytes()); 小结InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 read()、read(byte[] b)、read(byte[] b, int off, int len) 等。 OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 write(int b)、write(byte[] b)、write(byte[] b, int off, int len) 等。 这两个抽象类是字节流的基础。 FileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。 FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。 这两个类是字节流最常用的实现类之一。 字符流字符符流 Reader 和 Writer 的故事要从它们的类关系图开始，来看图。 用字节流直接读取中文，可能会遇到乱码问题 之所以出现乱码是因为在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。 用字节流处理中文 try (FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;)) &#123; byte[] bytes = new byte[1024]; int len; while ((len = inputStream.read(bytes)) != -1) &#123; System.out.print(new String(bytes, 0, len)); &#125;&#125; 我们拿 String 类进行了解码，查看new String(byte bytes[], int offset, int length)的源码就可以发现，该构造方法有解码功能 另一角度来说：字符流 &#x3D; 字节流 + 编码表 字符传入流Readerjava.io.Reader是字符输入流的超类（父类），它定义了字符输入流的一些共性方法： 1、close()：关闭此流并释放与此流相关的系统资源。 2、read()：从输入流读取一个字符。 3、read(char[] cbuf)：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下： 可以通过构造方法指定要读取的文件路径。 每次可以读取一个或多个字符。 可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换 构造方法 1、FileReader(File file)：创建一个新的 FileReader，参数为File对象。 2、FileReader(String fileName)：创建一个新的 FileReader，参数为文件名。 读取字符数据1. 读取字符：read方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1。 // 使用文件名称创建流对象FileReader fr = new FileReader(&quot;abc.txt&quot;);// 定义变量，保存数据int b;// 循环读取while ((b = fr.read())!=-1) &#123; System.out.println((char)b);&#125;// 关闭资源fr.close(); 2. 读取指定长度的字符：read(char[] cbuf, int off, int len)，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数 例如: off &#x3D; 9, len &#x3D; 数组.length FileReader 实现了 AutoCloseable 接口，因此可以使用 try-with-resource语句自动关闭资源，避免了手动关闭资源的繁琐操作。 字符输出流 Writerjava.io.Writer 是字符输出流类的超类（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法： 1、write(int c) 写入单个字符。 2、write(char[] cbuf) 写入字符数组。 3、write(char[] cbuf, int off, int len) 写入字符数组的一部分，off为开始索引，len为字符个数。 4、write(String str) 写入字符串。 5、write(String str, int off, int len) 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。 6、flush() 刷新该流的缓冲。 7、close() 关闭此流，但要先刷新它。 java.io.FileWriter 类是 Writer 的子类，用来将字符写入到文件。 FileWriter 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，参数为要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，参数为要读取的文件的名称。 FileWriter写入数据写入指定字符数组 fw = new FileWriter(&quot;output.txt&quot;); char[] chars = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;&#125;;fw.write(chars, 0, 5); // 将字符数组的前 5 个字符写入文件 写入指定字符串 String str = &quot;沉默王二真的帅啊！&quot;;try (FileWriter fw = new FileWriter(&quot;output.txt&quot;)) &#123; fw.write(str, 0, 5); // 将字符串的前 5 个字符写入文件&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 关闭close和刷新flushFileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中 但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 //源 也就是输入流【读取流】 读取a.txt文件FileReader fr=new FileReader(&quot;abc.txt&quot;); //必须要存在a.txt文件，否则报FileNotFoundException异常//目的地 也就是输出流FileWriter fw=new FileWriter(&quot;b.txt&quot;); //系统会自动创建b.txt，因为它是输出流！int len;while((len=fr.read())!=-1)&#123; fw.write(len);&#125;//注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用fr.close();//关闭了缓冲区fw.flush();//刷新缓冲区, 让其可以继续使用fw.close();//最终关闭 FileWriter的续写和换行续写和换行：操作类似于FileOutputStream操作open in new window，直接上代码： // 使用文件名称创建流对象，可以续写数据FileWriter fw = new FileWriter(&quot;fw.txt&quot;,true); // 写出字符串fw.write(&quot;沉默王二&quot;);// 写出换行fw.write(&quot;\\r &quot;);// 写出字符串fw.write(&quot;是傻 X&quot;);// 关闭资源fw.close(); 小结Writer 和 Reader 是 Java I&#x2F;O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。 Writer 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。 在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。 缓冲流Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I&#x2F;O 操作的效率。 Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。 缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的 I&#x2F;O 操作次数，提高系统的 I&#x2F;O 效率，从而提高程序的运行效率。 字节缓冲流构造方法 BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。 BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流，注意参数类型为OutputStream。 // 创建字节缓冲输入流，先声明字节流FileInputStream fps = new FileInputStream(b.txt);BufferedInputStream bis = new BufferedInputStream(fps)// 创建字节缓冲输入流（一步到位）BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;b.txt&quot;));// 创建字节缓冲输出流（一步到位）BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;)); 缓冲流的高效我们通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下： // 记录开始时间long start = System.currentTimeMillis();// 创建流对象try (FileInputStream fis = new FileInputStream(&quot;py.mp4&quot;);//exe文件够大 FileOutputStream fos = new FileOutputStream(&quot;copyPy.mp4&quot;))&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125;// 记录结束时间long end = System.currentTimeMillis();System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); 再试试缓冲流 + 字符数组 package com.java_2.IOstream;import java.io.*;import java.io.FileOutputStream;public class FIleCopy &#123; public static void main(String[] args) &#123; copyFile(); &#125; public static void copyFile() &#123; long start = System.currentTimeMillis(); String filePath = &quot;C:\\\\Users\\\\Qyingli\\\\Videos\\\\泸沽湖.mp4&quot;; String newFilePath = &quot;C:\\\\Users\\\\Qyingli\\\\Videos\\\\泸沽湖2.mp4&quot;; FileInputStream fis = null; FileOutputStream fos = null; try &#123; //使用缓冲流起飞 fis = new FileInputStream(filePath); fos = new FileOutputStream(newFilePath); BufferedInputStream bis = new BufferedInputStream(fis); BufferedOutputStream bos = new BufferedOutputStream(fos); //字节数组 byte[] buf = new byte[1024*8]; int readData =0; while ((readData = bis.read(buf, 0, 4)) != -1) &#123; bos.write(buf, 0, readData); //将数组 buf 中的从 0 位置开始，长度为 readData 的字节写入 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fis.close(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125; 传统的 Java IO 是阻塞模式的，它的工作状态就是“读&#x2F;写，等待，读&#x2F;写，等待。。。。。。” 字节缓冲流解决的就是这个问题：一次多读点多写点，减少读写的频率，用空间换时间。 减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I&#x2F;O 操作的效率。 减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I&#x2F;O 操作的效率。 提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。 4）byte &amp; 0xFFbyte 类型是有符号的，即其取值范围为 -128 到 127。如果我们希望得到的是一个无符号的 byte 值，就需要使用 byte &amp; 0xFF 来进行转换。 字符缓冲流BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 readLine() 方法可以一次读取一行数据，而不是一个字符一个字符地读取。 BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 newLine() 方法可以写入一个系统特定的行分隔符。 构造方法 BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。 BufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。 2）字符缓冲流特有方法字符缓冲流的基本方法与普通字符流open in new window调用方式一致，这里不再赘述，我们来看字符缓冲流特有的方法。 BufferedReader：String readLine(): 读一行数据，读取到最后返回 null BufferedWriter：newLine(): 换行，由系统定义换行符。 // 创建流对象BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));// 定义字符串,保存读取的一行文字String line = null;// 循环读取,读取到最后返回nullwhile ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(&quot;------&quot;);&#125;// 释放资源br.close(); // 创建流对象BfferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));// 写出数据bw.write(&quot;沉&quot;);// 写出换行bw.newLine();bw.write(&quot;默&quot;);bw.newLine();bw.write(&quot;王&quot;);bw.newLine();bw.write(&quot;二&quot;);bw.newLine();// 释放资源bw.close(); 练习//字符串分割String cmower = &quot;沉默王二.一枚有趣的程序员&quot;;if (cmower.contains(&quot;.&quot;)) &#123; String [] parts = cmower.split(Pattern.quote(&quot;.&quot;)); System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);&#125; 6.岑夫子，丹丘生，将进酒，杯莫停。 1.君不见黄河之水天上来，奔流到海不复回。 8.钟鼓馔玉不足贵，但愿长醉不愿醒。 3.人生得意须尽欢，莫使金樽空对月。 5.烹羊宰牛且为乐，会须一饮三百杯。 2.君不见高堂明镜悲白发，朝如青丝暮成雪。 7.与君歌一曲，请君为我倾耳听。 4.天生我材必有用，千金散尽还复来。 package com.java_2.IOstream;import java.io.*;import java.io.FileOutputStream;import java.util.HashMap;import java.util.regex.Pattern;import java.io.DataInputStream;public class Buffere &#123; public static void main(String[] args) &#123; sortStirng(); &#125; public static void sortStirng() &#123; // 创建map集合,保存文本数据,键为序号,值为文字 HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;(); String filePath = &quot;C:\\\\Users\\\\Qyingli\\\\Documents\\\\MarkDown\\ ew.txt&quot;; String newFilePath = &quot;C:\\\\Users\\\\Qyingli\\\\Documents\\\\MarkDown\\ ew22.txt&quot;; FileReader fis = null; FileWriter fos = null; BufferedReader bis = null; BufferedWriter bos = null; try &#123;// 创建流对象 源 fis = new FileReader(filePath); fos = new FileWriter(newFilePath); bis = new BufferedReader(fis); bos = new BufferedWriter(fos); String line; while ((line = bis.readLine())!=null) &#123; // 解析文本 if (line.isEmpty()) &#123; continue; &#125; String[] split = line.split(Pattern.quote(&quot;.&quot;)); // 保存到集合 lineMap.put(split[0], split[1]); &#125;// for (int i = 1; i &lt;= lineMap.size(); i++) &#123;// String key = line.valueOf(i);// // 获取map中文本// String value = lineMap.get(key);// // 写出拼接文本// bos.write(key+&quot;.&quot;+value);// // 写出换行// bos.newLine();// &#125; for (String i : lineMap.keySet()) &#123; bos.write(i + &quot;.&quot; + lineMap.get(i)); // 写出换行 bos.newLine(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fis.close(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; for (String i : lineMap.keySet()) &#123; System.out.println(&quot;key: &quot; + i + &quot; value: &quot; + lineMap.get(i)); &#125; &#125;&#125; 转换流字节流和字符流之间的转换 转换流主要有两种类型：InputStreamReader 和 OutputStreamWriter。 InputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。 字符集Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。 常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。 ASCII 字符集ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。 ASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制。 Unicode 字符集Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。 为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。它们的差别在于使用的字节长度不同。 UTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 0x00~0x7F），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。 UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 0x0000~0xFFFF），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。 UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。 GBK 字符集GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。 GBK 编码是一种变长的编码 GB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等 乱码 当使用不同的编码方式读取或者写入文件时，就会出现乱码问题 InputStreamReaderjava.io.InputStreamReader 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 String s = &quot;沉默王二！&quot;;try &#123; // 将字符串按GBK编码方式保存到文件中 OutputStreamWriter outUtf8 = new OutputStreamWriter( new FileOutputStream(&quot;logs/test_utf8.txt&quot;, &quot;GBK&quot;); outUtf8.write(s); outUtf8.close(); // 将字节流转换为字符流，使用GBK编码方式 InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;); // 读取字符流 int c; while ((c = isr.read()) != -1) &#123; System.out.print((char) c); &#125; isr.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; OutputStreamWriterjava.io.OutputStreamWriter 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName)：创建一个指定字符集的字符 try &#123; // 从文件读取字节流，使用UTF-8编码方式 FileInputStream fis = new FileInputStream(&quot;test.txt&quot;); // 将字节流转换为字符流，使用UTF-8编码方式 InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;); // 使用缓冲流包装字符流，提高读取效率 BufferedReader br = new BufferedReader(isr); // 创建输出流，使用UTF-8编码方式 FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;); // 将输出流包装为转换流，使用UTF-8编码方式 OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;); // 使用缓冲流包装转换流，提高写入效率 BufferedWriter bw = new BufferedWriter(osw); // 读取输入文件的每一行，写入到输出文件中 String line; while ((line = br.readLine()) != null) &#123; bw.write(line); bw.newLine(); // 每行结束后写入一个换行符 &#125; // 关闭流 br.close(); bw.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 小结InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。 InputStreamReader 类的常用方法包括： read()：从输入流中读取一个字符的数据。 read(char[] cbuf, int off, int len)：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。 ready()：返回此流是否已准备好读取。 close()：关闭输入流。 OutputStreamWriter 类的常用方法包括： write(int c)：向输出流中写入一个字符的数据。 write(char[] cbuf, int off, int len)：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。 flush()：将缓冲区的数据写入输出流中。 close()：关闭输出流。 在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码。 序列化Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。 序列化是指将一个对象转换为一个字节序列（包含对象的数据、对象的类型和对象中存储的属性等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 Serializable 接口open in new window的对象才能被序列化。 反序列化是指将一个字节序列转换为一个对象，以便在程序中使用 ObjectOutputStreamjava.io.ObjectOutputStream 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。 来看 ObjectOutputStream 的构造方法：ObjectOutputStream(OutputStream out) 该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如： FileOutputStream fos = new FileOutputStream(&quot;file.txt&quot;);ObjectOutputStream oos = new ObjectOutputStream(fos); 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口open in new window，否则会抛出NotSerializableException 。 该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用transient 关键字open in new window进行修饰。 public class Employee implements Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化&#125; 接下来，来聊聊 writeObject (Object obj) 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。 public class ObjectOutputStreamDemo &#123; public static void main(String[] args) &#123; Person person = new Person(&quot;沉默王二&quot;, 20); try &#123; FileOutputStream fos = new FileOutputStream(&quot;logs/person.dat&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(person); oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Person implements Serializable &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; 上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化。 ObjectInputStreamObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据、对象的类型和对象中存储的属性等信息）。 序列化之前是什么, 序列化后就是什么 ObjectInputStream(InputStream in) ： 创建一个指定 InputStream 的 ObjectInputStream。 String filename = &quot;logs/person.dat&quot;; // 待反序列化的文件名try (FileInputStream fileIn = new FileInputStream(filename); ObjectInputStream in = new ObjectInputStream(fileIn)) &#123; // 从指定的文件输入流中读取对象并反序列化 Object obj = in.readObject(); // 将反序列化后的对象强制转换为指定类型 Person p = (Person) obj; // 打印反序列化后的对象信息 System.out.println(&quot;Deserialized Object: &quot; + p);&#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace();&#125; 首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息。 KryoSerializable 接口Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。 序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；反序列化open in new window的思想是“解冻”对象状态，重新获得可用的 Java 对象。 序列化有一条规则，就是要序列化的对象必须实现 Serializbale 接口，否则就会报 NotSerializableException 异常。 //定义public interface Serializable &#123; &#125; 通过 ObjectOutputStream 将“18 岁的王二”写入到文件当中，实际上就是一种序列化的过程；再通过 ObjectInputStream 将“18 岁的王二”从文件中读出来，实际上就是一种反序列化的过程。 // 初始化Wanger wanger = new Wanger();wanger.setName(&quot;王二&quot;);wanger.setAge(18);System.out.println(wanger);// 把对象写到文件中try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));)&#123; oos.writeObject(wanger);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;// 从文件中读出对象try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));)&#123; Wanger wanger1 = (Wanger) ois.readObject(); System.out.println(wanger1);&#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace();&#125; ObjectInputStream 为例，它在反序列化的时候会依次调用 readObject()→readObject0()→readOrdinaryObject()→readSerialData()→defaultReadFields()。 ObjectOutputStream 为例，它在序列化的时候会依次调用 writeObject()→writeObject0()→writeOrdinaryObject()→writeSerialData()→invokeWriteObject()→defaultWriteFields()。 Serializable只起到一个标识作用, 真正的序列化不由他来完成 打印流 System.out.println() 的使用频率恐怕不亚于 main 方法的使用频率。其中 System.out 返回的正是打印流 PrintStream 。 除此之外，还有它还有一个孪生兄弟，PrintWriter。 PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，也就是说，一个字节流open in new window，一个是字符流open in new window。 打印流具有以下几个特点： 可以自动进行数据类型转换：打印流可以将各种数据类型转换为字符串，并输出到指定的输出流中。 可以自动进行换行操作：打印流可以在输出字符串的末尾自动添加换行符，方便输出多个字符串时的格式控制。 可以输出到控制台或者文件中：打印流可以将数据输出到控制台或者文件中，方便调试和日志记录（尽管生产环境下更推荐使用 Logbackopen in new window、ELK 等）。 PrintStream 类的常用方法包括： print()：输出一个对象的字符串表示形式。 println()：输出一个对象的字符串表示形式，并在末尾添加一个换行符。 printf()：使用指定的格式字符串和参数输出格式化的字符串。 关于printf %s：输出一个字符串。 %d 或 %i：输出一个十进制整数。 %x 或 %X：输出一个十六进制整数，%x 输出小写字母，%X 输出大写字母。 %f 或 %F：输出一个浮点数。 %e 或 %E：输出一个科学计数法表示的浮点数，%e 输出小写字母 e，%E 输出大写字母 E。 %g 或 %G：输出一个浮点数，自动选择 %f 或 %e/%E 格式输出。 %c：输出一个字符。 %b：输出一个布尔值。 %h：输出一个哈希码（16进制）。 %n：换行符 PrintWriter pw = new PrintWriter(&quot;output.txt&quot;);pw.println(&quot;沉默王二&quot;);int age = 18;pw.printf(&quot;他的年纪为 %d. &quot;, age);pw.close(); Properties类从配置文件中 传统方法读取BufferedReader br = new BufferedReader(new FileReader(&quot;src\\\\mysql.properties&quot;));String line = &quot;&quot;;while ((line = br.readLine()) != null) &#123; //循环读取 //分割字符String[] split = line.split(&quot;=&quot;); while((line = br.readLine()) != -1) &#123; if(line == null) &#123; continue; &#125; //指定只获得ip Stirng [] spilt = line.spilt(&quot;=&quot;); System.out.println(spilt[0] + &quot;值:&quot; + spilt[1]) &#125;&#125;br.close( 使用properties类 load: 加载配置文件的键值对到properties对象 list: 将数据显示到指定设备 getProperties(key): 根据键值对到properties对象 setProperties(key, value): 设置键值对到Properties store: 将properties中键值对存储到配置文件, 在idea中, 保存信息到配置文件 //使用 Properties 类来读取 mysql.properties 文件//1. 创建 Properties 对象Properties properties = new Properties();//2. 加载指定配置文件properties.load(new FileReader(&quot;src\\\\mysql.properties&quot;));//3. 把 k-v 显示控制台properties.list(System.out);//4. 根据 key 获取对应的值String user = properties.getProperty(&quot;user&quot;);String pwd = properties.getProperty(&quot;pwd&quot;);System.out.println(&quot;用户名=&quot; + user);System.out.println(&quot;密码是=&quot; + pwd);","tags":["Java"],"categories":["记录"]},{"title":"Java学习笔记 -第一阶段","path":"/2023/12/04/Java第一阶段/","content":"Java概述1.1 什么是程序 程序：计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合 1.2Java历史 1990sun公司启动绿色计划 1992创建oak语言-&gt;Java 1994gosling参加硅谷大会演示Java功能，震惊世界 2009，甲骨文公司收购sun，2011，发布Java7 … 1.3 Java技术体系平台 JavaSE 标准版 JavaEE企业版 JavaME 小型版 1.4 Java重要特点 面向对象 强类型机制，异常处理，垃圾的自动收集 跨平台 解释型（编译后通过需要解释器执行，编译型语言编译后可以直接运行） 1.5 Java运行机制Test.java-&gt;Test.class-&gt;JVM-&gt;跨平台 Java虚拟机 JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据，内存，寄存器，包含在jdk中。 不同平台不同虚拟机（针对不同的指令集） Java虚拟机机制屏蔽了底层运行的差异，一次编译，随意运行。 JDK JDK 的全称(Java Development Kit Java 开发工具包) JDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等] JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独 安装 JRE 了 JRE JRE(Java Runtime Environment Java 运行环境) JRE &#x3D; JVM + Java 的核心类库[类] 包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。 JDK、JRE 和 JVM 的包含关系 JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等) JRE &#x3D; JVM + Java SE 标准类库（java 核心类库 如果只想运行开发好的 .class 文件 只需要 JRE 1.6 Java开发注意事项和细节说明 源文件的基本组成部分是类（class）。 执行入口是main(). public static void main() {} 一个源文件包含一个public，其他类不限，并且文件名必须按照public来命名 可以将main方法写在非public类中，然后指定运行非public类 先认识基本框架和语法，再去了解细节 1.7 转义字符在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能 实现对齐 ：换行符 \\ \\ ：一个\\ \\ “ :一个” &#39; ：一个’ 输出斜杠，“ \\r :一个回车 System.out.println(“韩顺平教育\\r北京”e 先输出韩顺平教育，然后将光标定在这一行首，输出北京平教育 1.8 文档注释注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类 文档注释允许你在程序中嵌入关于程序的信息。 你可以使用 javadoc 工具软件来生成信息，并输出到 HTML 文件中。 文档注释，使你更加方便的记录你的程序信息。 import java.io.*;/***这个类演示了文档注释* @author* @version 1.2*/public class SquareNum &#123; /** * This method returns the square of num. * This is a multiline description. You can use * as many lines as you like. * @param num The value to be squared. * @return num squared. */ public double square(double num) &#123; return num * num; &#125; /** * This method inputs a number from the user. * @return The value input as a double. * @exception IOException On input error. * @see IOException 0o */ public double getNumber() throws IOException &#123; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader inData = new BufferedReader(isr); String str; str = inData.readLine(); return (new Double(str)).doubleValue(); &#125;/** * This method demonstrates square(). * @param args Unused. * @return Nothing. * @exception IOException On input error. * @see IOException */ public static void main(String args[]) throws IOException &#123; SquareNum ob = new SquareNum(); double val; System.out.println(&quot;Enter value to be squared: &quot;); val = ob.getNumber(); val = ob.square(val); System.out.println(&quot;Squared value is &quot; + val); &#125;&#125; 1.9 dos原理 相对路径，绝对路径 常用dos命令 查看当前目录是有什么内容 dir dir dir d:\\abc2\\test200 切换到其他盘下：盘符号 cd : change directory 案例演示：切换到 c 盘 cd &#x2F;D c: 切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录 案例演示： cd d:\\abc2\\test200 cd ....\\abc2\\test200 切换到上一级： 案例演示： cd … 切换到根目录：cd \\ 案例演示：cd \\ 查看指定的目录下所有的子级目录 tree 清屏 cls [苍老师] 退出 DOS exit 说明: 因为小伙伴后面使用 DOS 非常少，所以对下面的几个指令，老韩给大家演示下, 大家了解即可 (md[创建目 录],rd[删除目录],copy[拷贝文件],del[删除文件],echo[输入内容到文件],type,move[剪切]) &#x3D;&gt; Linux 变量2.1 为什么需要变量 变量是程序的基本组成单位 三个基本要素：类型+名称+值 2.2 变量 变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房 间，而通过变量名可以访问到变量(值) 基本使用步骤 声明 赋值 使用 2.3 注意事项 变量表示内存中的一个存储区域 该区域拥有自己的名称 变量必须先声明，后使用 该区域的数据&#x2F;值可以在同一类型范围内不断变化 变量在同一个作用域内不能重名 三要素 2.4 +的使用 左右两边都是数值型时，做加法运算 两边有一方为字符串时，做拼接运算 2.5 数据类型每一种数据都定义了明确的数据类型，在内存中分配了大小不同的内存能空间 java 数据类型分为两大类 基本数据类型， 引用类型 基本数据类型有 8 中 数值型 [ byte（1字节、-128~127）, short（2字、-32768~32767）, int（4） , long（8） , float（4） ,double（8） 关于浮点数在机器中存放形式的简单说明, 浮点数&#x3D;符号位+指数位+尾数位 数部分可能丢失，造成精度损失(小数都是近似值) ] char , boolean 引用类型 [类，接口， 数组] 2.6 浮点类型使用细节 十进制形式：5.12 512.0f .512(必须有小数) ​\t科学计数法： 5.12e2(5.12*10^2) 5.12E-2（5.12&#x2F;10^2） 浮点数使用陷阱： 2.7 和8.1&#x2F;3比较 double num1 = 2.7;double num2 = 8.1/3; // 2.7System.out.println(num1);System.out.println(num2); // 接近2.7的一个小数// 比较大小的正确方法if(Math.abs(num1 - num2) &lt; 0.0000001) &#123;System.out.println(&quot;插值很小，到我们规定的精度范围内时认为相等&quot;)&#125; 2.7 JavaAPI的使用 API（application programming interface,应用程序接口）是Java提供的基本编程接口 Java提供了大量的基础类，因此Oracle公司也为这些基础类提供了相应的API文档，用以说明使用 Java类的组织形式 在API文档包中索引使用 2.8 char一个char表示两个字节，多个字符用string。 使用细节 单引号 转义字符 在Java中，char的本质是一个整数，输出时是在Unicode码中对应的字符 char可以赋值整数，然后输出会按照Unicode字符输出（97-&gt;a） char可以运算，相当于一个整数，因为它都对应有Unicode码 Unicode兼容ASCII 字符本质 字符型存储到计算机中，需要将字符对应的码值（整数）找出来，比如（a-&gt;97-&gt;二进制-&gt;存储）,读取相反。 字符和码值是规定好的 ASCII（ASCII 编码表 一个字节表示，共128个字符） Unicode（Unicode 编码表 固定大小的编码 使用两个字节来表示字符，字母和汉字统一都是占用两个字节，这样浪费空间） utf-8（大小可变的编码，字母使用1个字节，汉字使用3个字节） gbk（可以表示汉字，而且范围广，字母使用1个字节，汉字2个字节） 2.9 基本数据类型转换当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的类型。 char-&gt;int-&gt;long-&gt;float-&gt;double-&gt; byte-&gt;short—&gt;int-&gt;long-&gt;float-&gt;double 注意事项和细节 有多种类型数据混合运算时，首先将所有数据转换为容量最大的，再进行计算 大变小会报错 byte，short和char之间不会进行自动转换 byte，short,char三者可以计算，都当作int Boolean不参与转换 自动提升原则：表达式结果的类型自动提升为操作数最大的类型 强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成 精度降低或溢出,格外要注意。 int i = （int)1.9; char类型可以保存整型常量，但不能保存int变量的值。 int m = 10; char c = m; //错误 基本数据类型和string类型的转换 将基本类型的值加上“”即可。 int n &#x3D; 100; string s &#x3D; n + “”; string转基本类型用到包装类 String c = &quot;100&quot;;int/double/float/long num = Integer/Double/Float.parseInt/Double/Flaot/Long(c); 注意 ​\t1. 在将 String 类型转成 基本数据类型时，要确保String类型能够转成有效的数据 ，比如我们可以把 “123” , 转成一 个整数，但是不能把 “hello” 转成一个整数 如果格式不正确，就会抛出异常，程序就会终止， 这个问题在异常处理章节中，会处理 第四章 运算符4.1 关系运算符逻辑运算 a&amp;b : &amp; 叫逻辑与 规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false a&amp;&amp;b : &amp;&amp; 叫短路与 规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 和&amp;的区别：&amp;&amp;只要第一个为false第二个就不会判断，而&amp;&amp;第二个不会判断，效率更高； a|b : | 叫逻辑或 规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false a||b : || 叫短路或 规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 区别：||如果第一个为true，第二个就不会判断 !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true a^b: 叫逻辑异或，当 a 和不同时结果为true 4.2 三元运算符条件表达式？表达式1：表达式2； 规则： 如果条件表达式为true，运算后结果为表达式1，否则为2； 细节 表达式1和2要为可以赋给接受变量的类型（或可以自动转换）】 三元运算符可以转成if-else int a = 1;int b = 2;a &gt; b ? 1.1 : 2.2; //不行a &gt; b ? (int)1.1 : (int)2.2;// 可以 4.3 优先级 优先级 运算符 结合性 1 ( )　[ ] . &lt;- 2 ! ~ ++ – &lt;- 3 * &#x2F; % &lt;- 4 + - &lt;- 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; &lt;- 6 &lt; &lt;&#x3D; &gt; &gt;&#x3D; instanceof &lt;- 7 &#x3D;&#x3D; !&#x3D; &lt;- 8 &amp; &lt;- 9 ^ &lt;- 10 &#96; &#96; 11 &amp;&amp; &lt;- 12 &#96; 13 ? : &lt;- 14 &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; &#96; &#x3D;&#96; ^&#x3D; ~&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D; 15 ， -&gt; 只有单目运算符，赋值运算符是从右向左的。 用多就熟悉了 4.4 标识符的规则和规范 Java对各种变量、方法和类命名时使用的字符序列称为标识符 凡是自己可以起名字的地方都叫标识符 规则：‘ 不可以使用关键字和保留字，但可以包含。 规范： 包名：多单词组成时所有字母都小写：aaa.bbb.ccc &#x2F;&#x2F;比如 com.hsp.crm 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档. 4.5 键盘输入语句需要一个扫描器（对象），就是Scanner 步骤： 导入该类所在的包 创建该类的对象（声明变量） 调用里面的功能 import java.util.Scanner;public class Input &#123; public static void main(String[] args) &#123; //1. 引入Scanner的包 //2. 创建Scanner对象，new创建 Scanner myScanner = new Scanner(System.in); //3. 接受用户输入，使用相关方法 System.out.println(&quot;Please input your name:&quot;); String name = myScanner.next(); //调用myScanner对象的方法next()，表示接受用户的输入 System.out.println(&quot;Please input your age:&quot;); int age = myScanner.nextInt(); System.out.println(&quot;Please input your page:&quot;); double page = myScanner.nextDouble(); System.out.println(&quot;name:&quot; + name + &quot; age:&quot; + age + &quot; page:&quot; + page); &#125;&#125; 4.6 各种进制十进制小数转二进制1.用2乘十进制小数，可以得到积，将积的整数部分取出2.再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出3.重复操作，直到积中的小数部分为零，此时0或1为二进制的最后一位，或者达到所要求的精度为止 0.125 * 2 = 0.25 ------0 0.25 * 2 = 0.5 ------0 0.5 * 2 = 1.0 ------1 当小数部分为零时就可以停止，然后正序输出，0.001； 八进制转十六八进制-&gt;二进制-&gt;十六进制 位运算原码，反码，补码 二进制的最高位是符号位，0正1负 正数的原码，补码，反码都一样 负数的反码&#x3D;他的原码符号位不变，其它位取反 负数的补码&#x3D;他的反码+1，负数的反码&#x3D;复数的补码+1 0的补码和反码都是0 Java中的数都是有符号的 Java运算的时候，都是以补码的方式运算 看计算结果时，要看他的原码，Java是将补码转换成原码 位运算符 Java中有7个运算符 &amp;（按位与)、|（、^、~、&gt;&gt;、&lt;&lt;和&gt;&gt;&gt; &gt;&gt;算数右移:低位溢出,符号位不变,并用符号位补溢出的高位 &gt;&gt;算数左移:符号位不变,低位补零 &gt;&gt;&gt;有符号右移:低位溢出,高位补零 没有&lt;&lt;&lt;运算符 int a = 1 &gt;&gt; 2;//00000001 -&gt;00000000 ,相当于除二,1&#x2F;2&#x2F;2 &#x3D; 0 int a = 1 &lt;&lt; 2; // 0000 00100 本质1*2*2&#x3D;4 第五章5.1 顺序控制程序从上到下逐行执行,中间没有任何判断和跳转 5.2 分支控制if-else让程序有选择的执行 ifif-elseif()-else if()-else()-…-else()最后一个为else 嵌套分支一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外 层分支。老师建议: 不要超过 3 层 （可读性不好） 5.3 switch分支结构 注意事项 表达式数据类型应该和case后面的类型一致,或者是可以自动转化的类型,比如输入字符,而常量是int switch(表达式)中返回值必须是:byte, short, int, char, enum, Sting double c = 1.1;switch(c)&#123; case 1.1: // 错误e System.out.println(&quot;yeah&quot;); break;&#125; case子句中的值必须是常量,不能是变量 default是可选的 switch和if的比较 如果判断的具体数值不多,而且符号byte, short, int, char, enum, Sting符合,使用switch. 其他情况:对区间判断,结果为Boolean类型,使用if,if的使用范围更广. 5.4 for循环细节 1.循环条件是返回一个布尔值的表达式 for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略 public class ForDetail &#123; public static void main(Sting[] args) &#123; int i = 1; // 初始化写在外面 for(; i &lt; 10; ) &#123; System.out.println(&quot;nb&quot;); i++; //变量迭代写到循环中也可以 &#125; &#125;&#125; 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代 语句，中间用逗号隔开。 public class ForDetail &#123; public static void main(Sting[] args) &#123; int count = 3; for (int i = 0; j = 0; i &lt; count; i++, j++) &#123; System.out.println(&quot;nv&quot;); &#125; &#125;&#125; 5.5 while5.6 do…while5.7 多重循环控制! 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。 【建议一般使用两层，最多不要超过 3 层, 否则，代码的可读性很差】 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内 层循环，才可结束外层的当次循环，开始下一次的循环 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次 练习import java.util.Scanner;public class Input &#123; public static void main(String[] args) &#123; double s0,s1,s2,s3,s4 = 0; double score = 0; double sum = 0; int count = 0; for (int i = 0; i &lt; 3; i++) &#123; System.out.print(&quot;Enter the number: &quot;); Scanner sc = new Scanner(System.in); s0 = sc.nextInt(); s1 = sc.nextInt(); s2 = sc.nextInt(); s3 = sc.nextInt(); s4 = sc.nextInt(); score = (s0 + s1 + s2 + s3) / 5; System.out.println(&quot;平均成绩为:&quot; + score); sum += score; &#125; System.out.println(&quot;所有班级平均成绩为:&quot; + sum / 3); &#125;&#125; import java.util.Scanner;public class Input &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt;= 9; i++) &#123; for(int j = 1; j &lt;= i; j++) &#123; System.out.print(i + &quot;*&quot; + j + &quot;=&quot; + (i * j) + &quot;\\t&quot;); &#125; /* 按行输出 for(int j = 1; j &lt;= i; j++) &#123; System.out.print(i + &quot;*&quot; + j + &quot;=&quot; + (i * j) + &quot;\\t&quot;); &#125; */ System.out.println(); &#125; &#125;&#125; 思路分析 化繁为简 先打印一个矩形 打印半个金字塔 打印完整金字塔 第一层:1个* 第二层:3个* 第三层:5个* … 第五层:9个* 规律:2*层数-1,等差数列(an &#x3D; a1 + (n-1) * d) 带入公差2,得到:an &#x3D; 2n - 1; 熟能生巧 先死后活:先考虑固定的值,然后转换成灵活变化的值 求1100，9的倍数，那如果以后有490,534436654,123567,8的倍数，10的倍数，3的倍数等等的话，也应该可以利用这个程序，所以我们只需要把固定的数据，用变量来替换，那么就能适用更多情况 import java.util.Scanner;public class Input &#123; public static void main(String[] args) &#123; int totalLevel = 10; //层数 for (int i = 1; i &lt;= totalLevel; i++) &#123; //i 表示层数//在输出*之前，还有输出 对应空格 = 总层数-当前层 for (int k = 1; k &lt;= totalLevel - i; k++) &#123; System.out.print(&quot;%&quot;); &#125;//控制打印每层的*个数,打印完整三角,就需要*2,但这样第一行就会有两个,所有需要再-1; for (int j = 1; j &lt;= 2 * i - 1; j++) &#123; //当前行的第一个位置是*,最后一个位置也是*, 最后一层全部 * if (j == 1 || j == 2 * i - 1|| i == totalLevel) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; //其他情况输出空格 System.out.print(&quot; &quot;); &#125; &#125;//每打印完一层的*后，就换行 println 本身会换行 System.out.println(); &#125; &#125;&#125; 跳转控制语句break细节 break语句出现在多层嵌套的语句块中时,可以通过标签指明要终止的是哪一层语句块 标签的基本使用 label1: &#123; label2: &#123; label3: &#123; break label1; &#125; &#125;&#125;//1. break语句可以指定退出那层//2. label1是标签,名字有程序员指定//3. break后指定到那个label就退出到哪里//4. 在实际的开发中,尽量不是用标签//5. 如果没有指定break,默认退出最近的循环体 跳转控制语句continue 结束本次循环,开始下一次 可以通过标签指明要跳过那一层循环,规则与break一样 跳转控制语句return 跳出所在的方法 如果return写在main方法,则退出程序 听懂了,不会做我亦无他,唯手熟尔 第六章 数组,排序,查找数组 数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。 即数组就是一组数据 double hens[] &#x3D; {…} 数组的使用动态初始化 使用方式1 数组的定义 数据类型 数组名[] &#x3D; new 数据类型[大小] int a[] &#x3D; new int[5] 数组的引用(使用\\访问\\获取数组元素) 数组名[下标\\索引\\index] 动态初始化 使用方式2 先声明数组 数据类型 数组名[]; int a[]; &#x2F;&#x2F;只是个空值,没有存储空间 创建数组 数组名 &#x3D; new 数据类型[大小]; a &#x3D; new int[5]; &#x2F;&#x2F;分配内存空间 静态初始化 使用方式3 初始化数组 数据类型 数组名[] &#x3D; {元素值} int a[] &#x3D; {1,,1,2,33,} 细节 数组是多个相同数据类型的组合,实现对这些数据的统一管理 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null 使用数组的步骤 声明数组并开辟空间 给数组各个元素赋值 使用数组 数组的下标是从 0 开始的。 数组下标必须在指定范围内使用，否则报：下标越界异常，比如 数组赋值机制 基本数据类型赋值,这个值就是具体的数值,不互相影响 int a &#x3D; 1; int b &#x3D; 2; 数组在默认情况下是引用传递,赋的值是地址 int arr1[] = &#123;1, 2, 3&#125;;int arr2[] = arr1;arr2[0] = 10; //此时arr1[0]也会被修改 值传递和引用传递 值传递是拷贝一份过去 引用是把地址给过去 数组的值在堆内,基本数据类型的值在栈里 数组拷贝要求数据空间独立 int arr1[] = &#123;1, 2, 2,&#125;;//创建一个新的数组,开辟新空间//大小 arr1.length;int arr2[] = new int[arr1.length];//遍历arr1for(int i = 0; i &lt; arr1.length; i++) &#123; arr2[i] = arr1[i];&#125; 数组反转把数组的内容反转 arr {1, 2, 3, 4, 5, 6, 7, 8,} -&gt; arr {8, 7, 6, 5, 4, 3, 2, 1,} import java.util.Scanner;public class Input &#123; public static void main(String[] args) &#123; int arr[] = new int[] &#123;1, 2, 3, 4, 5, 6&#125;; int temp = 0; for (int i = 0; i &lt; arr.length / 2; i++) &#123; temp = arr[i]; arr[i] = arr[arr.length - 1 - i]; arr[arr.length - 1 - i] = temp; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; &#125;&#125; 数组扩容要求：实现动态的给数组添加元素效果，实现对数组扩容。 1. 原始数组使用静态分配 int[] arr &#x3D; {1,2,3} 增加的元素 4，直接放在数组的最后 arr &#x3D; {1,2,3,4} 用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y&#x2F;n /*1. 原始数组使用静态分配arr2. 要改变容量只能新建一个数组arrNew,根据原有大小动态分配3. 拷贝到新数组4. 让arr指向arrNew,原来的数据被销毁,即弃用原来的空间 import java.util.Scanner;public class Input &#123; public static void main(String[] args) &#123; int arr[] = new int[] &#123;1, 2, 3, 4, 5, 6&#125;; char yOrn = &#x27; &#x27;; while (arr.length != 1 || yOrn != &#x27;n&#x27;) &#123; System.out.println(&quot;If you want to add length ? [y/n]&quot;); Scanner sc = new Scanner(System.in); yOrn = sc.next().charAt(0); if (yOrn == &#x27;y&#x27;) &#123; int arrNew[] = new int [arr.length + 1]; System.out.println(&quot;Enter the value:&quot;); arrNew[arrNew.length - 1] = sc.nextInt(); for (int i = 0; i &lt; arr.length; i++) &#123; arrNew[i] = arr[i]; &#125; arr = arrNew; for (int i = 0; i &lt; arrNew.length; i++) &#123; System.out.println(arrNew[i]); &#125; &#125; else if (yOrn == &#x27;n&#x27; || arr.length != 1) &#123; int arrNew[] = new int [arr.length - 1]; System.out.println(&quot;Enter the value:&quot;); arrNew[arrNew.length - 1] = sc.nextInt(); for (int i = 0; i &lt; arrNew.length - 1; i++) &#123; arrNew[i] = arr[i]; &#125; arr = arrNew; for (int i = 0; i &lt; arrNew.length; i++) &#123; System.out.println(arrNew[i]); &#125; &#125; &#125; &#125;&#125; 排序将多个数据, 依指定的顺序排列的过程 内部排序 将所有需要处理的数据都加载到内部存储器中排序(交换式排序法, 选择排序法和插入式排序法) 外部排序法 数据量大,无法全部加载到内存中,需要借助外部存储进行排序(合并排序, 直接合并排序) 冒泡排序通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒 思路: 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 int a[] = new int[5];a[] = &#123;1, 2, 3, 4, 5,&#125;;for (int i = 0; i &lt; a.length - 1; i++) &#123; for (int j = 0; j &lt; a.length - 1 - i; j++) &#123; int temp = 0; if (a[i] &gt; a[j+1]) &#123; temp = arr[i]; arr[i] = arr[j+1]; arr[j+1] = temp; &#125; &#125; 查找 顺序查找 字符串比较函数 变量1.equals(变量2) ,输出boolean 判断经常会使用index来保存状态 二维数组二维数组指向一片空间,这个空间里存储多个一维数组,一维数组再指向真正的存储数据空间 a[1] [1]代表第二个一维数组里存储的第二个值 遍历就是遍历指向的每一个一维数组的值 可以推广到三维数组… 二维数组的使用方法一 先声明: 类型 数组名 再定义: 开辟空间 数组名 &#x3D; new 类型[大小][大小] arr &#x3D; new int[4][3] 赋值(有默认值,比如int就为0) 方法二 动态初始化,列数不确定 JAVA中可以有列数不同的数组 arr[3][] {1, 2, 3, 4, 5, 6, 7} {1, 2, 4,} {3, 3, 4, 5, ,2,} // arr[3][] 这种写法需要给每一个一维数组开辟空间int arr[][] = new int[10][];// 如果没有给一维数组new, 那么arr[i]就是Nullfor (int i = 0; i &lt;　arr.length; i++)&#123; arr[i] = new int[i + 1];&#125; 定义 类型 数组名 练习 声明: int[]x,y[];判断以下选择 (说明:x是int类型的一维数组,y是int类型的二维数组) x[0] &#x3D; y; &#x2F;&#x2F;错误,x[0]是一维数组,y是二维数组 int[][] -&gt; int y[0] &#x3D; x; &#x2F;&#x2F;正确, 都是一维数组 y[0][0] &#x3D; x; &#x2F;&#x2F;错误 x[0][0] &#x3D; y; &#x2F;&#x2F;x[0][0]不存在 y[0][0] &#x3D; x[0] &#x2F;&#x2F;正确 细节 二维数组实际上是有多个一维数组组成的,他的各个一维数组的长度可以相同,也可以不同 面向对象*　单独变量解决,不利于数据的管理*　数组无法提现数据类型 *　只能通过下标获取，造成变量名和内容信息不明确 类与对象 提取特性 定义类 通过类创建对象 总结为: 类也是一个数据类型, 只是是用户自定义的 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型. 对象是具体的，实际的，代表一个具体事物, 即 是实例. 类是对象的模板，对象是类的一个个体，对应一个实例 定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。 声明类的对象，就像声明基本类型的变量一样。 class Cat &#123; //properties String name; int age; String color;&#125;Cat cat1 = new Cat();cat1.name = &quot;小花&quot;;cat1.age = 2;cat1.color = &quot;blue&quot;; 对象在内存中的存在形式 对象名(对象引用)在栈里是地址,对象本体在堆中 属性&#x2F;成员变量&#x2F;字段 成员变量 &#x3D; 属性 &#x3D; 字段(field) 属性可以是任何数据类型(基本+引用) 属性细节 属性的定义语法同变量， 示例：访问修饰符 属性类型 属性名; 这里老师简单的介绍访问修饰符： 控制属性的访问范围 有四种访问修饰符 public, proctected, 默认, private ,后面我会详细介绍 属性的定义类型可以为任意类型，包含基本类型或引用类型 属性如果不赋值，有默认值，规则和数组一致。 具体说: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000， boolean false，String null 创建&amp;&amp;访问对象 先声明再创建 Cat cat ; &#x2F;&#x2F;声明对象(先给名字) cat cat &#x3D; new Cat(); &#x2F;&#x2F;创建 (给空间) 直接创建 Cat cat &#x3D; new Cat(); 对象名.属性 对象分配机制类似数组拷贝 对象创建Person p = new Person();p.name = &quot;jack&quot;;p.age = 11;Person q = null; //空指针 先加载Person类信息(属性和方法信息,只会加载一次) 在堆中分配空间,进行属性默认初始化(看规则) 把地址付给p,p就指向对象 进行指定初始化(p.name &#x3D; “jack”;) 成员方法 在某些情况下，我们要需要定义成员方法(简称方法)。 比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一些行为比如: 可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。 方法的使用提高了代码复用 可以将实现封装起来,方便其他用户使用 现在要求对 Person类完成 public class Method &#123; public static void main(Sting args[]) &#123; //方法使用 //1.方法写好后,如果不调用,不会输出 //2. 先创建对象,然后调用方法 Person p = new Person(); p.speak(); int sum = p.cla01(22); &#125;&#125;class Person &#123; String name; int age; //方法(成员方法) //添加speak成员方法,输出一句话; //1. public表示方法公开 //2. void表示无返回值 //3. speak() speak是方法名 ()形参列表 //4. &#123;&#125; 方法体,可以写我们要执行的代码 public void speak() &#123; System.out.println(&quot;一句话&quot;); &#125; //计算从0到n的值 public int cla01(int n) &#123; int res = 0; for(int i = 0; i &lt;= n; i++) &#123; res += i; &#125; return res; &#125;.\t&#125; 方法执行流程 在栈里创建main栈 main栈里创建对象 堆中生成对象空间 在栈里新建方法空间(与main独立), 从main中调到方法空间 通过return返回main 使用细节 访问修饰符 (作用是控制 方法使用的范围) 如果不写默认访问， [有四种: public, protected, 默认, private], 具体在后面说 返回数据类型 一个方法最多有一个返回值 [思考，如何返回多个结果 返回数组 ] 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ; 方法名 遵循驼峰命名法，最好见名知义，表达出该功能的意思即可 参数列表 参数类型任意 调用时必须对应参数类列表传入相同类型或兼容类型的参数 方法定义的是形参,调用时的参数为实参 方法体 方法里面不能再定义方法, 即不能嵌套 方法调用细节和说明 同一个类的方法直接调用 class A &#123; public void print(int n) &#123; System.out.println(&quot;Before storm rain&quot;); &#125; public void say() &#123; print(3); System.out.println(&quot;oK?&quot;); &#125;&#125; 跨类的方法调用, 通过对象名. 对象名.方法名(参数); 在未创建实例的情况下,不能调用类中的方法 public class Main&#123; public static void main(String[] args) &#123; int num = 11; Function fun= new Function(); if (fun.fun1(num)) &#123; System.out.println(&quot;num is a odd number&quot;); &#125; else &#123; System.out.println(&quot;num is a even number&quot;); &#125; Function.fun2(); &#125;&#125;class Function&#123; public boolean fun1(int num) &#123; System.out.println(&quot;1.通过实例调用方法&quot;); if(num % 2 == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; public static void fun2() &#123; System.out.println(&quot;2.不创建实例直接调用放方法。&quot;); &#125;&#125; 传参机制!! 引用类型传递的是地址（传递也是值,值-&gt;地址），可以通过形参影响实参 基本变量则是传递值, 方法中会复制一份. 和C一样似乎 JAVA中操控内存的方式是引用,类似c&#x2F;c++中的指针 一般有三种: 数组, 类, 接口 引用传递虽然不会复制值, 但是会在栈中的方法空间里新建一个实参引用, 这个引用main中的实参独立; Person p = new Person();p.age = 10;p.name = &quot;jack&quot;;b.test200(p);System.out.println(&quot;main 的p.age:&quot; +　ｐ．age); //输出age:10class Person &#123;String name;int age;&#125;class B &#123;public void test200(Person p) &#123;//p.age = 10000; //修改对象属性//思考// 在堆中新建一个对象p,然后p指向这片空间, 并且与main中p的空间独立p = new Person();p.name = &quot;tom&quot;;p.age = 99;//思考//p = null;&#125; 克隆对象 方法的返回类型Person 形参(Pesson p) 方法体, 创建一个新对象,并复制属性,返回即可 public static void main(String args[])&#123; Person p = new Person(); p.name = &quot;sam&quot;; p.age = 12; MyTools tools = new MyTools(); Person p2 = tools.copyPerson(p); System.out.println(&quot;...&quot;); &#125; class MyTools &#123; public Person copyPerson(Person p)&#123; Person p2 = new Person(); p2.name = p.name; p2.age = p.age; return p2;&#125;&#125;// return 后的P2在main中指向的空间就是在方法中的,是同一块; 方法递归调用!! 递归就是自己调用自己，每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁 栈的特性:先进后出 public void test(int n) &#123; if (n ＞ 2) &#123; test(n - 1); &#125; System.out.println(n + &quot;&quot;);&#125; 阶乘public int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 流程倒过来思考 递归规则 执行一个方法时,就创建一个新的受保护的独立空间(栈) 方法的局部变量是独立的, 不会相互影响 如果方法中是引用变量类型, 共享该引用类型的数据 递归必须向退出的条件逼近, 否则死龟了 放一个方法执行完毕, 或者遇到return, 就会返回,遵守谁调用,谁就将结果返回给谁. 也就是方法执行完毕或者返回时,该方法就执行完毕 练习吃桃子问题猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！ 以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时， 想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子？ public int test(int n) &#123; if (n ==　10) &#123; return 1; &#125; else if (n &gt;= 1 &amp;&amp; n &lt;= 9) &#123; return (test(n + 1) + 1) * 2; &#125; else &#123; System.out.println(&quot;error&quot;) return -1; &#125;&#125; 迷宫问题 0表示可以走, 1表示障碍 二维矩阵四周全部设置为1 将障碍物设置为1 i, j 表示老鼠位置,初为(1, 1) 0-&gt;可以走, 2-&gt;障碍物, 3-&gt;都走过了, 但是走不通,死路 当map[6]&#x2F;[5] &#x3D; 2时就说明找到了通路,否则继续找 确定走路策略: 下-&gt;右-&gt;上-&gt;左 public class Main &#123; public static void main(String[] args) &#123; //用二维数组建立地图 int map[][] = new int[4][4]; for (int i = 0; i &lt; 4; i++) &#123; map[i][0] = 1; map[i][3] = 1; &#125; for (int i = 0; i &lt; 4; i++) &#123; map[0][i] = 1; map[3][i] = 1; &#125; //设置障碍// map[2][1] = 1;// map[2][2] = 1; //查看地图 for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; System.out.println();//创建方法 Function function = new Function(); function.FindWay(map, 1, 1); //遍历路径 for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125;class Function &#123; public boolean FindWay(int map[][], int i, int j) &#123; //每次开始先检查目标点是否到达, 如果到达, 会逐层放回true退出递归 if (map[2][2] == 2) &#123; return true; &#125; else &#123; if (map[i][j] == 0) &#123; //将经过的点设为2 map[i][j] = 2;// 从当前点开始找路, 将经过的设为2, 在找到目标点后返回true退出 if (FindWay(map, i + 1, j)) &#123; return true; &#125; else if (FindWay(map, i, j + 1)) &#123; return true; &#125; else if (FindWay(map, i - 1, j)) &#123; return true; &#125; else if (FindWay(map, i, j - 1)) &#123; return true; &#125; else &#123; //都没找到,表明地图是死路,逐层递归,所有点都被设为3 map[i][j] = 3; return false; &#125; &#125; else &#123;// 遇到障碍物 return false; &#125; &#125; &#125;&#125; 汉诺塔思路: 如果只有一个塔,直接从a到c 如果有多个塔, 当作两个来处理, 因为三根柱子一次只能操作两个塔 public class Main &#123; public static void main(String[] args) &#123; Function function = new Function(); function.move(4, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); &#125;&#125;class Function &#123; public void move(int num, char a, char b, char c) &#123; if (num == 1) &#123; System.out.println(a + &quot;-&gt;&quot; + c); &#125; else &#123; //1. 先移动上面所有的盘, 借助C move(num - 1, a, c, b); //2. 把最下面的盘移动到C System.out.println(a + &quot;-&gt;&quot; + c); //3. 再把b塔所有的盘移动到c, 借助a move(num - 1, b, a, c); &#125; &#125;&#125; 八皇后问题思路: 条件即是:if(p != i &amp;&amp; q != j &amp;&amp; i != j) 方法重载Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一样 重载的好处 减轻了起名的麻烦 减轻了记名的麻烦 例如println就是典型的重载，同一个方法可以应用不同的情况、 细节 方法名必须相同 形参列表： 必须不同（形参类型、个数或者顺序至少有一个不同，参数名无要求） 返回类型： 无要求， 返回类型不同不构成重载 可变参数 Java允许将同一个类中多个同名同功能但参数个数不同的方法方法封装成一个方法 基本语法访问修饰符 返回类型 方法名(数据类型… 形参名) class HspMethod &#123;//可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。//可以使用方法重载 public int sum(int n1, int n2) &#123;//2 个数的和 return n1 + n2; &#125; public int sum(int n1, int n2, int n3) &#123;//3 个数的和 return n1 + n2 + n3; &#125; public int sum(int n1, int n2, int n3, int n4) &#123;//4 个数的和 return n1 + n2 + n3 + n4; &#125;//..... //上面的三个方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化 //1. int... 表示接受的是可变参数 //2. 使用可变参数时，可以当作数组来使用nums， 通过下标控制传来的实参选择 public int sum(int... nums) &#123; int res = 0; for(int i = 0; i &lt; nums.length; i++) &#123; res += nums[i]; &#125; return res; &#125; 细节 可变参数的个数可以是0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数放在最后 public void f(String str, double... nums) 一个形参列表中只能有一个可变参数 作用域 在java编程中，主要的变量就是（属性）成员变量和局部变量 局部变量一般在成员方法中定义 分类： 全局变量： 也就是属性，作用域为整个类体 局部变量： 出来属性之外的变量，作用域为在他的代码块中 全局变量可以不赋值直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值 细节 属性和局部变量可以重名，访问时遵循就近原则 在同一个作用域中，局部变量不能重名 属性生命周期较长，伴随着对象的创建直到销毁。局部变量伴随代码块的执行而创建，代码块结束就销毁 作用域范围不同 全局变量&#x2F;属性： 可以被本类使用，也可以被其他类使用（通过对象调用） 局部变量：只能在本类中对应的方法中使用 修饰符不同（public这些） 全局变量&#x2F;属性可以加修饰符 局部变量不可以加修饰符 构造方法&#x2F;构造器 对象已经存在，构造器完成对新对象的初始化 我们来看一个需求：前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如 果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造器。 基本语法[修饰符] 方法名（形参列表） &#123; 方法体；&#125; 构造器没有返回值 修饰符可以默认 方法名和类名必须一致 参数列表和成员方法一样的规则，即参数要保持一致 构造器的调用由系统完成，如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造方法 构造器可以重载 class Person &#123; String name; int age; //方法与类同名 public Person (String pName, int pAge) &#123; name = pName; age = pAge; &#125; public Person (String pName) &#123; name = pName; &#125;&#125; 对象创建流程分析 加载Person类信息（Person.calss），只会加载一次 在堆中分配空间 完成对象初始化 默认初始化 显式初始化 构造器初始化 将堆中对象地址返回给p，即对象的引用 this关键字 JAVA虚拟机会给每个对象分配this,代表当前对象. 每个对象创建后, 那个对象被调用, this就是谁. 可以理解为对象在堆中创建空间后, 会有一个this引用, 指向这片空间. public class Main &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;Jack&quot;, 3); System.out.println(dog.hashCode()); dog.info();\t// dog.hashCode和this.hashCode是一样的 Dog dog1 = new Dog(&quot;sam&quot;, 4); System.out.println(dog1.hashCode()); dog1.info(); &#125;&#125;class Dog &#123; public String name; public int age; //构造器 public Dog(String name, int age) &#123; this.name = name; this.age = age; &#125; public void info() &#123; System.out.println(this.name + &quot;\\t&quot; + this.age + &quot;\\t&quot; + &quot;当前对象的hashcode是:&quot; + this.hashCode()); &#125;&#125; 细节 this关键字可以用来访问本类的属性, 方法, 构造器 this用于区分当前类的属性和局部变量(同名的时候 ) 访问成员方法的语法: this.方法名(参数列表); 访问构造器: this(参数列表); &#x2F;&#x2F; 只能在构造器中访问另外一个构造器 public T() &#123; this(&quot;jack&quot;, 12); //去访问另外一个构造器, 并且只能放在第一条语句 System.out.println(&quot;ldasl&quot;);&#125;public T(String name, int age) &#123;&#125; this不能在类定义的外部使用, 只能在类定义的方法中使用 例子 public class TestPerson &#123;//编写一个 main 方法public static void main(String[] args) &#123;Person p1 = new Person(&quot;mary&quot;, 20); Person p2 = new Person(&quot;mary&quot;, 20);System.out.println(&quot;p1 和 p2 比较的结果=&quot; + p1.compareTo(p2)); &#125;&#125;class Person &#123;String name;int age;//构造器public Person(String name, int age) &#123;this.name = name; // this.name指的是类中的属性name,而后面的name指的是传入的name;this.age = age; &#125;//compareTo 比较方法public boolean compareTo(Person p) &#123;//名字和年龄完全一样 //当前的name和传进来的p的name比较 if(this.name.equals(p.name) &amp;&amp; this.age == p.age) &#123; return true;&#125; else &#123;\treturn false; &#125;return this.name.equals(p.name) &amp;&amp; this.age == p.age;&#125; &#125; 作业8 public class test &#123; int count = 9; public void count1 () &#123; count = 10; System.out.println(&quot;count1:&quot; + count); &#125; public static void main(String arg[]) &#123; //1. new test() 是匿名对象, 匿名对象使用后,就不能使用,也就是只能用一次,因为没有东西对他进行引用 new test().count1(); &#125;&#125; 13 public class Main &#123; public static void main(String[] args) &#123;// Function function = new Function(); Circle circle = new Circle(); PassObject passObject = new PassObject(); passObject.printArea(circle, 5); &#125;&#125;class Function &#123; double n1 ,n2;&#125;class Circle &#123; double radius; public Circle() &#123;&#125; // 无参构造器 // 初始化 public Circle(double radius) &#123; this.radius = radius; &#125; //获取radius public void getRadius(double radius) &#123; this.radius = radius; &#125; public double findArea() &#123; return Math.PI * this.radius * this.radius; &#125;&#125;class PassObject &#123; public void printArea(Circle c, int times) &#123; System.out.println(&quot;Area&quot; + &quot;\\t&quot; + &quot;Radius&quot;); for (int i = 0; i &lt; times; i++) &#123; c.getRadius(times - i); System.out.println(c.findArea() + &quot;\\t&quot; + (times - i)); &#125; &#125;&#125; 第八章 面向对象(中级)包三大作用 区分相同名字的类 当类很多时候,可以很好的管理类 控制访问范围 包的基本语法package blue package 关键字, 表示打包 blue包名 包的本质就是创建不同的文件夹&#x2F;目录来保存类文件, 项目的src目录下 命名规则只能包含数字,字母,下划线,小圆点,不能数字开头,不能是关键字和保留字 规范com.公司名.项目名.业务模块名 常用包java.lang &#x2F;&#x2F;基本包,不需要引入 java.util &#x2F;&#x2F;系统提供的工具包 java.net &#x2F;&#x2F;网络包,网络开发 java.awt &#x2F;&#x2F;做Java界面开发 细节引入import 包; import java.util.Scanner; import java.util;引入所有 package的作用是声明当前类所在的包,需要放在类的最上面,一个类中最多一句package imoport指令位置放在package下面 访问修饰符java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）: 公开级别:用 public 修饰,对外公开 受保护级别:用 protected 修饰,对子类和同一个包中的类公开 默认级别:没有修饰符号,向同一个包的类公开. 私有级别:用 private 修饰,只有类本身可以访问,不对外公开 细节 修饰符可以用于属性,成员方法,类 只有默认和public才能修饰类 子类就是继承 封装 封装是把对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法进行操作。 封装的主要目的是保护对象的内部状态不被随意修改，同时提供了更好的数据隐藏和安全性。 隐藏实现的细节 方法 可以对数据进行验证,保证安全合理 实现步骤 将属性进行私有化private 提供一个公共的方法set方法,用于对属性进行判断并赋值 提供一个public的gEet方法,用于获取属性的值 public class Person &#123; public String name; private int age; private int salary; public String getName() &#123; return name; &#125;// 快捷键alt + insert public void setName(String name) &#123; if (name != null &amp;&amp; name.length() &gt;= 2 &amp;&amp; name.length() &lt;= 6 ) &#123; this.name = name; //谁调用就是谁的 &#125; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if (age &gt;= 0 &amp;&amp; age &lt;= 100) &#123; this.age = age; &#125; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary(int salary) &#123; if(salary &gt;= 0) &#123; this.salary = salary; &#125; &#125; public String info() &#123; return &quot;name:&quot; + name + &quot; &quot; + &quot;salary:&quot; + salary + &quot;age:&quot; + &quot; &quot; + age; &#125;&#125; 封装与构造器如果不将封装和构造器结合在一起,构造器就可以跳过封装 //构造器传入参数时可以不调用setAgepublic void setAge(int age) &#123; if (age &gt;= 0 &amp;&amp; age &lt;= 100) &#123; this.age = age; &#125; &#125;public Person (int age) &#123; //this.age = age; this.setAge(age);&#125; 可以将setxx方法写在构造器中 继承 继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，您不需要重新编写新的数据成员和成员方法，只需指定新建的类继承了一个已有的类的成员即可 这个已有的类称为基类，新建的类称为派生类 只需要通过 extends 来 声明继承父类即可。 class 子类 extends 父类 { } 细节 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问 public int getxx() &#123; return xx; &#125; public void callxxx() &#123; xxx();&#125;&#x2F;&#x2F; 调用xxx方法 2.子类必须调用父类的构造器， 完成父类的初始化. 先调用父类的,再调用子类的 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器. 如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不通过.super(参数列表);使用父类的构造器 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表) super 在使用时，必须放在构造器第一行(super 只能在构造器中使用) super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 java 所有类都是 Object 类的子类, Object 是所有类的基类. 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关 继承的本质 class GrandPa &#123; String name = &quot;大头爷爷&quot;; String hobby = &quot;旅游&quot;;&#125;class Father extends GrandPa &#123; String name = &quot;大头爸爸&quot;;&#125;class Son extends Father &#123; String name = &quot;大头儿子&quot;;&#125; 看子类有没有属性 如果子类有属性,访问 如果子类没有属性,则访问父类 如果父类没有,则查找上一级 练习class A &#123; A() &#123; System.out.println(&quot;a&quot;); &#125; A(String name) &#123; System.out.println(&quot;a name&quot;); &#125;&#125;class B &#123; B() &#123; this(&quot;abc&quot;); //单参构造器 &#125; B(String name) &#123; System.out.println(&quot;b name&quot;); &#125;&#125;//mian中: B b = new B(); //无参构造器//B中有隐藏的super(), 先调用A的无参构造器,然后调用B的单参构造器//a, b name, b 编写 Computer 类，包含 CPU、内存、硬盘等属性，getDetails 方法用于返回 Computer 的详细信息 编写 PC 子类，继承 Computer 类，添加特有属性【品牌 brand】 编写 NotePad 子类，继承 Computer 类，添加特有属性【color】 编写 Test 类，在 main 方法中创建 PC 和 NotePad 对象，分别给对象中特有的属性赋值，以及从 Computer 类继承的 属性赋值，并使用方法并打印输出信 //TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.public class Main &#123; public static void main(String[] args) &#123; PC pc = new PC(); pc.setCpu(&quot;Intel&quot;); NotePad notePad = new NotePad(); notePad.setColor(&quot;blue&quot;); notePad.setCpu(&quot;Intel&quot;); notePad.setRam(&quot;2GB&quot;); notePad.setHdd(&quot;1TB&quot;); notePad.Test(); &#125;&#125;class Computer &#123; private String cpu; private String ram; private String hdd; public String getCpu() &#123; return cpu; &#125; public void setCpu(String cpu) &#123; this.cpu = cpu; &#125; public String getRam() &#123; return ram; &#125; public void setRam(String ram) &#123; this.ram = ram; &#125; public String getHdd() &#123; return hdd; &#125; public void setHdd(String hdd) &#123; this.hdd = hdd; &#125; public String getDetails() &#123; return &quot;cpu:&quot; + cpu + &quot; ram:&quot; + ram + &quot; hdd:&quot; + hdd; &#125;&#125;class PC extends Computer &#123; private String brand; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125;&#125;class NotePad extends Computer &#123; String color; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void Test() &#123; System.out.println(&quot;cpu:&quot; + getCpu() + &quot; ram:&quot; + getRam() + &quot; hdd:&quot; + getHdd() + &quot; color:&quot; + color); &#125;&#125; spuer关键字 super 代表父类的引用，用于访问父类的属性、方法、构造器 super.xx; super.(参数列表); 不能访问私有的属性和方法 访问父类的构造器,只能放在第一句 super(参数列表); 细节 super找方法时: 本类-&gt;父类-&gt;父类的父类…直到object, 如果没有则报错 xx(); this.xx();&#x2F;&#x2F;等价与xx(); super.xx();&#x2F;&#x2F;直接查找父类,不看本类; super找属性时, 直接找父类-&gt;父类的父类… super访问构造器, 需要放在第一行 当子类中有和父类中同名的属性或方法时, 必须使用super访问. 如果没有重名,使用super,this,直接访问一样 super的访问不限与父类,如果爷爷类和本类中有同名的成员,也可以使用super去访问爷爷类的成员. 如果多个基类中都有同名的成员,遵循就近原则. super与this比较 方法重写&#x2F;覆盖 子类的方法和父类的某个方法完全一样,就表示子类的方法覆盖了父类方法 子类的返回类型和父类方法返回类型一样,或者是父类返回类型的子类, 比如父类的返回类型是Object, 子类方法返回类型是String public Objec t getInfo() &#123; return null;&#125;public String getInfo() &#123; return null;&#125;// String 和数组是Object子类的引用, 如果是基本数据类型就是重载而不是重写 子类方法不能缩小父类方法的访问权限 重载和重写 多态 多态意味着一个接口可以有多种实现方式，或者父类引用可以指向子类对象。这种特性使得代码更加灵活、可重用和易于维护 让父对象在运行时根据子对象的特性表现出不同的行为。 体现在: 方法的重载和重写; 对象转型：向上转型是指将子类的引用赋给父类引用变量，这是安全的；向下转型是指将父类引用转换为子类引用，这可能在运行时引发 3.接口实现:一个类可以实现多个接口，这意味着一个类可以有多种行为。 主人会给很多动物喂食, 动物多起来时代码管理和维护就会困难起来 方法的多态重写和重载就体现多态 对象的多态 一个对象的编译类型和运行类型可以不一致 Animal animal = new Dog();animal编译类型是Animal, 运行类型是Dog animal &#x3D; new Cat(); 编译类型在定义对象时就确定了,不能改变 运行类型是可以变化的 编译类型看定义时 &#x3D; 的左边, 运行类型右边 所以具体运行时执行的代码内容时运行类型中的. //main中package java_1.chapter_8.poly;public class main &#123; public static void main(String[] args) &#123; Master master = new Master(&quot;Tom&quot;); Bone bone = new Bone(&quot;bigBone&quot;); Dog dog = new Dog(&quot;jack&quot;); //dog和bone都是Animal and Food 的子类 master.feed(dog, bone); &#125;&#125;//类public void feed(Animal animal, Food food) &#123; System.out.println(name + &quot; feed &quot; + animal.getName() + &quot; eat&quot; + food.getName()); &#125;// public viod feed(Dog dog, Bone bone)) &#123;// System.out.println(name + &quot; feed &quot; + dog.getName() + &quot; eat&quot; + bone.getName());// &#125;// public viod feed(Cat cat, Fish fish)) &#123;// System.out.println(name + &quot; feed &quot; + cat.getName() + &quot; eat&quot; + fish.getName());// &#125; 对象的向上&#x2F;下转型 向上转型 本质 父类的引用指向了子类的对象(子类当父类用) Animal animal = new Dog(); animal是Animal的引用,指向了子类对象Dog 语法: 父类类型 引用名 &#x3D; new 子类类型(); animal 可以调用父类的所有成员(需要访问权限), 不能调用子类的成员, 因为在编译阶段能调用那些成员是由编译类型决定的. 编译由Javac完成 最终运行效果看子类的具体实现. 运行由Java完成, 即animal.xx();这个方法最终运行时会先看Dog中的方法, 再看Animal. 规则和this一样 如果觉得有一些不好记，就看它的起源，为什么需要它。比如，封装，继承，多态。。。核心就是减少代码，既然要减少是不是就要封装，那我总不能都封在一个类中啊，那就有了继承，继承多了，我怎么知道谁是老大，那就有了多态。。像自动拆箱，封箱，就是java设计者的弥补，他说了是一切皆对象 向下转型 ​\t语法: 子类类型 引用名 &#x3D; (子类类型) 父类引用; ​\tDog dog = (Dog) animal;&#x2F;&#x2F;在栈中创建一个新的Dog引用, 然后将原来Animal的引用指向这里. 只能强转父类的引用,不能转父类的对象 要求父类的引用必须指向的是当前目标类型的对象. animal 创建时指向的是Dog的对象. Cat cat &#x3D; (Cat) animal 不可以,因为animal创建时指向的是Dog类型, 即父类的引用必须指向的是当前目标类型的对象; 可以调用子类的所有成员 细节 多态的前提是继承 属性没有重写 class Base &#123; int count = 10;&#125;class Sub extends Base &#123; int count = 20;&#125;Base base = new Sub(); //父类的引用base指向子类的对象Sub();System.out.println(base.count); // 输出10. 属性没有重写 instanceOf 比较操作符, 判断对象的类型是否为xx类型或xx类型的子类型 属性看编译, 方法看运行 动态绑定!! 在Java中，动态绑定是运行时确定方法执行的技术。 当一个方法在子类中被重写时，如果一个父类引用指向一个子类对象并调用了这个方法，那么Java虚拟机（JVM）会在运行时根据对象的实际类型来选择正确的方法实现。这个过程就是动态绑定的过程。 简而言之，动态绑定就是运行时决定方法执行的技术。 当调用对象方法时,该方法会和该对象的内存地址&#x2F;运行类型绑定 当调用对象属性时,没有动态绑定机制,哪里声明,哪里使用 /*子类调用方法时,1. 该方法自己有, 用自己的2. 该方法没有, 用父类的3. 属性没有动态绑定, 在哪里就用那里的 */public class DynamicBinding &#123;public static void main(String[] args) &#123;//a 的编译类型 A, 运行类型 BA a = new B();//向上转型 //子类有getI,i就用当前的System.out.println(a.sum());//?40 -&gt; 30 //子类没有sum1,用父类的sum1, 而属性没有动态绑定, 就用当前父类的iSystem.out.println(a.sum1());//?30-&gt; 20&#125;&#125;class A &#123;//父类public int i = 10;//动态绑定机制:public int sum() &#123;//父类 sum()return getI();&#125;public int sum1() &#123;//父类 sum1()return i + 10;//10 + 10&#125;public int getI() &#123;//父类 getIreturn i;&#125;&#125;class B extends A &#123;//子类public int i = 20;// public int sum() &#123;// return i + 20;// &#125;public int getI() &#123;//子类 getI()return i;&#125;// public int sum1() &#123;// return i + 10;// &#125;&#125; 多态数组数组的定义类型为父类类型, 里面保存的实际元素类型是子类类型 数组类型为父类; 多态意味着调用成员方法时，会根据调用方法的对象的类型来执行不同的方法，即动态绑定。 public class PloyArray &#123;public static void main(String[] args) &#123;//应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、// 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法Person[] persons = new Person[5];persons[0] = new Person(&quot;jack&quot;, 20);persons[1] = new Student(&quot;mary&quot;, 18, 100);persons[2] = new Student(&quot;smith&quot;, 19, 30.1);persons[3] = new Teacher(&quot;scott&quot;, 30, 20000);persons[4] = new Teacher(&quot;king&quot;, 50, 25000); for (int i = 0; i &lt; persons.length; i++) &#123; //persons[i]编译类型是person,实际运行类型是根据实际情况由JVM来判断; persons[i].say; //动态绑定机制,对象不同,方法不同; &#125; if(person[i] instanceof Student) &#123; //判断personp[i]的运行类型是不是Student Student student = (Student)person[i].study(); //向下转型 &#125; else if (person[i] instanceof Teacher) &#123; Tercher teacher = (Teacher) person[i].teach(); &#125; &#125; 多态参数参数列表定义父类, 传值时使用子类, 达到多态的效果 package java_1.chapter_8.poly.employee;public class test &#123; public int showEmpAnnaul(Employee employee) &#123; return employee.getAnnual(); &#125; //多态参数 public void testWork(Employee employee) &#123; if (employee instanceof Worker) &#123; System.out.println( ((Worker) employee).work() ); &#125; &#125;&#125; Object类所有对象都可以调用 equals方法 &#x3D;&#x3D; 和equals的对比 &#x3D;&#x3D; 就可以判断基本类型, 也可以判断引用类型 如果判断基本类型, 判断值是否相等 如果引用类型, 地址是否相等 equals是Object类中的方法, 只能判断引用类型 默认判断地址, 子类中往往重写该方法, 用于判断内容是否相等 在没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;的效果一样，也是比较的是引用类型的变量所指向的对象的地址，不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。 String str1 = new String(&quot;asdf&quot;); String str2 = new String(&quot;asdf&quot;); str1 == str2 // false 地址不同 str1.equals(str2) // ture equals判断的是值 //Jdk 的源码 String 类的 equals//把 Object 的 equals 方法重写了,变成了比较两个字符串值是否相同public boolean equals(Object anObject) &#123; //this代表当前对象if (this == anObject) &#123; //如果是同一个对象return true;//返回 true&#125; if (anObject instanceof String) &#123;//判断类型String anotherString = (String)anObject;//向下转型, 以便可以使用anObject的属性.int n = value.length; if (n == anotherString.value.length) &#123;//如果长度相同char v1[] = value;char v2[] = anotherString.value;int i = 0;while (n-- != 0) &#123;//然后一个一个的比较字符if (v1[i] != v2[i])return false;i++&#125; return true;//如果两个字符串的所有字符都相等，则返回 true&#125;&#125;return false;//如果比较的不是字符串，则直接返回 false&#125; 重写equals, 用于判断person类是否相同, 如果属性值一样,则返回true public boolean equals(Object obj) &#123; //判单是否是同一个对象 if ( this == boj) &#123; return true; &#125; if (obj instanceof Person) &#123; Person p = (Person)obj; // 向下转向, 这样才能访问boj子类对象的属性 return this.name.equals(p.name); &#125; //前面都不满足, 说明不相等 return false;&#125; hashCodepublic int hashCode(); 语法: xx.hashCode(); 返回该对象的哈希码值 提高具有哈希结构的容器的效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ 两个引用，如果指向的是不同对象，则哈希值是不一样的 哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。 toString默认返回: 全类名 + @ + 哈希值的十六进制 全类名 &#x3D; 包名 + 类名 public String toString () &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;//重写,输出对象的属性 public String toString() &#123; return name + age + sex; &#125; 当直接输出一个对象时,toString方法会被默认的调用 子类往往重写toString方法, 用返回对象的属性信息 finalize 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作【演示】 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制， protected void finalize() throws Throwable &#123; ...&#125; 判错 调试状态中, 是运行状态, 对象以运行类型来执行 光标放在变量上可以查看当前数据 F7跳入方法体, shift + F8跳出方法体 F9进入下一个断点 可以用来排查错误, 打上两个断点后, 用F9检查能否顺利进入下一个断点 房屋出租","tags":["JavaSE"],"categories":["记录"]},{"title":"前端三大件项目--美食计划","path":"/2023/06/04/前端三大件-0-1/","content":"Intro在线预览 大一暑假做边学边做的一个前端项目, 主要是HTML 和 CSS 的使用, 虽然比较基础, 但现在回过头来看, 还是有不少东西值得复习. 当时记得是跟着一个油管上的博主做的, 除了基础的语法和属性讲解外, 还重点介绍了前端页面的性能优化和布局以及常用的美化原则, 当时跟下来收获还是很大的. 当时做的一些笔记比较零碎, 很多都找不到了, 代码也没有太多注释, 现在看上去有点蒙蔽……😭😭 后面随缘补充吧….. Float 输入lorem可以创建一段假文字； float的元素不会真正影响周围元素，脱离标准文档流； 依然能在周围创造空间 float后高度为零 添加一个clearfix的class Flex flex的一些基础属性 使用Flex gap后，调整间距时不必一个个寻找，只需要修改一次，类似C中的宏 伪类 伪类超链接：a:link {} 这样只会针对有链接的a标签 a:hover; a:visited; 只针对访问过的链接 a:active; CSS Grid 让CSS更易阅读 可以和Flex协同工作 一些CSS Grid的terminology Design 九个网页设计层面 七种常见的页面风格 Good TypeFaces 字体的选择 字体大小，12&#x2F;14&#x2F;16&#x2F;18&#x2F;20&#x2F;24&#x2F;32&#x2F;44&#x2F;52&#x2F;60 每行的文字数不超过70 文本越长，行间距越大。一般长文本为1.5 短标题使用大写 字间距，文字越大越小 一般不会对齐文本，小段文字可以向左&#x2F;右 Color 不同的颜色，不同的情绪 选择主色、灰色和辅色 不要大面积使用低对比度的文字，对于那些视力障碍的人来说 ImagesDifferent types of images Product Photos Storytelling Photos illustrations 插图 Patterns 高质量图片！！！ 适配高分辨率屏幕 压缩图片 The Website Personalities FramworkSerious&#x2F;Elegant 使用衬线字体 颜色通常呈现奢华 图片大，质量高 实验性质的，创造性的布局 Minimalist&#x2F;Simple ✨ 布局通常比较规整，并使用无衬线字体 没有阴影和边界 简单的颜色 Plain&#x2F;Neutral 颜色中性 图片使用较多 Bold&#x2F;Confident ✨ 大胆且自信 明亮的颜色 大尺寸图片 强对比，颜色，亮度。 Calm&#x2F;Peaceful ✨ 平静柔和的颜色 曲线 Startup&#x2F;Upbeat ✨ Playful&#x2F; Fun 未完待续…..","tags":["JavaScript","HTML","CSS"],"categories":["技术"]},{"title":"C语言 翁恺学习笔记","path":"/2023/02/17/C语言 翁恺笔记/","content":"两种循环 do-while循环和while循环很像，区别是在循环体执⾏结束的时候才来判断条件。也就是说，⽆论如何，循环都会执⾏⾄少⼀遍，然后再来判断条件。与while循环相同的是，条件满⾜时执⾏循环，条件不满⾜ 时结束循环 注意,在do-while循环中,do{循环体} while (条件); 循环计算 计算之前先保存原始的值,后面可能有用 int x;int ret = 0;scanf(&quot;%d&quot;, &amp;x);int t =x; 计数循环 int count =100;while (count &gt;=0)&#123; count --; // 对于一个变量进行减一的操作. printf(&quot;%d &quot;, count);&#125;printf(&quot;发射! &quot;); 循环应用猜数游戏#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123; srand(time(0)); int a = rand(); printf(&quot;%d &quot;, a);&#125; 随机数 每次召唤rand()就得到一个随机的整数 %100 x%n的结果是[0,n-1]的一个整数 计算平均数while (number != -1)&#123; sum += number; count ++; scanf(&quot;d&quot;, &amp;number); &#125;printf(&quot;%f&quot;, 1.0*sun/count);do&#123; scanf(&quot;%d&quot;, &amp;number); if (number != -1); &#123; sum += number; count ++; &#125; while (number != -1);&#125; 整数逆序int x;scanf(&quot;%d&quot;, &amp;x);int digit;int ret =0;while(x &gt;0) digit =x%10; printf(&quot;%d&quot;, digit); ret =ret*10 + digit; x /=10;&#125;pritnf(&quot;%d&quot;, ret); 第五周 思想第三种循环for循环for循环像一个计数循环:设定一个计数器,初始化它,然后在计数器到达某值之前,重复执行循环体,而每执行一轮循环,计数器值以一定步骤进行调整,比如加1或减1. for(i&#x3D;0; i&lt;5; i&#x3D;i+1){ printf(“%d”, i);} for&#x3D;对于 for(count&#x3D;10; count&gt;0; count–) 可以读成:”对于的一开始的count&#x3D;10,当count&gt;0时,重复做循环体,每一轮循环在做完循环体内语句后,使得count–.” 小套路 做求和的程序时,记录结果的变量应该初始化为0,而做求积变量时,记录结果的变量应该初始化为1. for and while for(int i =1; i&lt;=n; i++)&#123;\tfact *=i;&#125;int i =1;while(i&lt;=n)&#123; fact *=i; i++;&#125; for循环 for(初始动作;条件;每轮的动作){} for中每一个表达式都是可以省略的 Tips for loops 如果有固定次数,用for; 如果必须执行一次,用do_while; 其他情况用while; 循环控制循环控制break vs continue break; 跳出循环 continue; 跳过循环这一轮剩下的语句进入下一轮; 嵌套的循环100以内的素数x cut x =2;int cut =0;while(cut &lt;50)&#123; int i; int isPrime =1; for(int i =2; i &lt;x; i++) if(x %i==0) &#123; isPrime =0; break; &#125; cut++;&#125;if(isPrime =1)&#123; pirntf(&quot;%d/t&quot;, x);\tif(cut &gt;5) &#123; printf(&quot; &quot;); &#125; &#125; 嵌套循环时的break凑硬币例子 如何用1角,2角和5角的硬币凑出10元以内的金额呢? int x;int one, two, five;scanf(&quot;%d&quot;, x);for (one =1; one &lt;x*10; one ++)&#123; for (two =1; two &lt; x*10/2; two ++) &#123; for (five =1; five &lt; x*10/5; five ++) &#123; if (one + two + five == x*10) &#123; printf(&quot;可以用%d个1角加%d个2角加%d个5角得到%d元 &quot;, one, two, five, x); &#125; &#125; &#125;&#125; break和continue 只对它所在的哪层循环做 接力breakint x;int one, two, five;int exit =0;scanf(&quot;%d&quot;, x);for (one =1; one &lt;x*10; one ++)&#123; for (two =1; two &lt; x*10/2; two ++) &#123; for (five =1; five &lt; x*10/5; five ++) &#123; if (one + two + five == x*10) &#123; printf(&quot;可以用%d个1角加%d个2角加%d个5角得到%d元 &quot;, one, two, five, x); exit =1; break; &#125; &#125; if (exit ==1) break; &#125; if (exit ==1) break;&#125; gotoint x;int one, two, five;scanf(&quot;%d&quot;, x);for (one =1; one &lt;x*10; one ++)&#123; for (two =1; two &lt; x*10/2; two ++) &#123; for (five =1; five &lt; x*10/5; five ++) &#123; if (one + two*2 + five*5 == x*10) &#123; printf(&quot;可以用%d个1角加%d个2角加%d个5角得到%d元 &quot;, one, two, five, x); goto out; &#125; &#125; &#125;&#125;out; goto语句可以指定到任意位置 循环应用求和改变符号，在求和中给出了两种 int sign &#x3D;1;sum +&#x3D;sign*sum;sign&#x3D;-sign; double sign&#x3D;1.0;sum &#x3D;sign&#x2F;i;sign &#x3D;-sign; 分解整数 输入一个非负整数，正序输出它的每一位数字 1int x;sacnf(&quot;%d, &amp;x&quot;);do&#123; int d =x%10; printf(&quot;%d&quot;, d); x /=10；&#125; while (x &gt;0); 做到了倒叙输出，但是没有空格。在解决空格问题的时候，可以添加if语句。 2int x;sacnf(&quot;%d, &amp;x&quot;);do&#123; int d =x%10; printf(&quot;%d&quot;, d); if (x&gt;9) printf(&quot; &quot;); x /=10;&#125; while (x &gt;0); 利用if判断解决了空格的问题，但是输出结果依然是逆序的。 3int x;sacnf(&quot;%d, &amp;x&quot;);x = 12345;int mask =10000;do&#123; int d =x/mask; printf(&quot;%d&quot;, d); if (x&gt;9) &#123; printf(&quot; &quot;); &#125; x %=mask; mask /=10;&#125; while (x &gt;0); 首先x除以mask，得到了最高位数字，然后X再以10000取余，得到去除最高位的2345，再将mask降低以为，循环即可得到正序结果。但是这样处理只能计算五位数，如果计算X的位数？ 4x =12345;int mask =10000;int n =0;do&#123;\tx /=10;\tn++;&#125; while (x&gt;0);printf(&quot;n=%d/n&quot;, n); 根据输入的X来输出对应的位数？ 5x =12345;int mask =1;do&#123;\tx /=10;\tmask *=10; &#125; while (x&gt;9);printf(&quot;%d &quot;, mask); 如果是X&gt;0，会多输出一个0。 6如果输出的x是1，那么得到的mask是10 ，因为do-while循环无论怎样，都会先做一轮循环，所以这里应该要用while循环。 int x;sacnf(&quot;%d&quot;, &amp;x);int mask =1;int t =x;while (t&gt;9)&#123;\tt /=10;\tmask *=10;\t&#125;do&#123;\tint d =x/mask;\tprintf(&quot;%d&quot;, d);\tif (x&gt;9)\t&#123; printf(&quot; &quot;);\t&#125;\tx %=mask;\tmask /=10;&#125; while (mask&gt;0);printf(&quot; &quot;); 求最大公约数枚举int a,b;int min;scanf(&quot;%d %d&quot;, &amp;a, &amp;b);if (a&gt;b)&#123;\tmin =b;&#125; else\t&#123; min =a;\t&#125;int ret =0;int i;for (i=1; i&lt;min; i++);&#123; if (a%i ==0) if (b%i ==0) ret =i; &#125;printf(&quot;%d和%d的最大公约数是%d&quot;, a, b, ret); 辗转相除法 如果B等于0，计算结束，A就是最大公约数； 否则，计算A除以B的余数，让A等于B，而B等于那个余数； 回到第一步。 int a,b;scanf(&quot;%d %d&quot;, &amp;a, &amp;b);int t;int origa =a;int origb =b;while (b !=0)&#123; t =a%b; a =b; b =t;&#125;pirntf(&quot;%d和%d的最大公约数就是%d&quot;, origa, origb, a); 第六周 数据类型数据类型基础数据类型类型安全 支持强类型的观点认为明确的类型有助于今早发现程序中的简单错误 反对强类型的观点认为过于强调类型迫使程序员面对底层、实现而非事务逻辑。 总的来说，早期语言强调类型，面向底层的语言强调类型 C语言需要类型，但是对类型的安全检查并不足够 C语言的类型 整数 char, short, int, long, long long 浮点数 float, double, long double 逻辑 bool 指针 自定义类型 类型的不同 名称 输入输出时格式化 表达数的范围 内存中所占据的大小 int就是用来表达寄存器的 内存中的表达形式：二进制数、编码 sizeof 是一个运算符，给出某个类型或变量在内存中所占据的字节数 sizeof(int) sizeof(i) 整数的内部表达如何表达负数 一个字节可以表达的数： 00000000–11111111（0-255） 三种方案 仿照十进制，有一个特殊的标志表示负数 取中间的数为0，如10000000表示0，比他小的是负数，大的是正数。 补码 是用补码 考虑-1，我们希望-1+1-&gt;0。什么东西加上1会是0？** 0 -&gt; 00000000 1 -&gt; 00000001 11111111 + 00000001 –&gt; 100000000 因为0 - 1 –&gt; - 1，所以 (1)00000000 - 00000001 –&gt; 1111 1111 &#x2F;&#x2F;计算机内部是8个bit，多出的那个1会被丢掉 11111111二进制为255，做补码时为-1 同理，对于-a，其补码就是0 - a，实际是2^n ( (1)00000000 ) - a，n是这种类型的位数。 补码的意义就是拿补码和原码可以加出一个溢出的”零“。 数的范围 char: 1字节：-128~127 short: 2字节：-32768~32767 int: 取决于编译器（CPU），通常的意义是“一个字” long: 4字节 long long :8字节 char c = 255;int i = 255;printf(&quot;c=%d, i=%d&quot;, c, i); unsigned 如果一个字面量常熟想要表达自己是unsigned，可以在后面加u unsigned的设计初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位 整数越界 整数是以纯二进制的方式进行计算的，所以： 11111111 + 1 -&gt; 100000000 -&gt; 0 01111111 + 1 -&gt; 100000000 -&gt; -128 10000000 - 1 -&gt; 01111111 -&gt; 127 127 + 1 &#x3D; -128 -128 - 1 &#x3D; 127 对于U来说255 + 1 &#x3D; 0 0 - 1 &#x3D; 255 unsigned int a=0;printf(&quot;int数据类型最大数是:%u &quot;,a-1);//直接减一，将%d改为%u。 整数的格式化8进制和16进制 o开始为8，ox开始为16 %o用于8进制，%ox用于16进制 8进制和16进制只是如何把数字表达为字符串，于内部如何表达数字无关 浮点类型范围 有效数字float和double都不能表示接近0附近的数，只是double的这个范围更加小而已。 float是7位有效数字32字长，而double是15位64字长 如果将%f换成%e，输出结果将以科学计数法表示，e和E效果相同。 输出精度 在%和f之间加上.n可以指定输出小数点后几位，这样的输出是做四舍五入的 printf(“%.3f ”, -0.0049); printf(“%.30f ”, -0.0049); -0.005 ，49后面并不是0，数学上来说所有数是连续的；计算机来说，最终是离散的表达（普朗克长度），只是double比float更加精确。即计算机无法精确表达小数。 浮点数到底能表示那些数？ printf输出infi表示超过范围的浮点数：正负无穷 printf输出nan表示不存在的浮点数 浮点运算的精度 float a, b, c;a = 1.345f;b = 1.234f;c = a + b;if (c == 2.468)\tprintf(&quot;相等 &quot;)；else printf(&quot;不想等！c = %.10f,或%f &quot;， c,c); 注意 带小数点的字面量是double而非float float需要用f或者F后缀来表明身份 f1 &#x3D;&#x3D; f2可能失败 fabs(f1 - f2) &lt; 1e-12 &#x3D;&#x3D; 1.0X10^-12（因为float的精度小于1e-12） 字符字符类型 char是一种个整数，也是一种特殊的类型：字符。 用单引号表示的字符字面量：‘a’, ‘1’ ‘ ‘也是一个字符 printf和scanf里用%c来输入输出字符 混合输入 有何不同？ scanf(“%d %c”, &amp;i, &amp;c); scanf(“%d%c”, &amp;i, &amp;c); 有空格时读完一个整数还要把后面的也读完，没有空格时读完一个整数就结束了 字符计算 一个字符加一个数字得到ASCII码表中那个数之后的字符 两个字符相减，得到他们在表中的距离 大小写转换 字幕在ASCII表中是顺序排列的 大写字母和小写字母是分开排列的，并不在一起 ’a’ - ‘A’可以得到两段之间的距离，于是 a + ‘a’ - ‘A’可以把一个大写字母变成小写字母，而 a + ‘A’ - ‘a’可以把一个小写字母变成大写字母 逃逸字符 用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“\\”开头，后面跟上另一个字符，这连个字符合起来，组成了一个字符 比如printf(“如输入\\”“5 7\\“ 表示5英尺7英寸：”)； 字符 意义 字符 意义 \\b 回退一格 \\ “ 双引号 \\t 到下一个表格位 \\ ‘ 单引号 换行 \\ \\ 反斜杠本身 \\r 回车 制表格 每行的固定位置 一个\\t使得输出从下一个制表位开始 用\\t才能使得上下两行对齐 类型转化自动类型转换 当运算符两边出现不一致的类型时，会自动转换较大的类型 对于printf，任何小于int的类型都会转化成int；float会被转换成double 但是scanf不会，要输入short，需要%hd 强制类型转换 (类型)值 (int)10.3 (short)32 只是从那个变量计算出了一个新的类型值，它并不改变那个变量，无论是值还是类型都不会改变 小的变量不能表达大的变量 (short)32768 强制类型转换的优先级高于四则运算 逻辑类型逻辑运算 逻辑运算是对逻辑量进行的运算结果只有0 or 1 逻辑量是关系运算或逻辑运算的结果 栗子 如何判断一个字符c是否是大写字母？ c &gt;&#x3D; ‘A’ &amp;&amp; c &lt;&#x3D;‘Z’ 优先级if (gameover == 0)&#123;\tif (p;ayer2move == 2)\t&#123; printf(&quot;Your turn &quot;);\t&#125;&#125;if (gameover == 0 &amp;&amp; playermove == 2)&#123;\tprintf(&quot;Your turn&quot;);&#125; 短路 逻辑运算是自左向右进行的，如果左边结果已经能够决定结果了，就不会做右边的计算 a &#x3D;&#x3D; 6 &amp;&amp; b &#x3D;&#x3D; 1 a &#x3D;&#x3D; 6 &amp;&amp; b+&#x3D;1 对于&amp;&amp;，左边是false时就不做右边了 对于||，左边时true时就不做右边了 条件运算条件运算符 count &#x3D; (count &gt; 20 ) ? count -10 : count +10; 条件、条件满足时的值和条件不满足时的值 自右向左结合，把所有的分支部分都算明白，再去判断。 if (count &gt; 20)&#123;\tcount = count -10;&#125; else &#123; count = count + 10;&#125; 优先级 条件运算符的优先级高于赋值运算符，但是低于其他运算符 嵌套套件表达式 count &#x3D; ( count &gt; 20 ) ? （count &lt; 50）? count - 10 : count -5 : (count &lt; 10) ? count +10 : count +5;???? 谭浩强直呼内行 逗号运算 逗号⽤来连接两个表达式，并以其右边的 表达式的值作为它的结果。 逗号的优先级 是所有的运算符中最低的，所以它两边的 表达式会先计算； 逗号的组合关系是⾃左 向右，所以左边的表达式会先计算，⽽右 边的表达式的值就留下来作为逗号运算的结果。 在for 中使用 for (i &#x3D; 0, j &#x3D; 10; i &lt; j; i++, j–) 第七周 函数函数的定义和使用素数求和 代码复制是程序质量不良的表现 void sum(int begin, int end)&#123; int i; int sum = 0; for (i = begin; i&lt;=end; i++) &#123; sum += i; &#125; printf(&quot;%d到%d&quot;的和是%d &quot;, begin, end, sum);&#125;int main()&#123; sum(1,10); sum(20,30); sum(35,45); return 0;&#125; 调用函数 函数名（参数值） （）起到了表示函数调用的作用 即使没有参数也需要（） 如果由参数，则需要给出正确的数量和顺序 这些值会按照顺序依次用来初始化函数中的参数 从函数中返回从函数中返回值int max(int a, int b)&#123; int ret; if (a&gt;b) &#123; ret =a; &#125; else &#123; ret =b; &#125; return ret;&#125; return停止函数的执行，并送回一个值 return; return表达式 一个函数里可以出现多个return语句 int max(int a, int b)&#123; int ret; if (a &gt; b) &#123; ret = a; &#125; else &#123; ret =b; &#125;&#125;int main()&#123; int a, b, c; a =5; b =6; c =max(10, 12); c =max(a, b); c =max(c, 23); printf(&quot;%d &quot;, max(a, b)); return 0;&#125; 可以赋值给变量 可以再传递给函数 甚至可以丢弃 有时候要的是副作用 没有返回值的函数 void 函数名 不能使用带值得return 可以没有return 调用得时候不能做返回得赋值 如果函数有返回值，则必须使用带值得return 函数的参数和变量函数原型 函数先后关系，C的编译器会自上而下顺序分析你的代码 如果不知道，旧标准会假设所调用的函数所有参数是int，返回的也是int void sum(int begin, int end); // 声明int main()&#123; sum(1,10); // int sum(int, int) sum(20,30); sum(35,45); return 0;&#125;void sum(int begin, int end) // 定义&#123; int i; int sum = 0; for (i = begin; i&lt;=end; i++) &#123; sum += i; &#125; printf(&quot;%d到%d&quot;的和是%d &quot;, begin, end, sum);&#125; 函数头，以分号“;”结尾，就构成了函数的原型 函数原型的目的是告诉编译器这个函数⻓什么样 名称 参数（数量及类型） 返回类型 旧标准习惯把函数原型写在调⽤它的函数⾥⾯ 现在⼀般写在调⽤它的函数前⾯ 原型⾥可以不写参数的名字，但是⼀般仍然写上，方便读者 参数传递调用函数 如果函数有参数，调用该函数时必须传递给它数量、类型正确的值 可以传递给函数的值是表达式的值，这包括： 字面量 变量 函数的返回值 计算的结果 类型不匹配 编译器会悄悄地替你把类型转好，但这很可能不是你想要的结果 传过去的是什么？#include &lt;stdio.h&gt;void swap(int a, int b);int main()&#123; int a =5; int b =6; swap(a, b); printf(&quot;a =%d b =%d&quot;, a, b); return 0;&#125;void swap(int a, int b)&#123; int t = a; a = b; b = t;&#125; c只能传值给函数 传值 每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系 过去，对于函数参数表中的参数，叫做“形式参数”，调用函数时给的值，叫做“实际参数” 这样会误会实际参数就是实际在函数中进行计算的参数， 误会调用函数的时候把变量而不是值传进去。 本地变量 函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量 定义在函数内部的变量就是本地变量 参数也是本地变量 变量的生存期和作用域 生存期：什么时候这个变量开始出现了，到什么时候它消亡了 作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用） 对于本地变量，这两个问题的答案是唯一的：大括号内——块 本地变量的规则 本地变量是定义在块内的 它可以是定义在函数的块内 也可以定义在语句的块内 甚至可以随便拉一对大括号来定义变量 程序运行进入这个块内，其中的变量不存在，离开这个块，其中的变量就消失了 块外面定义的变量在里面仍然有效 块里面定义了和外面同名的变量则掩盖了外面的 不能在一个块内定义同名的变量 本地变量不会被默认初始化 参数在进入函数的时候被初始化了 函数庶事没有参数时 void f(void); 还是 void f(); 在传统的C中，他表示f函数的参数表未知，并不表示没有参数 逗号运算符？ 调用函数时的逗号和逗号运算符怎么区分？ 调用函数时的圆括号里的逗号时标点符号，不是运算符 f(a,b) f((a,b)) 函数里的函数？ C语言不允许函数嵌套定义 这是？？ int i, j, sum(int a, int b); return (i); 关于main int main()也是一个函数 要不要写int mian(void)? retur 0有人看？ Windows：if errorlevel 1…le 第八周 数组数组初识数组 如何写一个程序计算用户输入的数字的平均数，并输出所有大于平均数的数？ 必须先记录每一个输入的数字，计算平均数后，再检查记录下来的每一个数字，于平均数相比，决定是否输出 当然，我们不想这样&#96;int num1, num2, num3, num5, … 数组int number[100]; scanf(“%d”, number[i]); int main()&#123; int x; double sum = 0; int cnt = 0; int number[50]; // 定义数组 scanf(&quot;%d&quot;, &amp;x); while (x != -1) &#123; number[cnt] = x; // 对数组中的元素赋值 &#123; int i; printf(&quot;%d\\t&quot;, cnt); for (i = 0; i &lt;= cnt; i++) &#123; printf(&quot;%d\\t&quot;, number[i]); &#125; printf(&quot; &quot;); &#125; sum += x; cnt ++; scanf(&quot;%d&quot;, &amp;x); &#125; if ( cnt &gt; 0) &#123; printf(&quot;%f &quot;, sum/cnt); int i; for (i =0; i &lt; cnt; i++) &#123; if (number[i] &gt; sum/cnt) // 使用数组中的元素 &#123; printf(&quot;%d &quot;, number[i]); // 遍历数组 &#125; &#125; &#125; return 0;&#125; 数组的定义和使用定义数组 &lt;类型&gt; 变量名称[元素数量]； int grades[100]; double weight[20]; 元素数量必须是整数； C99之前：元素数量必须是编译时刻定义的字面量 数组 数组是一种容器（放东西的地方），特点是： 其中所有的元素具有相同的类型 一旦创建，不能改变大小 *（数组中的元素在内存中是连续依次排列的） int a[10] 一个int的数组； 10个单元 每个单元就是一个int类型的变量 可以出现在赋值的左边或者右边 a[2] &#x3D; a[1] + 6; *在赋值左边的叫左值 数组的单元 数组的每个单元就是数组类型的一个变量 使用数组时放在[]的数字叫做索引，索引从0开始计算，也就是定义个10，实际只能使用9个。（程序员从0开始数数） 有效的下标范围 编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写 一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃 segmentation fault 也可能运气好，没造成严重后果 所以我们要保证程序只是使用有效的下标:[0，数组的大小-1] 计算平均数 如果让用户先输入有多少个数字要计算，可以使用C99的新功能 int x;double sum = 0;int cnt;printf(&quot;请输入数字的数量：&quot;);scanf(&quot;%d&quot;, &amp;cnt);if (cnt &gt; 0)&#123; int number[cnt]; scanf(&quot;%d&quot;, &amp;x); while (x != -1) &#123; number[cnt] = x; sum += x; cnt++; scanf(&quot;%d&quot;, &amp;x); &#125;&#125; 输入0到9以内的数字，统计每个数字出现了多少次 const int number = 10; // 数组的大小int x;int count[number]; // 定义数组int i;for (i = 0; i &lt; number; i++) // 初始化数组&#123; count[i] = 0; &#125;scanf(&quot;%d&quot;, &amp;x);while (x != -1)&#123; if (x &gt;= 0 &amp;&amp; x &lt;= 9) &#123; count[x] ++; // 数组参与运算 printf(&quot;%d\\t&quot;, count[x]); &#125; scanf(&quot;%d&quot;, &amp;x);&#125;for (i = 0; i &lt; number; i++)&#123; printf(&quot;%d:%d &quot;, i, count[i]); // 遍历数组输出&#125; 数组的运算搜索#include &lt;stdio.h&gt;/*找出key在数组a中的位置@param key need to find number@param a need to find array@param length array &quot;a&quot; of length@return if find, return local of &quot;a&quot;; if not find, reutn &quot;-1&quot;.*/int search(int key, int a[], int length);int main()&#123; int a[] = &#123;2, 4, 6, 7, 1, 3, 5, 9, 11, 13, 24, 33, 45&#125;; int x; int loc; printf(&quot;请输入一个数字：&quot;);\tscanf(&quot;%d&quot;, &amp;x); loc = search(x, a, sizeof(a)/sizeof(a[0])); if (loc != -1) &#123; printf(&quot;%d在第%d个位置上 &quot;, x, loc); &#125; else &#123; printf(&quot;%d不存在 &quot;, x); &#125; return 0;&#125;int search (int key, int a[], int length)&#123; int ret = -1; int i; for (int i = 0; i &lt; length; i++) &#123; if (a[i] == key) &#123; ret = i; break; &#125; &#125; return ret;&#125; 数组的集成初始化int a[] = &#123;2, 23, 53, 53, 3, 33, 22, &#125;; 直接用大括号给出数组的所有元素的初始值 不需要给出数组的大小，编译器会自己数 如果给出了数组的大小，但是后面的初始值数量不足，则其后的元素被初始化为0 集成初始化时的定位int a[10] = &#123;[0] = 2, [2] = 3, 5,&#125;; 用[n]在初始化的数据中给出定位 没有定位的数据接在前面的位置后面 其他位置的值补零 也可以不给出数组的大小，让编译器算 特别适合初始数据稀疏的数组 数组的大小 sizeof 给出整个数组所占据的内容的大小，单位是字节 ​\tsizeof(a)/sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小 这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码** 数组的赋值int a[] = &#123;2, 5, 3, 5, 7, 9, &#125;; int b[] = a 数组变量本身不能被赋值 要把一个数组的所有元素交给另一个数组，必须采用遍历 遍历数组 通常都是使用for循环，让循环变量i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标 常见的错误是： 循环结束的条件&lt;&#x3D;数组长度，或： 离开循环后，继续用i的值来做数组元素的下标 素数判断素数从2到x-1测试是否可以整除 int isPrime(int x)&#123; int ret = 1; int i; if (x == 1) ret = 0; for (i = 2; i &lt; x; i++) &#123; if (x % i == 0) &#123; ret = 0; break; &#125; &#125; return ret;&#125; 对于n要循环n-1遍 当n很大时就是n遍 去掉偶数后，从3到x-1，每次加2 int isPrime(int x)&#123; int ret = 1; int i; if (x == 1 || (x % 2 ==0 &amp;&amp; x !=2) ) ret = 0; for (i = 3; i &lt; x; i += 2) &#123; if (x % i == 0) &#123; ret = 0; break; &#125; &#125; return ret;&#125; 如果x是偶数，立刻 否则要循环(n-3)&#x2F;2+1遍 A当n很大时就是n&#x2F;2遍 无须到x-1，到sqrt(x)就够了 int isPrime(int x)&#123; int ret = 1; int i; if (x == 1 || (x % 2==0 &amp;&amp; x!= 2)) ret = 0; for (i = 3; i &lt; sqrt(x); i +=2) &#123; if (x % i == 0) &#123; ret = 0; break; &#125; &#125; return ret;&#125; 只需要循环sqrt(x)遍 判断是否能被已知的且&lt;x的素数整除 构造素数表 欲构造n以内的素数表 令x为2 将2x、3x、4x、直至ax &lt;n的数标记为非素数 令x为下一个没有被标记为素数的数，重复2；直到所有的数都已经尝试完毕 伪代码 欲构造n以内（不含）的素数表 开辟prime[n],初始化其所有元素为1，prime[x]1表示x是素数 令x&#x3D;2 如果x是素数，则对于（i&#x3D;2; x*i&lt;n; i++)令prime[i * x]&#x3D;0 令x++,如果x&lt;n,重复3，否则结束 #include &lt;stdio.h&gt;int main()&#123; const int maxnumber = 25; int isPrime[maxnumber]; int i; int x; for (i =0; i &lt; maxnumber; i++) &#123; isPrime[i] =1; &#125; &#123; printf(&quot;\\t&quot;); for ( i =2; i &lt;maxnumber; i++); &#123; printf(&quot;%d\\t&quot;, i); &#125; printf(&quot; &quot;); &#125; for (x =2; x &lt; maxnumber; x++) &#123; if (isPrime[x]) &#123; for (i =2; i*x &lt; maxnumber; i++) &#123; isPrime[i*x] =0; &#125; &#125; printf(&quot;%d\\t&quot;, x); for (i =2; i &lt;maxnumber; i++) &#123; printf(&quot;%d\\t&quot;, isPrime[i]); printf(&quot; &quot;); &#125; &#125; for (i =2; i &lt; maxnumber; i++) &#123; if (isPrime[i]) &#123; printf(&quot;%d\\t&quot;, i); &#125; &#125; printf(&quot; &quot;); return 0;&#125; 二维数组 int a[3] [5] 通常理解为a是一个三行五列的矩阵 二维数组的遍历for (i =0; i &lt; 3; i++)&#123; for (j = 0; j &lt; 5; j++) &#123; a[i][j] = i*j; // 二维数组的赋值方式 &#125;&#125; a[i] [j]是一个int; 表示第i行第j列上的单元 a[i,j]??? 二维数组的初始化int a[] [5] = &#123; &#123;0, 1, 2, 3, 4,&#125;, &#123;2, 3, 4, 5, 6,&#125;,&#125;; 列数是必须给出的，行数可以有编译器来求 每行一个{}，逗号分隔 如果省略，表示补零 也可以用定位 井字棋游戏 读入一个3X3的矩阵，矩阵中的数字为1表示该位置上有一个X，为0表示为O 程序判断这个矩阵中是否有获胜的一方，输出表示获胜一方的字符X或O，或者无人获胜 读入矩阵 const int size = 3;int borad[size] [size];int i, j;int num0fX, num0fO;int result = -1; // -1没人赢//读入矩阵for (i = 0; i &lt; size; i++)&#123; for (j =0; j &lt; size; j++) &#123; scanf(&quot;%d&quot;, &amp;borad[i] [j]); &#125;&#125;0 1 2 0 1 2 0 检查行 for (i =0; i &lt; size &amp;&amp; result == -1; i++)&#123; num0fO = num0fX = 0; for (j = 0; j &lt; size; j++) &#123; if (board[i] [j] == 1) &#123; num0fX ++; &#125; else &#123; num0fO ++; &#125; &#125; if (num0fO == size) &#123; result = 1; &#125; else if (num0fX == size) &#123; result = 0; &#125;&#125; 检查列 for (j =0; j &lt;size &amp;&amp; result == -1; j++)&#123; num0fX = num0fX = 0; for (i = 0; i &lt; siez; i++) &#123; if (borad[i] [j] ==1) &#123; num0fX ++; &#125; else &#123; num0fO ++; &#125; &#125; if (num0fO == size) &#123; result = 1; &#125; else if &#123; result = 0; &#125;&#125; 检查对角线 num0fO = num0fX = 0; 00 01 02 10 11 12 20 21 22 for (i = 0; i &lt; size; i++) &#123; if (borad[i] [i] == 1) &#123; num0fX ++; &#125; else &#123; num0fO ++; &#125; &#125;\tfor (i = 0; i &lt; size; i++) &#123; if (borad[i] [size =i =1] == 1) &#123; num0fX ++; &#125; else &#123; num0fO ++; &#125; &#125; 第九周 指针指针取地址运算运算符&amp; scanf(“%d”, &amp;i);里的&amp; 获得变量的地址，它的操作数必须是变量 int i; printf(“%x”, &amp;x); 地址的大小是否与int相同取决于编译器 int i; printf(“%p”, &amp;i); &amp;不能取得地址 &amp;不能对没有地址的东西取地址 &amp;(a+b)? &amp;(a++)? &amp;(++a)? 试试这些&amp; 变量的地址 相邻的变量的地址 &amp;的结果的sizeof 数组的地址 数组单元的地址 相邻的数组单元的地址 #include&lt;stdio.h&gt;int main()&#123; int a[10]; int p; printf(&quot;%p &quot;, &amp;a); printf(&quot;%p &quot;, a); printf(&quot;%p &quot;, a[0]); printf(&quot;%p &quot;, a[3]); return 0;&#125; 什么是指针想想scanf 如果能够将取得的变量的地址传递给一个函数，能否通过这个地址在那个函数内访问这个变量？ scanf(“%d”, &amp;i); scanf()的原型应该是怎样的？我们需要一个参数能保存别的变量的地址，如果表达能够保存地址的变量？ 计算机的所有东西都是人做出来的，别人能想的出来的，我也能想的出来。在计算机里，没有任何黑魔法，所有的东西只是现在不知道，总会搞明白一切。 就是指针 Point 就是保存地址的变量 int i;int* p = &amp;i;int* p, q; int *p, q; 三四行的意思一样，都是表示p是一个指针，而不是p,q都是，四的写法更加好看。 指针变量 变量的值是内存的地址 普通变量的值是实际的值； 指针变量的值是具有实际值的变量的地址 作为参数的指针 void f(int *p); 在被调用时得到了某个变量的地址； int i &#x3D; 0; f(&amp;i); 在函数里面可以通过这个指针访问外面的这个i 访问那个地址上的变量* 解引用符号 *是一个单目运算符，用来访问指针所表示的地址上的变量 可以作为右值，也可以作为左值 int k &#x3D; *p; *p &#x3D; k + 1; 左值 出现在赋值号左边的不是变量，而是值，是表达式的计算结果 指针的运算符&amp; * 互相反作用 *&amp;yptr -&gt; * (&amp;yptr) -&gt; * (yptr的地址) -&gt; 得到那个地址上的变量 -&gt; yptr 传入地址 int i; scanf(&quot;%d&quot;, i); 为什么没有报错？ 指针的应用场景交换两个变量的值 void swap（int *p, int *q)&#123; int t = *p; *p = *q; *q = t;&#125; 通过指针在函数中返回多个值 函数返回多个值，某些值就只能通过指针返回 传入的参数实际上是需要保存带回的结果的变量 函数返回运算的状态，结果通过指针返回 常用的套路是让函数返回特殊的不属于有效范围的值来表示出错 -1或0 但是当任何数值都是有效的可能结果时，就得分开返回了？？？ 指针常见的错误 定义了指针变量，还没有指向任何变量，就开始使用指针 int *p;int k;k = 12;*p = k;int *q = 0;int j; j = 5;*q = j; 指针与数组 函数参数表中的数组实际上就是指针 sizeof(a) &#x3D;&#x3D; sizeof(int *) 但是可以用数组的运算符[]进行运算 void minmax(int a[], int len, int *max, int *min);int main()&#123; int a[] = &#123;1,2,4,5,6,55,54,7,9,0,66,52,77,&#125;; int min, max; printf(&quot;main sizeof(a)=%lu &quot;, a); printf(&quot;main a=%p &quot;, a); minmax(a, sizeof(a) / sizeof(a[0]), &amp;max, &amp;min); printf(&quot;min=%d,max=%d &quot;, min, max); return 0;&#125;void minmax(int a[], int len, int *max, int *min)&#123; int i; printf(&quot;minmax sizeof(a)=%lu &quot;, a); printf(&quot;minmax a=%p &quot;, a); *min = *max = a[0]; *max = 1777; for (i = 1; i &lt; len; i++) &#123; if (a[i] &gt; *max) &#123; *max = a[i]; &#125; if (a[i] &lt; *min) &#123; *min = a[i]; &#125; &#125;&#125; 数组参数 一下四种函数原型是等价的 int sum(int *ar , int n); int sum(int *, int); int sum(int [], int n); int sum(int [], int); 数组变量是特殊的指针 数组变量本身表达地址，所以 int a[10]; int *p &#x3D; a; &#x2F;&#x2F; 无需取地址符 但是数组的单元表达的是变量，需要用&amp;取地址 a &#x3D;&#x3D; &amp;a[0] []运算符可以对数组做，也可以对指针做： p[0] (所指位置上的值取出来，作为指针的值) &lt;&#x3D;&#x3D;&gt; a[0] *运算符可以可以对指针做，也可以对数组做： *a &#x3D; 23; 数组变量是被const的指针，所以不能被赋值 int a[] &lt;&#x3D;&#x3D;&gt; int *const a &#x3D;… 指针与const1.指针是const 表示一旦得到了某个变量的地址，不能再指向其他变量(地址不能再变） int * const q = &amp;i; //，定义了一个const的指针q *q &#x3D; 26; &#x2F;&#x2F;OK，可以修改它所指向的值，但是只能指向初始化时设置的地址 q++; &#x2F;&#x2F;ERROR 2.所指是cosnt 表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const） const int *p &#x3D; &i; *p &#x3D; 26; &#x2F;&#x2F; ERROR! ( * p)是const i &#x3D; 26; &#x2F;&#x2F;OK p &#x3D; &j; &#x2F;&#x2F;OK 不同的表示： int i;const int * p1 &#x3D; &i;int const * p2 &#x3D; &i;int * const p3 &#x3D; &i; 判断那个被const了的标志是cosnt在*的前面还是后面。 转换 总是可以把一个非const的值转换成cosnt的 void f(cosnt int* x);int a = 15;f(&amp;a); // OKconst int b = a;f(&amp;b); //OKb = a + 1; // ERROR 当要传递的参数的类型比地址大的时候，这是常用的手段；既能用比较少的字节串传递给参数，又能避免函数对外面变量的修改 const 数组 cosnt int a[] &#x3D; {1,2,3,4,5,6}; 数组变量已经是cosnt的指针了，这里的const表明数组的每个单元都是const int 所以必须通过初始化进行赋值 保护数组值 因为要把数值传入函数时传递的是地址，所以那个函数内部可以修改数组的值 为了保护数组不被破坏，可以设置参数为cosnt int sum(const int a[], int length ); int *p; *p &#x3D; a[0];&#x2F;&#x2F; OKp &#x3D; a[0]; &#x2F;&#x2F; ERROR，p所储存的是地址，这样表示把a[0]的值赋给p,覆盖了原来的的地址，语法错误。 指针运算指针是可计算的1 + 1 &#x3D; 2？ 给一个指针加1表示要让指针指向下一个变量 int a[10]; int *p = a[0]; *(p + 1) -&gt; a[1] *(p+n) = a[n] 如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义 指针计算 可以经行 +, +&#x3D;, -, -&#x3D; 可以++， – 挪到下一个位置去 两个指针可以相减， 得到的是：差值**指针类型大小 *p++ 取出p所指的那个数据来，完事之后顺便把p移到下一个位置去 （*的优先级虽然高，但是没有++高） 常用于数组的连续空间操作 在某些CPU上，这可以直接被翻译为一条汇编指令 指针比较 &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;都可以对指针做 比较他们在内存中的地址，a[0]的地址比a[1]小 数组中的单元的地址肯定是线性递增的 0地址 内存中有0地址，但是0地址不能随便碰 所以指针不应该具有0值 因此可以用0地址来表示特殊的事情： 返回的指针无效 指针没有被真正初始化 NULL（小写不管用）是一个预定定义的符号，表示0的地址（优先使用NULL表示0地址） 指针类型的转换 不同类型的指针不能相互赋值 void* 表示不知道指向什么东西的指针 计算式与char*相同（但不相通？？？） 指针 也可以转换类型 int *p &#x3D; &i; void *q &#x3D; (void *)p; i的类型还是int,但是q这时也指向i，所以通过q去看i时是void型 这里并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量 用指针来做什么？ 需要传入较大的数据做参数 传入数组后对数组做操作 函数返回不止一个结果 需要用函数来修改不止一个变量 动态申请的内存… 动态内存的分配在C99中可以定义一个变量来实现可变数组大小，但是在C99之前是不行的；这时候需要用到malloc 使用malloc需要用到新的头文件，&lt;stdlib.h&gt; #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int number; int *a; int i; printf(&quot;输入数量：&quot;); scanf(&quot;%d&quot;, &amp;number); // int a[number]; a = (int*)malloc(number*sizeof(int)); // 强制类型转换，然后使用malloc定义大小 for (i = o; i&lt;= number; i++) // 读入数组 &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; for (i = number-1; i&gt;= 0; i--) //逆序输出 &#123; printf(&quot;%d &quot;, a[i]); &#125; free(a); // 有借有还，再借不难！！&#125; malloc #include&lt;stdlib.h&gt; void* malloc(size_t size); 向malloc申请的空间的大小是以字节为单位的 返回的结果是void*，需要类型转换为自己需要的类型 (int*)malloc(n *sizeof(int)) 计算机no care这个是double还是int，它只认为内存是一片连续的空间 没空间了？ 如果申请失败则返回0，或者叫做NULL 你的系统能给你多少空间? #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; void *p; int cnt = 0; while ( (p = malloc(100*1024*1024)) ) &#123; cnt++; &#125; printf(&quot;分配了%d00的空间&quot;, cnt); return 0;&#125; 指针定义了，就初始化它为0； 常见问题 申请了没有free-&gt;长时间运行内存逐渐下降 新手（低情商）：忘了 老手（高情商）：找不到合适的free时机 字符串字符串字符串 以0（整数0）结尾的一串字符 0（一个int)或者‘&#x2F;0’（一个字节）是一样的，但是和‘0’不同,这个表示ASCII 0标志字符串结束，但它本身不是字符串的一部分 计算字符串长度的时候不包含这个0 字符串以数组的形式存在，以数组或指针的形式访问 更多的是以指针的形式 C语言的字符串是以 字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用来初始化字符数组 以及标准库提供了一系列字符串函数 字符串常量 “Hello” 字符串的字面量 “Hello”会被编译器变成一个字符数组放在某处，这个数组长度是6，结尾还有表示结束的‘0’； 两个相邻的字符串常量会被连接起来 字符串变量char * s &#x3D; “hello world!”; s是一个指针，初始化为指向一个字符串常量 由于这个常量所在的地方，所以实际上s是const char * s，但是由于历史的原因，编译器接受不带const的写法 但是试图对s所指的字符串做写入会造成严重的后果 如果需要修改字符串，应该用数组： char s[] &#x3D; “hello world!”; 指针还是数组? char *str &#x3D; “hello”; char word[] &#x3D; “hello”; 数组：这个字符串在这里 作为本地变量空间自动被回收 指针：这个字符串不知道在哪里 处理参数 动态分配空间 char* 不一定是字符串 本意是指向字符的指针，可能指向的是字符的数组 只有它所指的字符数组有结尾0的时候，才能说他是字符串 char * s = &quot;hello world!&quot;;char s1[] = &quot;hello world!&quot;;// s = &#x27;8&#x27;;// s1[0] = 7;// s = &#x27;salgjag&#x27;;s1[0]= &#x27;jjj&#x27;;printf(&quot; s=%p, %s &quot;, s, s);printf(&quot;s1=%p, %s &quot;, &amp;s1, s1); 字符串运算字符串赋值？ char *t &#x3D; “title”; char *s; s &#x3D; t; 并没有产生新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的； 字符串输入输出 scanf读入一个单词，到空格、tab或回车为止 scanf是不安全的，因为不知道要读入的内容长度 安全输入 scanf(“%Xs”, string); X表示最多允许读入的字符的数量，这个数字应该比数字的大小减一 下一次的scanf从哪里开始？ 常见错误 以为char * string就是字符串类型，定义了一个字符串类型的变量就可以直接使用了 由于没有对string初始化为0，所以不一定每次运行都出错。 空字符串 char buffer[100] &#x3D; “”; 一个空的字符串，buffer[0] &#x3D;&#x3D; ‘\\0’ char buffer[] &#x3D; “”; 这个数组的长度是1！！！ 字符串数组以及程序参数 char **a a是个指针，指向另一个指针，那个指针指向一字符串 char a[] [] a是一个二维数组，第二个维度的大小不知道，不能编译 char a[] [10] a是一个二维数组，a[x]是一个char[10] char * a[] a是一个一维数组，a[x]是一个char* iy &#x3D; abs( ix ); &#x2F;&#x2F;int型 ly &#x3D; labs( lx ); &#x2F;&#x2F;long型 dy &#x3D; fabs( dx ); &#x2F;&#x2F;double型 程序参数 int main(int argc, char const *argv[]) argv[0]是命令本事 当使用Unix的符号，反映符号链接的名字 字符串函数单字符输入输出 putchar int putchar(int c); 向标准输出一个字符 返回写了几个字符，EOF（-1）表示写失败 getchar int getchar(void) 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) windows-&gt;ctrl z char ch;while ((ch = getchar()) != EOF)&#123; putchar(ch);&#125;printf(&quot;EOF &quot;); 每次只读一个，为什么需要按回车才会返回结果？ shell会有一个行编辑，在没有按回车的时候，shell不会把输人给程序 字符串函数strlensize_t mylen(const char *s)&#123; int idx = 0; while (s[idx] != &#x27;\\0&#x27;) &#123; idx++; &#125; return 0;&#125; strcmpp的值没有改变，++改变了P存储的地址，这里的++从逻辑上讲，是让指针指向了下一个内存地址。在这里下一个内存地址就是下一个字节。++完成后，因为循环再次回到判断，做运算，即取值指向的值。const *p允许读取，不允许写入，在整个过程中，没有发生写入。 int strcmp（const char *s1, const char *s2); 比较两个字符串，返回： 0：s1 &#x3D;&#x3D; s2; 大于0：s1 &gt; s2; 小于0；s1 &lt; s2; in mycmp(cosnt char *s1, cosnt char *s2)&#123; int idx = 0; while (s1[idx] == s2[idx] &amp;&amp; s1[idx] != &#x27;\\0&#x27;) &#123; idx++; &#125;&#125;\twhile (*s1 == *s2 &amp;&amp; *s1 != &#x27;\\0&#x27;) &#123; s1++; s2++; &#125;\treturn *s1 - *s2; strcpy#include &lt;stdio.h&gt;char *mycpy(char *dst, const char *src)&#123; char *ret = dst; while (*dst++ = *src++) ; *dst = &#x27;\\0&#x27;; return ret;&#125;char *mycpy(char *dst, const *char src)&#123; int idx = 0; while (src[idx]) &#123; dst[idx] = src[idx]; idx++; &#125; dst[idx] = &#x27;\\0&#x27;;&#125;return dst;int main()&#123; char s1[] = &quot;abc&quot;; char s2[] = &quot;aaa&quot;; mycpy(s1,s2); printf(&quot;%s &quot;, s1); return 0;&#125; char *strcpy (char *restrict dst, cosnt char *restrict src); 把src的字符串拷贝到dst restrict表明src和dst不重叠 返回dst 为了能链起代码来 复制一个字符串从函数参数得到一个字符串，但实际我们得到的是一个指针，我们不能保证指针指向的那个字符串始终在，所以我们需要把它复制过来。 char *dst &#x3D; (char *)malloc(strlen(src)+1); &#x2F;&#x2F; 加一是为了结尾的0 strcpy(dst, src); 字符串函数strcat char *strcat(char *restrict s1, const cahr *restrict s2); 把s2拷贝到s1的后面，接成一个长的字符串 返回s1 s1必须具有足够的空间 安全问题 strcpy和strcat都可能出现安全问题 如果目的地没有足够的空间？？？ 尽量不要使用 安全版本 char *strncpy(char *restrict dst, const char *restrict src, size_t n); char *strcat(cahr *restrict s1, const char *restrict s2, size_t n); int strncmp(const char *s1, const char *s2, size_t n); &#x2F;&#x2F;意思是只比较前n个就得出结论。 字符串搜索函数 char *strchr(const char *s, int c); &#x2F;&#x2F; 从左往右 char *strrchr(const char *s, int c); &#x2F;&#x2F; 从右往左 返回NULL表示没有找到 如何寻找第二个？ int main(int argc, char const *argv[])&#123; char s[] = &quot;hello&quot;; char *p = strchr(s, &#x27;l&#x27;); char *t = (char *)malloc(strlen(p)+1); strcpy(t, p); printf(&quot;%s &quot;, t); free(t); return 0;&#125; 做完之后*p &#x3D; c;什么都没有发生。 字符串中找字符串 char *strstr(const char *s1, const char *s2); char *strcasrstr(const char *s1, const char *s2); 结构类型枚举 用符号，而不是具体的数字来表示程序中的数字，这件事枚举会比定义独立的const int更加方便 enum COLOR &#123;RED, YELLOW, GREEN&#125;; 枚举是一种用户定义的数据类型，它用关键字enum以如下语法来声明： enum 枚举类型名字 &#123;名字0， 名字1， ... 名字n&#125;; 枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为他们就是常量符号，类型是int，值依次从0递增到n. 当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字。 #include&lt;stdio.h&gt;enum color &#123;red, yellow, green&#125;;void f (enum color c);int main()&#123; enum color t = red; // scanf(&quot;%d&quot;, &amp;t); f(t); return 0;&#125;void f(enum color c)&#123; printf(&quot;%d &quot;, c);&#125; 枚举量可以作为值 枚举类型可以跟上enum作为类型 但是实际上是以整数来做内部计算和外部输入输出的。 套路：自动计数的枚举 这样需要遍历所有枚举量或者需要建立一个用枚举量做下标的数组时就很方便。 枚举量 声明枚举量的时候可以指定值 enum COLOR &#123;RED=1, YELLOW, GREEN=5&#125;; 枚举只是int,即使给枚举类型的变量赋不存在的整数值也没有任何warning或者error. 枚举 虽然枚举类型可以当作类型使用，但是实际上很（bu)少（hao）用 如果有意义上排比的名字，用枚举比const int方便 枚举比宏（macro)好，因为枚举有int类型。 结构结构类型 声明结构类型 一个结构就是一个复合的结构类型,一个变量表达这些数据。 注意结尾的分号； 通常会将结构体放在函数外； 声明结构的形式 结构变量 结构的初始化 结构里的成员 结构和数组有点像 数组用[ ]运算符和下标访问其成员 结构用 “ . “ 运算符和名字访问其成员 today.day student.fiestName pl.y pl.x 结构运算 要访问整个结构，直接用结构变量的名字 对于整个结构，可以做赋值、取地址，也可以传递给函数参数 pl = (struct point)&#123;5,10&#125;; // 相当于pl.x = 5; pl.y = 10; p1 = p2; // 相当于p1.x = p2.x; p1.y = p2.y; 而数组无法做这种运算 结构指针 结构变量的名字并不是结构变量的地址，必须使用&amp;运算符 struct date * pDate &#x3D; &today; 复合字面量字面量指处符号常量外的常量 (type-name）&#123; initializer-list &#125; （type-name） &#123; initializer-list , &#125; today &#x3D; (struct date) {9,25,2004}; today &#x3D; (struct date) {.month&#x3D;9, .day&#x3D;25, .year&#x3D;2004}; （int [2]){19,20}; 结构函数 记住页数的经典的东西[狗头] 结构作为函数参数int numberofDays (strcut date d) 整个结构可以作为参数的值传入函数 这时候是在函数内新建一个结构变量，并复制调用者的结构的值 也可以返回一个结构 这与数组不同 输入结构 没有直接的方式可以一次scanf一个结构 如果写一个函数用来读入结构 但是读入的结构如何传出？？？ 解决方案 使用指针，因为传入的函数是外面那个结构的克隆体，而不是指针 或者创建一个临时的结构变量，把这个结构返回给调用者 指向结构的指针 相比(*p).month，可以用-&gt;表示指针所指的结构变量中的成员 结构指针参数 好处是传入传出只是一个指针的大小 如果需要保护传入的结果不被函数修改 const struct point *p 返回传入的指针是一种套路，这样可以少用一次P，因为后续可能有其他函数需要这个结构的地址。让程序更加简洁。 结构中的结构struct date dates[100];struct date dates[] = &#123;&#123;5,3,2002&#125;, &#123;5,2,2003&#125;&#125;;struct dateAndTime &#123;\tstruct date sdate;\tstruct date stiem;&#125;; 嵌套的结构类型定义联合选择： 成员是 一个int i还是 一个char c sizeof(union …) &#x3D; sizeof (每个成员)的最大值 联合 存储 所有的成员共享一个空间 同一时间只有一个成员是有效的 union的大小是其最大的成员 初始化 对第一个成员做初始化 union自己并不知道当时其中那个成员是有效的 union的用处#include &lt;stdio.h&gt;typedef union&#123; int i; char ch[sizeof(int)];&#125; CHI;int main()&#123; CHI chi; int i; chi.i = 1234; for (i = 0; i &lt; sizeof(int); i++) printf(&quot;%02hhX&quot;, chi.ch[i]); printf(&quot; &quot;); return 0;&#125; 类型定义自定义数据类型 typedef typedef int Length; 使得Length成为int类型的别名。 Length a, b, kle. Length numbers[10]; typedef typedef struct &#123; int month; int day; int year;&#125; Date; 程序结构全局变量全局变量 定义在函数外面的全局变量 全局变量具有全局的生存期和作用域 它们与任何函数无关 在任何函数内部都可使用它们 全局变量初始化 没有做初始化的全局变量会得到0值 指针会得到NULL 只能用编译时刻已知的值来初始化全局变量？？？ 它们的初始化发生在main函数之前 被隐藏的全局变量 如果函数内部存在与全局变量同名的变量，则全局变量被隐藏 静态本地变量 在本地变量定义时加上static修饰符就成为静态本地变量 当函数离开时，静态本地变量会继续存在并保持其值 静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值 静态本地变量实际上是特殊的全局变量 它们位于相同的内存区域 静态本地变量具有全局的生存期，函数内的局部作用域 static在这里的意思是局部作用域(本地可访问) 在程序载入内存时就已经为static分配好了内存。 写在函数里面表示只能有这个函数识别。 返回指针的函数int *f(void);void g(void)int mian()&#123;\tint *p = f();\tprintf(&quot;*p=%d &quot;, *p);\tg();\tprintf(&quot;*p=%d &quot;, *p);\treturn 0;&#125;int * f(void)&#123;\tint i=13;\treturn &amp;i;&#125;void g(viod)&#123;\tint k=23;\tprintf(&quot;k=%d &quot;, k);&#125;m 局部变量在自动内存中，第一次输出时候还在，但是调用g函数时，这里的内存被重新使用，挤掉了原来的值。 如果打印i和k的地址会发现他是一样的。 tips 不要使用全局变量来在函数间传递参数和结果 尽量避免使用全局变量 丰田汽车的案子 （使用全局变量和静态本地变量的函数是线程不安全的） 编译预处理和宏宏编译预处理指令 #开头的是编译预处理指令 它们不是C语言的成分，但是C语言程序离不开它们 #define用来定义一个宏 #define #define &lt; name &gt; &lt; zhi &gt; 注意没有结尾的分号，因为不是C的语句 名字必须是一个单词，值可以是各种东西 在C语言的编译器开始编译之前，编译预处理程序会把程序中的名字换成值 完全的文本替换 宏 如果一个宏的值中有其他宏的名字，也是会被替换的 如果一个宏的值超过一行，最后一行之前的行末需要加\\ 宏的值后面出现的注释不会被当作宏的值的一部分 没有值的宏 #define _DEBUG 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了 预定义的宏带着翅膀的宏 _ LINE _ _ FILE _ _ DATE _ _ TIME _ _ STDC _ 带参数的宏 #define cude(x) ((x)(x)(x)) 宏可以带参数 引用时cude(4),X会被替换为4 错误定义的宏 #define RADTODEG(x) (x*57.29578) #define RADTODEG(x) (x)*57.29578 带参数宏的原则 一切都要括号 整个值要括号 参数出现的每个地方都要括号 #define RADTODEG(x) ((x)*57.29578) 可以带多个参数 #define MIN(a,b) ((a)&gt;(b)?(b):(a)) 也可以组合（嵌套）使用其他宏 在大型程序的代码中使用非常普遍 可以非常复杂，如“产生”函数 在#和##的帮助下 中西方文化差异[😀] 部分宏会被inline函数代替 其他编译预处理指令 条件编译 error … 大程序文件头文件函数原型 如果不给出函数原型，编译器会猜测你所调用的函数的所有参数都是int,返回类型也是一样 编译器在编译的时候只看当前的一个编译单元，它不会去看同一个项目中的其他编译单元以找出那个函数的原型 如果你的函数并非如此，程序连接的时候不会出错 但是执行的时候就不对了 所以需要在调用函数的地方给出函数的原型，以告诉编译器那个函数究竟长什么样 头文件 把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器再编译的时候知道函数的原型 在使用和定义这个函数的地方都应该#include这个头文件 一般的做法就是任何.c都有对应的同名.h，把所有对外公开的函数的原型和全局变量的声明都放进去 # include #include是一个编译预处理指令，和宏一样，在编译之前就处理了 它把那个文件的全部文本内容原封不动地插入到它所在地地方 所以也不是一定要在.c文件地最前面#include “” 还是&lt;&gt; #icnlude有两种形式来指出要插入的文件 “”要求编译器首先在当前目录（.c文件所在地目录）寻找这个文件，如果没有，到编译器指定的目录去找 &lt;&gt;让编译器只在指定的目录去找 编译器自己知道自己地标准库地头文件在哪里 环境变量和编译器命令行参数也可以指定寻找头文件地目录 #include的误区 #include不是用来引入库的 stdio.h里只有printf的原型，printf的代码在另外的地方 现在的C语言编译器默认会引入所有的标准库 #include&lt;stdio.h&gt;只是为了让编译器知道printf函数的原型，保证你调用的时候给出的参数值是正确的类型 在全局变量前面加上static表示只能在当前的.c文件中使用 声明变量的声明 int i; 是变量的定义 extern int i; 是变量的声明 声明和定义 声明是不产生代码的东西 函数原型 变量声明 结构声明 宏声明 枚举声明 类型声明 inline声明 定义是产生代码的东西 头文件 只有声明可以被放在头文件中 是规则不是法律 否则会造成一个项目中多个编译单元里有重名的是实体 有些编译器允许 重复声明 同一个编译单元里，同名的结构不能被重复声明 如果你的头文件里有结构的声明，很难这个头文件不会再一个编译单元里被#include多次 所以需要“标准头文件结构” 标准头文件结构 运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次，带上翅膀 第十三周 文件文件格式化输入输出%[flags] [width][.prec][hlL]type printf(&quot;%*d &quot;,6, 123); // *表示6是用来填充*的 scanf: %[flag]type scanf(&quot;%*d%d&quot;, &amp;num); 位运算链表有一个东西，里面有俩个部分，一个是数据，一个是指针，这个指针指向另一个相同的东西。这就是链表 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct Node* add(struct Node *head, int number);void print(struct Node *phead);struct Node&#123; int value; struct Node *next;&#125;;int main()&#123; struct Node *head = NULL; int number; do &#123; scanf(&quot;%d&quot;, &amp;number); if (number != -1) &#123; head = add(head, number); &#125; &#125; while( number != -1 ); print(head); scanf(&quot;%d&quot;, &amp;number); struct Node *p, *q; int isFound = 0; for (p=head; p; p=p-&gt;next) &#123; if (p-&gt;value = number) &#123; isFound = 1; printf(&quot;找到了! &quot;); break; &#125; if (!isFound) printf(&quot;没找到! &quot;); &#125; for (p = head, q=NULL; p; q=p;p=p-&gt;next) &#123; if (p-&gt;value == number) &#123; if ( q ) &#123; q-&gt;next = p-&gt;next; &#125; else head = p-&gt;next; free(p); break; &#125; &#125; return 0;&#125;struct Node* add(struct Node *head, int number)&#123; // add to linked-list struct Node *p = (struct Node *)malloc(sizeof(struct Node)); p-&gt;value = number; p-&gt;next = NULL; // find the last struct Node * last = head; if ( last ) &#123; while (last-&gt;next) //循环结束时，last就是最后哪一个结构。 //head的地址和head指向的那个东西的地址 last = last-&gt;next; // 现在last指向最后一个结构中的next。 //attach last-&gt;next = p; &#125; else head = p; return head;&#125; void print(struct Node *phead)&#123; struct Node *p; for (p = phead; p; p=p-&gt;next) printf(&quot;%d\\t&quot;, p-&gt;value); printf(&quot; &quot;);&#125; How do we find the boundary当一个指针出现在arrow的左边时，以为着要使用这个指针，那么就要看看这个指针是否是NULL 编程练习4.0// 计算机循环的思想#include&lt;stdio.h&gt;int main()&#123; int a; scanf(&quot;%d&quot;, &amp;a); int cnt = 0; // 计数专用cnt int i, j, k; // 就是induce，之后用j, k for ( i = a; i &lt;= a+3; i++ ) // 输入一个，输出三个，需要有三重循环；从外往内走，到最小时做输出； &#123; for ( j = a; j &lt;= a+3; j++) &#123; for ( k = a; k &lt;= a+3; k++) &#123; if (i != j &amp;&amp; j != k &amp;&amp; k != i) &#123; printf(&quot;%d&quot;, i*100+j*10+k); cnt++; if (cnt == 6) &#123; printf(&quot; &quot;); cnt = 0; &#125; else &#123; printf(&quot; &quot;); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 4.1 水仙花数#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main ()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int i,first; i = first = 1; while (i &lt; n) &#123; first *= 10; i++; &#125; i = first; while (i &lt; first*10) &#123; int fin = 0; int sum = 0; int t = i; do &#123; int d = t%10; t /= 10; sum = pow(d,n); fin += sum; &#125; while (t &gt; 0); if ( fin == i) &#123; printf(&quot;%d &quot;, i); &#125; i++; &#125; return 0;&#125; 4.2 九九乘法表#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int i, j, cnt; cnt = 1; for (i = 1; i &lt;= n; i++) &#123; j = cnt; while (j &lt;= n) &#123; printf(&quot;%d*%d=%-4d&quot;, i, j, i*j); j++; &#125; printf(&quot; &quot;); cnt++; &#125; return 0;&#125; 4.3/*统计给定整数M和N区间内素数的 个数 并对它们 求和1. 计数 2. 计数后相加变量：m,n. sum cnt ,i,j,k.*/#include&lt;stdio.h&gt;int main()&#123; int m,n; scanf(&quot;%d %d&quot;, &amp;m, &amp;n); int cnt = 0; int sum = 0; for (;m &lt;= n;m++) &#123; if ( m%2 != 0 ) &#123; int isPrime = 1; for (int k = 3; k &lt; m; k++) &#123; if (m%k == 0) &#123; isPrime = 0; break; &#125; &#125; if ( isPrime ) &#123; sum += m; cnt++; &#125; &#125; &#125; printf(&quot;%d %d&quot;, cnt, sum); return 0;&#125; 5.0 前N项和/*计算序列 2/1 + 3/2 + 5/3 + 8/5 + ... 的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。(b+c)/cn输入计算位数-&gt;一个sum保存和-&gt;一个dynamic计算计算过程：只是找一个变量做替换，没有递增。题目已经给出算法！！！*/#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); double a, b; a = 2; b = 1; double sum, dynamic; sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += a/b; dynamic = a; a += b; b = dynamic; &#125; printf(&quot;%.2lf &quot;, sum); printf(&quot;%d %d &quot;, a, b); printf(&quot;%lf %lf&quot;, a, b); return 0;&#125; 5.1 化简/*最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。循环（a%i!=0） 找到约数*/#include&lt;stdio.h&gt;int main()&#123; int a, b; scanf(&quot;%d/%d&quot;, &amp;a, &amp;b); int i, j; for (i = a-1; a%i!=0; i--) ; for (j = b-1; b%j!=0; j--) ; if ( i &gt; j) &#123; printf(&quot;%d/%d&quot;, i, j); &#125; else &#123; printf(&quot;%d/%d&quot;, i, j); &#125; return 0;&#125; 谭8.15 指针/*四个学生，五门课程成绩，即为一个四行五列的数组。每一行的第0个元素相然后除4.得到第一门课平均分*/int main()&#123; int i, j; float n; char score[][5]; for ( i = 0; i &lt; 4; i++) &#123; for( j = 0; j &lt; 5; j++) &#123; scanf(&quot;%f&quot;, score[i][j]);&#125;void avg(int score[][5], int n)&#123; float sum=0; for ( int i = 0; i &lt; 4; i++) &#123; sum += *(*(score + i) + 0) &#125; printf(&quot;第一门课成绩为：%f&quot;, sum/4);&#125; 数组名是数组首元素的地址 *(score+0) &#x3D;&#x3D; score[0] *((score+0) + 1)&#x2F;&#x2F; 第一个学生的第二门课成绩","tags":["C","编程"],"categories":["技术","记录"]},{"title":"SpringMVC 学习","path":"/2023/02/17/四、SpringMVC实战：构建高效表述层框架/","content":"四、SpringMVC实战：构建高效表述层框架一、SpringMVC简介和体验1.1 介绍https://docs.spring.io/spring-framework/reference/web/webmvc.html &#x3D;&#x3D;Spring Web MVC是基于Servlet API构建的原始Web框架&#x3D;&#x3D;，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ spring-webmvc ），但它通常被称为“Spring MVC”。 在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的首选方案。之所以能做到这一点，是因为SpringMVC具备如下显著优势： Spring 家族原生产品，与IOC容器等基础设施无缝对接, 爹好 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 Servlet 是 Java 平台上的一项技术，主要用于创建动态的 Web 应用程序。它是一种在服务器端运行的小程序，通常用于处理和响应 Web 客户端（例如浏览器）的请求。 Servlet 的工作原理Servlet 的工作流程一般如下： 客户端请求：用户在浏览器中输入 URL 或者点击链接，发送一个 HTTP 请求到服务器。 服务器解析请求：Web 服务器接收到请求，并将其转发给相应的 Servlet。 Servlet 处理请求：Servlet 接收到请求后，执行相关的业务逻辑，访问数据库或其他资源，生成响应内容。 服务器发送响应：Servlet 处理完请求后，将生成的响应返回给 Web 服务器，服务器再将响应发送回客户端。 Servlet 生命周期Servlet 的生命周期包括以下几个阶段： 加载和实例化：Servlet 类被加载到内存中，并实例化一个 Servlet 对象。 初始化：调用 init() 方法进行初始化，这个方法只在 Servlet 实例化后调用一次。 处理请求：每次有请求到来时，Servlet 的 service() 方法被调用，具体的请求被 doGet() 或 doPost() 等方法处理。 销毁：在服务器关闭或 Servlet 被卸载时，调用 destroy() 方法释放资源。 一个简单的 Servlet 示例import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/hello&quot;)public class HelloWorldServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); response.getWriter().println(&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;); &#125;&#125; 这个简单的示例展示了一个基本的 Servlet，它处理 GET 请求并返回一个简单的 HTML 响应。 常用的 Servlet API **HttpServlet**：所有 Servlet 类通常继承自这个类。 **HttpServletRequest**：封装了客户端请求的所有信息。 **HttpServletResponse**：封装了返回给客户端的响应信息。 **ServletConfig**：用于获取 Servlet 的配置信息。 **ServletContext**：用于在多个 Servlet 之间共享信息。 使用 Servlet 的优势 性能：因为 Servlet 是在服务器内存中运行的，避免了创建新进程的开销，响应速度快。 可扩展性：通过与其他 Java EE 组件（如 JSP、EJB）结合，构建大型、复杂的 Web 应用。 健壮性：Java 的强类型和异常处理机制使得 Servlet 具有较高的健壮性和安全性。 原生Servlet API开发代码片段 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String userName = request.getParameter(&quot;userName&quot;); System.out.println(&quot;userName=&quot;+userName);&#125; 基于SpringMVC开发代码片段 @RequestMapping(&quot;/user/login&quot;)public String login(@RequestParam(&quot;userName&quot;) String userName,Sting password)&#123; log.debug(&quot;userName=&quot;+userName); //调用业务即可 return &quot;result&quot;;&#125; 1.2 主要作用 表述层接受前端参数, 调用业务逻辑, 响应前端数据. SpringMVC的作用主要覆盖的是表述层，例如： 请求映射 数据输入 视图界面 请求分发 表单回显 会话控制 过滤拦截 异步交互 文件上传 文件下载 数据校验 类型转换 等等等 最终总结： 简化前端参数接收( 形参列表 ) 简化后端数据响应(返回值) 以及其他…… 1.3 核心组件和调用流程理解Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 Servlet DispatcherServlet 做整体请求处理调度！ 除了DispatcherServletSpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。 SpringMVC处理请求流程： 如果没有SpringMVC, 用户是直接访问controller层. 圈子内各个小圆圈就是SpringMVC的组件, 内部封装一个servlet, 大名叫DispatcherServlet, 用户先访问它. CEO去找handlerMapping, 是CEO的秘书. CEO再去找经理(HandlerAdapter), 老板把参数装到request中, 经理去调用具体的打工人(方法), 将响应封装到response 登陆时CEO去找财务(视图解析器), 他去调用具体的文件 完成一系列操作后CEO返回给用户 SpringMVC涉及组件理解： DispatcherServlet : SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ] HandlerMapping : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书] HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理] Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人] ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务] 1.4 快速体验 体验场景需求 配置分析 DispatcherServlet，设置处理所有请求！ HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！ Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！ 准备项目 创建项目 springmvc-base-quick 注意：需要转成maven&#x2F;web程序！！ 导入依赖 Controller声明 @Controllerpublic class HelloController &#123; //handlers /** * handler就是controller内部的具体方法 * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解! * @ResponseBody 代表向浏览器直接返回数据! */ @RequestMapping(&quot;/springmvc/hello&quot;) @ResponseBody public String hello()&#123; System.out.println(&quot;HelloController.hello&quot;); return &quot;hello springmvc!!&quot;; &#125;&#125; Spring MVC核心组件配置类 声明springmvc涉及组件信息的配置类 //TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc @Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; @Bean public HandlerMapping handlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125; @Bean public HandlerAdapter handlerAdapter()&#123; return new RequestMappingHandlerAdapter(); &#125; &#125; SpringMVC环境搭建 对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示： //TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定service / mapper层的配置类 */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return null; &#125; /** * 指定springmvc的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;; &#125; /** * 设置dispatcherServlet的处理路径! * 一般情况下为 / 代表处理所有请求! */ @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 启动测试 注意： tomcat应该是10+版本！方可支持 Jakarta EE API! 整个启动流程: 声明Handler方法 写配置类, 指定HandlerMapping和HandlerAdapter放到ioc容器 写一个类继承AbstractAnnotationConfigDispatcherServletInitializer, 重写方法配置servlet地址和项目配置类 二、SpringMVC接收数据2.1 访问路径设置@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。 精准路径匹配 在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。 @Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125;) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125; /** * 精准设置访问地址 /user/register */ @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;) @ResponseBody public String register()&#123; System.out.println(&quot;UserController.register&quot;); return &quot;register success!!&quot;; &#125; &#125; 模糊路径匹配 在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。 @Controllerpublic class ProductController &#123; /** * 路径设置为 /product/* * /* 为单层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 不可以 * 路径设置为 /product/** * /** 为任意层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 也可以访问 */ @RequestMapping(&quot;/product/*&quot;) @ResponseBody public String show()&#123; System.out.println(&quot;ProductController.show&quot;); return &quot;product show!&quot;; &#125;&#125; 单层匹配和多层匹配： /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。 /**：可以匹配URL地址中的多层。其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。 类和方法级别区别 @RequestMapping 注解可以用于类级别和方法级别，它们之间的区别如下： 设置到类级别：@RequestMapping 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。 设置到方法级别：@RequestMapping 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 @RequestMapping 注解进行更精细的映射。//1.标记到handler方法@RequestMapping(&quot;/user/login&quot;)@RequestMapping(&quot;/user/register&quot;)@RequestMapping(&quot;/user/logout&quot;)//2.优化标记类+handler方法//类上@RequestMapping(&quot;/user&quot;)//handler方法上@RequestMapping(&quot;/login&quot;)@RequestMapping(&quot;/register&quot;)@RequestMapping(&quot;/logout&quot;) 附带请求方式限制 HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类： public enum RequestMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE&#125; 默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！ 如果需要特定指定： @Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login * method = RequestMethod.POST 可以指定单个或者多个请求方式! * 注意:违背请求方式会出现405异常! */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125; /** * 精准设置访问地址 /user/register */ @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;) @ResponseBody public String register()&#123; System.out.println(&quot;UserController.register&quot;); return &quot;register success!!&quot;; &#125;&#125; 注意：违背请求方式，会出现405异常！！！ 进阶注解 还有 @RequestMapping 的 HTTP 方法特定快捷方式变体： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)||@GetMapping(value=&quot;/login&quot;) 注意：进阶注解只能添加到handler方法上，无法添加到类上！ 常见配置问题 出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。 There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() mapped. 2.2 接收参数（重点）2.2.1 param 和 json参数比较在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比： 参数编码： &#x20; param 类型的参数会被编码为 ASCII 码。例如，假设 name=john doe，则会被编码为 name=john%20doe。 而 JSON 类型的参数会被编码为 UTF-8。 参数顺序： &#x20; param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。 JSON 采用键值对的形式进行传递，其中键值对是有序排列的。 数据类型： &#x20; param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。 而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。 嵌套性： &#x20; param 类型的参数不支持嵌套。 但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。 可读性： &#x20; param 类型的参数格式比 JSON 类型的参数更加简单、易读。 但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。 &#x3D;&#x3D;总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。&#x3D;&#x3D;根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。 2.2.2 param参数接收 直接接值 客户端请求 handler接收参数 只要形&#96;&#96;参数名和类型与传递参数相同，即可自动接收! @Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; /** * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18 * * 可以利用形参列表,直接接收前端传递的param参数! * 要求: 参数名 = 形参名 * 类型相同 * 出现乱码正常，json接收具体解决！！ * @return 返回前端数据 */ @GetMapping(value=&quot;/value&quot;) @ResponseBody public String setupForm(String name,int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name + age; &#125;&#125; @RequestParam注解 可以使用 @RequestParam 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。 @RequestParam使用场景： 指定绑定的请求参数名 要求请求参数必须传递 为请求参数提供默认值基本用法： /** * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18 * * 使用@RequestParam注解标记handler方法的形参 * 指定形参对应的请求参数@RequestParam(请求参数名称) */@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;stuAge&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 默认情况下，使用此批注的方法参数是必需的，但您可以通过将 @RequestParam 批注的 required 标志设置为 false！ 如果没有没有设置非必须，也没有传递参数会出现： 将参数设置非必须，并且设置默认值： @GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 特殊场景接值 一名多值 多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！ /** * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝 * * 一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定 */@GetMapping(value=&quot;/mul&quot;)@ResponseBodypublic Object mulForm(@RequestParam List&lt;String&gt; hbs)&#123; System.out.println(&quot;hbs = &quot; + hbs); return hbs;&#125; 实体接收 Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例： 定义一个用于接收参数的实体类： public class User &#123; private String name; private int age = 18; // getter 和 setter 略&#125; 在控制器中，使用实体对象接收，示例代码如下： @Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST) @ResponseBody public String addUser(User user) &#123; // 在这里可以使用 user 对象的属性来接收请求参数 System.out.println(&quot;user = &quot; + user); return &quot;success&quot;; &#125;&#125; 在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！ 使用postman传递参数测试： 2.2.3 路径 参数接收路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 @PathVariable 注解来处理路径传递参数。 @PathVariable 注解允许将 URL 中的占位符映射到控制器方法中的参数。 例如，如果我们想将 /user/&#123;id&#125; 路径下的 &#123;id&#125; 映射到控制器方法的一个参数中，则可以使用 @PathVariable 注解来实现。 下面是一个使用 @PathVariable 注解处理路径传递参数的示例： /** * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125; 动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识! * 形参列表取值: @PathVariable Long id 如果形参名 = &#123;动态标识&#125; 自动赋值! * @PathVariable(&quot;动态标识&quot;) Long id 如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值! * * 访问测试: /param/user/1/root -&gt; id = 1 uname = root */@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)@ResponseBodypublic String getUser(@PathVariable Long id, @PathVariable(&quot;name&quot;) String uname) &#123; System.out.println(&quot;id = &quot; + id + &quot;, uname = &quot; + uname); return &quot;user_detail&quot;;&#125; 2.2.4 json参数接收前端传递 JSON 数据时，Spring MVC 框架可以使用 @RequestBody 注解来将 JSON 数据转换为 Java 对象。@RequestBody 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下： 前端发送 JSON 数据的示例：（使用postman测试） &#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;男&quot;&#125; 定义一个用于接收 JSON 数据的 Java 类，例如： public class Person &#123; private String name; private int age; private String gender; // getter 和 setter 略&#125; 在控制器中，使用 @RequestBody 注解来接收 JSON 数据，并将其转换为 Java 对象，例如： @PostMapping(&quot;/person&quot;)@ResponseBodypublic String addPerson(@RequestBody Person person) &#123; // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性 return &quot;success&quot;;&#125; 在上述代码中，@RequestBody 注解将请求体中的 JSON 数据映射到 Person 类型的 person 参数上，并将其作为一个对象来传递给 addPerson() 方法进行处理。 完善配置 测试： 问题： org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported] 原因： 不支持json数据类型处理 没有json类型处理的工具（jackson）解决：springmvc handlerAdpater配置json转化器,配置类需要明确：//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;&#125; pom.xml 加入jackson依赖&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; @EnableWebMvc注解说明 @EnableWebMvc注解效果等同于在 XML 配置中，可以使用 &lt;mvc:annotation-driven&gt; 元素！我们来解析&lt;mvc:annotation-driven&gt;对应的解析工作！ 让我们来查看下&lt;mvc:annotation-driven&gt;具体的动作！ 先查看&lt;mvc:annotation-driven&gt;标签最终对应解析的Java类 查看解析类中具体的动作即可 打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler 打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123; public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName(); public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName(); static &#123; ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader(); javaxValidationPresent = ClassUtils.isPresent(&quot;jakarta.validation.Validator&quot;, classLoader); romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader); jaxb2Present = ClassUtils.isPresent(&quot;jakarta.xml.bind.Binder&quot;, classLoader); jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp; ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader); jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader); jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader); jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader); gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader); &#125; 主动调用pase方法, 创建handlerMapping, 它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书], 再将HandlerAdapter(经理)加入到ioc容器, 最后给他们添加对应的json处理器. &#x3D;&#x3D;这个注解相当于一个组合功能的表示&#x3D;&#x3D; @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) {&#x2F;&#x2F;handlerMapping加入到ioc容器readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);&#x2F;&#x2F;添加jackson转化器addRequestBodyAdvice(handlerAdapterDef);addResponseBodyAdvice(handlerAdapterDef);&#x2F;&#x2F;handlerAdapter加入到ioc容器readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);return null; } &#x2F;&#x2F;具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) {if (jackson2Present) { beanDef.getPropertyValues().add(“requestBodyAdvice”, new RootBeanDefinition(JsonViewRequestBodyAdvice.class));} } protected void addResponseBodyAdvice(RootBeanDefinition beanDef) {if (jackson2Present) { beanDef.getPropertyValues().add(“responseBodyAdvice”, new RootBeanDefinition(JsonViewResponseBodyAdvice.class));} } ### 2.3 接收Cookie数据可以使用 `@CookieValue` 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。考虑使用以下 cookie 的请求：```javaJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 下面的示例演示如何获取 cookie 值： @GetMapping(&quot;/demo&quot;)public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; //...&#125; 2.4 接收请求头数据可以使用 @RequestHeader 批注将请求标头绑定到控制器中的方法参数。 请考虑以下带有标头的请求： Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 下面的示例获取 Accept-Encoding 和 Keep-Alive 标头的值： @GetMapping(&quot;/demo&quot;)public void handle( @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; //...&#125; 2.5 原生Api对象操作https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html 下表描述了支持的控制器方法参数 Controller method argument 控制器方法参数 Description jakarta.servlet.ServletRequest, jakarta.servlet.ServletResponse 请求&#x2F;响应对象 jakarta.servlet.http.HttpSession 强制存在会话。因此，这样的参数永远不会为 null 。 java.io.InputStream, java.io.Reader 用于访问由 Servlet API 公开的原始请求正文。 java.io.OutputStream, java.io.Writer 用于访问由 Servlet API 公开的原始响应正文。 @PathVariable 接收路径参数注解 @RequestParam 用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。 @RequestHeader 用于访问请求标头。标头值将转换为声明的方法参数类型。 @CookieValue 用于访问Cookie。Cookie 值将转换为声明的方法参数类型。 @RequestBody 用于访问 HTTP 请求正文。正文内容通过使用 HttpMessageConverter 实现转换为声明的方法参数类型。 java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap 共享域对象，并在视图呈现过程中向模板公开。 Errors, BindingResult 验证和数据绑定中的错误信息获取对象！ 获取原生对象示例： /** * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序! * 注意: 接收原生对象,并不影响参数接收! */@GetMapping(&quot;api&quot;)@ResponseBodypublic String api(HttpSession session , HttpServletRequest request, HttpServletResponse response)&#123; String method = request.getMethod(); System.out.println(&quot;method = &quot; + method); return &quot;api&quot;;&#125; 2.6 共享域对象操作2.6.1 属性（共享）域作用回顾 两个资源之间传递时, 会将共同的数据放在共享空间当中, 一种数据的间接传递手段 存setAttribute(key , Object value) 取get 除remove 在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：ServletContext、HttpSession、HttpServletRequest、PageContext。 ServletContext 共享域：ServletContext 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 ServletContext 中保存的数据是线程安全的。 HttpSession 共享域：HttpSession 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 HttpSession 中，让用户在多个页面间保持登录状态。 HttpServletRequest 共享域：HttpServletRequest 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 HttpServletRequest 中，让处理器方法之间可以访问这些数据。 PageContext 共享域：PageContext 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括pageScope、requestScope、sessionScope、applicationScope 等作用域。 共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。 2.6.2 Request级别属性（共享）域 使用 Model 类型的形参@RequestMapping(&quot;/attr/request/model&quot;)@ResponseBodypublic String testAttrRequestModel( // 在形参位置声明Model类型变量，用于存储模型数据 Model model) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 model.addAttribute(&quot;requestScopeMessageModel&quot;,&quot;i am very happy[model]&quot;); return &quot;target&quot;;&#125; 使用 ModelMap 类型的形参@RequestMapping(&quot;/attr/request/model/map&quot;)@ResponseBodypublic String testAttrRequestModelMap( // 在形参位置声明ModelMap类型变量，用于存储模型数据 ModelMap modelMap) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;); return &quot;target&quot;;&#125; 使用 Map 类型的形参@RequestMapping(&quot;/attr/request/map&quot;)@ResponseBodypublic String testAttrRequestMap( // 在形参位置声明Map类型变量，用于存储模型数据 Map&lt;String, Object&gt; map) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;); return &quot;target&quot;;&#125; 使用原生 request 对象@RequestMapping(&quot;/attr/request/original&quot;)@ResponseBodypublic String testAttrOriginalRequest( // 拿到原生对象，就可以调用原生方法执行各种操作 HttpServletRequest request) &#123; request.setAttribute(&quot;requestScopeMessageOriginal&quot;, &quot;i am very happy[original]&quot;); return &quot;target&quot;;&#125; 使用 ModelAndView 对象@RequestMapping(&quot;/attr/request/mav&quot;)public ModelAndView testAttrByModelAndView() &#123; // 1.创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 2.存入模型数据 modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;); // 3.设置视图名称 modelAndView.setViewName(&quot;target&quot;); return modelAndView;&#125; 2.6.3 Session级别属性（共享）域@RequestMapping(&quot;/attr/session&quot;)@ResponseBodypublic String testAttrSession(HttpSession session) &#123; //直接对session对象操作,即对会话范围操作! return &quot;target&quot;;&#125; 2.6.4 Application级别属性（共享）域解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！ @Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/attr/application&quot;)@ResponseBodypublic String attrApplication() &#123; servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;); return &quot;target&quot;;&#125; 三、SpringMVC响应数据3.1 handler方法分析理解handler方法的作用和组成： /** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: * 1.接收请求参数(param,json,pathVariable,共享域等) * 2.调用业务逻辑 * 3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 * 1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) * 2.调用业务: &#123; 方法体 可以向后调用业务方法 service.xx() &#125; * 3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收)&#123; 调用业务方法 返回的结果 （页面跳转，返回数据（json）） return 简化响应前端数据;&#125; 总结： 请求数据接收，我们都是通过handler的形参列表 &#x20; 前端数据响应，我们都是通过handler的return关键字快速处理！ &#x20; springmvc简化了参数接收和响应！ 3.2 页面跳转控制3.2.1 快速返回模板视图 开发模式回顾 在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。 前后端分离模式：[重点] 后端只写三层架构, 只需要接收json并响应 指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。 混合开发模式： 浏览器请求时, controller层将数据放到共享域中, 前端动态页面从共享域中获取数据最终把文件返回给浏览器, 前后端混合在一起. 这种只能将数据返回给html 指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。 对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！ jsp技术了解 JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。 JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。 JSP 的主要特点包括： 简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。 高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。 多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。 总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。 准备jsp页面和依赖 pom.xml依赖 &lt;!-- jsp需要依赖! jstl--&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; jsp页面创建 建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！ 位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 快速响应模版页面 配置jsp视图解析器@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125;&#125; handler返回视图/** * 跳转到提交文件页面 /save/jump * * 如果要返回jsp页面! * 1.方法返回值改成字符串类型 * 2.返回逻辑视图名即可 * &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; * + 逻辑视图名 + * &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; */@GetMapping(&quot;jump&quot;)public String jumpJsp(Model model)&#123; System.out.println(&quot;FileController.jumpJsp&quot;); model.addAttribute(&quot;msg&quot;,&quot;request data!!&quot;); return &quot;home&quot;;&#125; 3.2.2 转发和重定向在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 redirect 或者 forward 关键字来实现重定向。 @RequestMapping(&quot;/redirect-demo&quot;)public String redirectDemo() &#123; // 重定向到 /demo 路径 return &quot;redirect:/demo&quot;;&#125;@RequestMapping(&quot;/forward-demo&quot;)public String forwardDemo() &#123; // 转发到 /demo 路径 return &quot;forward:/demo&quot;;&#125;//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！ 总结： 将方法的返回值，设置String类型 转发使用forward关键字，重定向使用redirect关键字 关键字: &#x2F;路径 注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！ 3.3 返回JSON数据（重点）3.3.1 前置准备导入jackson依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 添加json数据转化器 @EnableWebMvc&#x20; //TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;&#125; 3.3.2 @ResponseBody 方法上使用@ResponseBody 可以在方法上使用 @ResponseBody注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！ 测试方法： @GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ResponseBodypublic Object handle() &#123; // ... return obj;&#125; 具体来说，@ResponseBody 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。 测试方法： @RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)@ResponseBody //返回的json数据直接返回给客户端public User getUser(@RequestBody User userParam) &#123; System.out.println(&quot;userParam = &quot; + userParam); User user = new User(); user.setAge(18); user.setName(&quot;John&quot;); //返回的对象,会使用jackson的序列化工具,转成json返回给前端! return user;&#125; 定义一个handler方法, 接收(声明ResquestBody注解), 请求体中的json数据转为实体对象, 然后返回一个Java对象(响应). 这个返回的对象由经理(Adapter)转为json字符串, 有了json注解不会找视图解析器, 直接放在响应体中返回 返回结果： 类上使用@ResponseBody 如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。 @ResponseBody //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; 3.3.3 @RestController类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。 RestController源码: @Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123; /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) * @since 4.0.1 */ @AliasFor(annotation = Controller.class) String value() default &quot;&quot;; &#125; 3.4 返回静态资源处理 静态资源概念 资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理。典型的静态资源包括： 纯HTML文件 图片 CSS文件 JavaScript文件 …… 静态资源访问和问题解决 springmvc内部处理请求时, 都是交给servlet, 然后servlet内部去找handlerMapping找资源, 静态资源不在handlerMapiing中, 所以找不到 web应用加入静态资源 手动构建确保编译 访问静态资源 问题分析 DispatcherServlet 的 url-pattern 配置的是“&#x2F;” url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理 对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法 现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404 问题解决 在 SpringMVC 配置配置类： @EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 再次测试访问图片： CEO在找handlerMapping时如果找不到, 就会去二秘书 DefaultServletHander 新的问题：其他原本正常的handler请求访问不了了 handler无法访问 解决方案： @EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器 四、RESTFul风格设计和实战 后端在使用时总会有几个问题: 使用什么路径 使用哪种方式传递参数 使用哪种请求方式 而RestFul -&gt;就是解决这些问题的, 他是一种标准解决方案 4.1 RESTFul风格概述4.1.1 RESTFul风格简介 RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。 通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。 总而言之，RESTful 是&#x3D;&#x3D;一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！&#x3D;&#x3D; 为什么说RestFul是最标准的方案: 设计者是Http协议规范者之一 HTTP在设计之初有不同的请求方案, 但是后面使用时并没有按照设计者的意图使用, 导致不规范 设计者提出了RestFul, 教给我们使用 学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！ 4.1.2 RESTFul风格特点 每一个URI代表1种资源（URI 是名词）； 客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源； 资源的表现形式是XML或者JSON； 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。 4.1.3 RESTFul风格设计规范 HTTP协议请求方式要求 REST 风格主张在项目设计、开发过程中，具体的操作符合HTTP协议定义的请求方式的语义。 操作 请求方式 查询操作 GET 保存操作 POST 删除操作 DELETE 更新操作 PUT URL路径风格要求 REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！ 使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！ 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET 总结 根据接口的具体动作，选择具体的HTTP协议请求方式 路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！ 4.1.4 RESTFul风格好处 含蓄，安全 使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。 风格统一 URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。 无状态 在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。 严谨，规范 严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。 简洁，优雅 过去做增删改查操作需要设计4个不同的URL，现在一个就够了。 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET 丰富的语义 通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。 http://localhost:8080/shop http://localhost:8080/shop/product http://localhost:8080/shop/product/cellPhone http://localhost:8080/shop/product/cellPhone/iPhone 4.2 RESTFul风格实战4.2.1 需求分析 数据结构： User {id 唯一标识,name 用户名，age 用户年龄} 功能分析 用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10） 保存用户功能 根据用户id查询用户详情功能 根据用户id更新用户数据功能 根据用户id删除用户数据功能 多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10） 4.2.2 RESTFul风格接口设计 接口设计 功能 接口和请求方式 请求参数 返回值 分页查询 GET &#x2F;user page&#x3D;1&amp;size&#x3D;10 { 响应数据 } 用户添加 POST &#x2F;user { user 数据 } {响应数据} 用户详情 GET &#x2F;user&#x2F;1 路径参数 {响应数据} 用户更新 PUT &#x2F;user { user 更新数据} {响应数据} 用户删除 DELETE &#x2F;user&#x2F;1 路径参数 {响应数据} 条件模糊 GET &#x2F;user&#x2F;search page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字 {响应数据} 问题讨论 为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？ 误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！ 在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。 对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。 而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。 此外，还有一些通用的原则可以遵循： 路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。 请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。 对于敏感信息，最好使用 POST 和请求体来传递参数。 4.2.3 后台接口实现准备用户实体类： package com.atguigu.pojo;/** * projectName: com.atguigu.pojo * 用户实体类 */public class User &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 准备用户Controller: /** * projectName: com.atguigu.controller * * description: 用户模块的控制器 */@RequestMapping(&quot;user&quot;)@RestControllerpublic class UserController &#123; /** * 模拟分页查询业务接口 */ @GetMapping public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size); System.out.println(&quot;分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户保存业务接口 */ @PostMapping public Object saveUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户保存业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户详情业务接口 */ @PostMapping(&quot;/&#123;id&#125;&quot;) public Object detailUser(@PathVariable Integer id)&#123; System.out.println(&quot;id = &quot; + id); System.out.println(&quot;用户详情业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户更新业务接口 */ @PutMapping public Object updateUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户更新业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟条件分页查询业务接口 */ @GetMapping(&quot;search&quot;) public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size, @RequestParam(name = &quot;keyword&quot;,required= false)String keyword)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size + &quot;, keyword = &quot; + keyword); System.out.println(&quot;条件分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125;&#125; 五、SpringMVC其他扩展5.1 全局异常处理机制5.1.1 异常处理两种方式开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。 对于异常的处理，一般分为两种方式： 编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。 声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 @Throws 或 @ExceptionHandler），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。 站在宏观角度来看待声明式事务处理： 整个项目从架构这个层面设计的异常处理的统一机制和规范。 一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。 使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！ 5.1.2 基于注解异常声明异常处理 声明异常处理控制器类 异常处理控制类，统一定义异常处理handler方法！ /** * projectName: com.atguigu.execptionhandler * * description: 全局异常处理器,内部可以定义异常处理Handler! *//** * @RestControllerAdvice = @ControllerAdvice + @ResponseBody * @ControllerAdvice 代表当前类的异常处理controller! */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; &#125; 声明异常处理hander方法 异常处理handler方法和普通的handler方法参数接收和响应都一致！ 只不过异常处理handler方法要映射异常，发生对应的异常会调用！ 普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！ /** * 异常处理handler * @ExceptionHandler(HttpMessageNotReadableException.class) * 该注解标记异常处理Handler,并且指定发生异常调用该方法! * * * @param e 获取异常对象! * @return 返回handler处理结果! */@ExceptionHandler(HttpMessageNotReadableException.class)public Object handlerJsonDateException(HttpMessageNotReadableException e)&#123; return null;&#125;/** * 当发生空指针异常会触发此方法! * @param e * @return */@ExceptionHandler(NullPointerException.class)public Object handlerNullException(NullPointerException e)&#123; return null;&#125;/** * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! * 具体异常处理Handler优先级更高! * 例如: 发生NullPointerException异常! * 会触发handlerNullException方法,不会触发handlerException方法! * @param e * @return */@ExceptionHandler(Exception.class)public Object handlerException(Exception e)&#123; return null;&#125; 配置文件扫描控制器类配置 确保异常处理控制类被扫描 &lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) 5.2 拦截器使用5.2.1 拦截器概念拦截器和过滤器解决问题 生活中 为了提高乘车效率，在乘客进入站台前统一检票 程序中 在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测 拦截器 Springmvc VS 过滤器 javaWeb： 相似点 拦截：必须先把请求拦住，才能执行后续操作 过滤：拦截器或过滤器存在的意义就是对请求进行统一处理 放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源 不同点 工作平台不同 过滤器工作在 Servlet 容器中 拦截器工作在 SpringMVC 的基础上 拦截的范围 过滤器：能够拦截到的最大范围是整个 Web 应用 拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求 IOC 容器支持 过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的 拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持 选择： 功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。 经过DispatcherServlet后, 先经过拦截器在去找其他Handler 5.2.2 拦截器使用 创建拦截器类 public class Process01Interceptor implements HandlerInterceptor &#123; // if( ! preHandler())&#123;return;&#125; // 在处理请求的目标 handler 方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler); System.out.println(&quot;Process01Interceptor.preHandle&quot;); // 返回true：放行 // 返回false：不放行 return true; &#125; // 在目标 handler 方法之后，handler报错不执行! @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, modelAndView = &quot; + modelAndView); System.out.println(&quot;Process01Interceptor.postHandle&quot;); &#125; // 渲染视图之后执行(最后),一定执行! @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, ex = &quot; + ex); System.out.println(&quot;Process01Interceptor.afterCompletion&quot;); &#125;&#125; 拦截器方法拦截位置： 修改配置类添加拦截器 @EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器 @Configuration @ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) //TODO: 进行controller扫描 //WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现 public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125; &#125;3. 配置详解 1. 默认拦截全部 ```java @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125; 精准配置 @Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);&#125; 排除配置 //添加拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;); //排除匹配,排除应该在匹配的范围内排除 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内 registry.addInterceptor(new Process01Interceptor()) .addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;) .excludePathPatterns(&quot;/common/request/tow&quot;);&#125; 多个拦截器执行顺序 preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。 postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。(内部是倒序遍历拦截器的List) afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。(源码中也是倒序遍历) 5.3 参数校验 例如实现一个登录功能: 前端传来账号 controller接收, 之后逐层执行, 其中有参数校验 在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。 校验概述 JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。 注解 规则 @Null 标注值必须为 null @NotNull 标注值不可为 null @AssertTrue 标注值必须为 true @AssertFalse 标注值必须为 false @Min(value) 标注值必须大于或等于 value @Max(value) 标注值必须小于或等于 value @DecimalMin(value) 标注值必须大于或等于 value @DecimalMax(value) 标注值必须小于或等于 value @Size(max,min) 标注值大小必须在 max 和 min 限定的范围内 @Digits(integer,fratction) 标注值值必须是一个数字，且必须在可接受的范围内 @Past 标注值只能用于日期型，且必须是过去的日期 @Future 标注值只能用于日期型，且必须是将来的日期 @Pattern(value) 标注值必须符合指定的正则表达式 JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解： 注解 规则 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————- ——————– @Email 标注值必须是格式正确的 Email 地址 @Length 标注值字符串大小必须在指定的范围内 @NotEmpty 标注值字符串不能是空字符串 @Range 标注值必须在指定的范围内 Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。 配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。 操作演示 导入依赖 &lt;!-- 校验注解 --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;!-- 校验注解实现--&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt; 应用校验注解 import jakarta.validation.constraints.Email;import jakarta.validation.constraints.Min;import org.hibernate.validator.constraints.Length;/** * projectName: com.atguigu.pojo */public class User &#123; //age 1 &lt;= age &lt; = 150 @Min(10) private int age; //name 3 &lt;= name.length &lt;= 6 @Length(min = 3,max = 10) private String name; //email 邮箱格式 @Email private String email; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; handler标记和绑定错误收集 @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; /** * @Validated 代表应用校验注解! 必须添加! */ @PostMapping(&quot;save&quot;) public Object save(@Validated @RequestBody User user, //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出! BindingResult result)&#123; //判断是否有信息绑定错误! 有可以自行处理! if (result.hasErrors())&#123; System.out.println(&quot;错误&quot;); String errorMsg = result.getFieldError().toString(); return errorMsg; &#125; //没有,正常处理业务即可 System.out.println(&quot;正常&quot;); return user; &#125;&#125; 测试效果 易混总结 @NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。 @NotNull (包装类型不为null) @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。 @NotEmpty (集合类型长度大于0) @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。 @NotBlank （字符串，不为null，切不为” “字符串） @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。 六、SpringMVC总结 核心点 掌握目标 springmvc框架 主要作用、核心组件、调用流程 简化参数接收 路径设计、参数接收、请求头接收、cookie接收 简化数据响应 模板页面、转发和重定向、JSON数据、静态资源 restful风格设计 主要作用、具体规范、请求方式和请求参数选择 功能扩展 全局异常处理、拦截器、参数校验注解","tags":["Spring","JavaWeb","SpringMVC"],"categories":["技术","记录"]},{"title":"MyBatis 学习","path":"/2023/02/13/三、MyBatis实践：提高持久层数据处理效率/","content":"三、MyBatis实践：提高持久层数据处理效率一、Mybatis简介1.1 简介https://mybatis.org/mybatis-3/zh/index.html MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 社区会持续更新开源项目，版本会不断变化，我们不必每个小版本都追，关注重大更新的大版本升级即可。 本课程使用：3.5.11版本 1.2 持久层框架对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生成的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于 Hibernate，但是完全能够接收 开发效率：Hibernate&gt;Mybatis&gt;JDBC 运行效率：JDBC&gt;Mybatis&gt;Hibernate 1.3 快速入门（基于Mybatis3方式） 准备数据模型 CREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`( emp_id INT AUTO_INCREMENT, emp_name CHAR(100), emp_salary DOUBLE(10,5), PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;tom&quot;,200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;jerry&quot;,666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;andy&quot;,777.77); 项目搭建和准备 项目搭建 依赖导入 pom.xml 实体类准备 public class Employee &#123; private Integer empId; private String empName; private Double empSalary; //getter | setter&#125; 准备Mapper接口和MapperXML文件 MyBatis 框架下，SQL语句编写位置发生改变，从原来的Java类，改成XML或者注解定义！ 推荐在XML文件中编写SQL语句，让用户能更专注于 SQL 代码，不用关注其他的JDBC代码。 如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码！！ 一般编写SQL语句的文件命名：XxxMapper.xml Xxx一般取表名！！ Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，我们不需要提供实现类，具体的SQL写到对应的Mapper文件，该用法的思路如下图所示： 定义mapper接口 包：com.atguigu.mapper package com.atguigu.mapper;import com.atguigu.pojo.Employee;/** * t_emp表对应数据库SQL语句映射接口! * 接口只规定方法,参数和返回值! * mapper.xml中编写具体SQL语句! */public interface EmployeeMapper &#123; /** * 根据员工id查询员工数据方法 * @param empId 员工id * @return 员工实体对象 */ Employee selectEmployee(Integer empId); &#125; 定义mapper xml 位置： resources&#x2F;mappers&#x2F;EmployeeMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.EmployeeMapper&quot;&gt; &lt;!-- 查询使用 select标签 id = 方法名 resultType = 返回值类型 标签内编写SQL语句 --&gt; &lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.pojo.Employee&quot;&gt; &lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp where emp_id = #&#123;empId&#125; &lt;/select&gt;&lt;/mapper&gt; 注意： 方法名和SQL的id一致 方法返回值和resultType一致 方法的参数和SQL的参数一致 接口的全类名和映射配置文件的名称空间一致 准备MyBatis配置文件 mybatis框架配置文件： 数据库连接信息，性能配置，mapper.xml配置等！ 习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 运行和测试 /** * projectName: com.atguigu.test * * description: 测试类 */public class MyBatisTest &#123; @Test public void testSelectEmployee() throws IOException &#123; // 1.创建SqlSessionFactory对象 // ①声明Mybatis全局配置文件的路径 String mybatisConfigFilePath = &quot;mybatis-config.xml&quot;; // ②以输入流的形式加载Mybatis配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatisConfigFilePath); // ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2.使用SqlSessionFactory对象开启一个会话 SqlSession session = sessionFactory.openSession(); // 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术) EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); // 4. 调用代理类方法既可以触发对应的SQL语句 Employee employee = employeeMapper.selectEmployee(1); System.out.println(&quot;employee = &quot; + employee); // 4.关闭SqlSession session.commit(); //提交事务 [DQL不需要,其他需要] session.close(); //关闭会话 &#125;&#125; 说明： SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂”。 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。 SqlSession和HttpSession区别 HttpSession：工作在Web服务器上，属于表述层。 代表浏览器和Web服务器之间的会话。 SqlSession：不依赖Web服务器，属于持久化层。 代表Java程序和数据库之间的会话。 &#x3D;&#x3D;SqlSessionFactory中生产出SqlSession, 从中进行数据库操作, 相当于查找到sql语句&#x3D;&#x3D; 二、MyBatis基本使用 ibatis方式通过传入参数完成sql操作 Mybatis中, SqlSession提供一个方法, 根据接口生成代理对象(getMapper), 代理方法内部调用iBatis实现. 我们只需要调用代理对象的方法 id和namespace一致时, Mapper.java接口才能找到 2.1 向SQL语句传参2.1.1 mybatis日志输出配置mybatis配置文件设计标签和顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 我们可以在mybatis的配置文件使用settings标签设置，输出运过程SQL日志！ 通过查看日志，我们可以判定#{} 和 ${}的输出效果！ settings设置项： logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 日志配置： &lt;settings&gt; &lt;!-- SLF4J 选择slf4j输出！ --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;&lt;/settings&gt; 2.1.2 #{}形式Mybatis会将SQL语句中的#{}转换为问号占位符。 2.1.3 ${}形式${}形式传参，&#x3D;&#x3D;底层Mybatis做的是字符串拼接操作。&#x3D;&#x3D; 通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用 结论：实际开发中，能用#{}实现的，肯定不用${}。 特殊情况： 动态的不是值，是列名或者关键字，需要使用${}拼接 //注解方式传入参数！！@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 2.2 数据输入2.2.1 Mybatis总体机制概括 2.2.2 概念说明这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。 简单类型：只包含一个值的数据类型 基本数据类型：int、byte、short、double、…… 基本数据类型的包装类型：Integer、Character、Double、…… 字符串类型：String 复杂类型：包含多个值的数据类型 实体类类型：Employee、Department、…… 集合类型：List、Set、Map、…… 数组类型：int[]、String[]、…… 复合类型：List&lt;Employee&gt;、实体类中包含集合…… 2.2.3 单个简单类型参数Mapper接口中抽象方法的声明 Employee selectEmployee(Integer empId); SQL语句 &lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名。 2.2.4 实体类类型参数Mapper接口中抽象方法的声明 int insertEmployee(Employee employee); SQL语句 &lt;insert id=&quot;insertEmployee&quot;&gt; insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; 对应关系 结论 &#x3D;&#x3D;Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置。&#x3D;&#x3D; 2.2.5 零散的简单类型数据零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称： Mapper接口中抽象方法的声明 int updateEmployee(@Param(&quot;empId&quot;) Integer empId,@Param(&quot;empSalary&quot;) Double empSalary); SQL语句 &lt;update id=&quot;updateEmployee&quot;&gt; update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;&lt;/update&gt; 对应关系 2.2.6 Map类型参数Mapper接口中抽象方法的声明 int updateEmployeeByMap(Map&lt;String, Object&gt; paramMap); SQL语句 &lt;update id=&quot;updateEmployeeByMap&quot;&gt; update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;&lt;/update&gt; junit测试 private SqlSession session;//junit5会在每一个@Test方法前执行@BeforeEach方法@BeforeEachpublic void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession();&#125;@Testpublic void testUpdateEmpNameByMap() &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;empSalaryKey&quot;, 999.99); paramMap.put(&quot;empIdKey&quot;, 5); int result = mapper.updateEmployeeByMap(paramMap); log.info(&quot;result = &quot; + result);&#125;//junit5会在每一个@Test方法后执行@@AfterEach方法@AfterEachpublic void clear() &#123; session.commit(); session.close();&#125; 对应关系 #{}中写Map中的key 使用场景 &#x3D;&#x3D;有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。&#x3D;&#x3D; 2.3数据输出2.3.1 输出概述数据输出总体上有两种形式： 增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可 查询操作的查询结果 我们需要做的是，指定查询的输出数据类型即可！ 并且插入场景下，实现主键数据回显示！ 2.3.2 单个简单类型Mapper接口中的抽象方法 int selectEmpCount(); SQL语句 &lt;select id=&quot;selectEmpCount&quot; resultType=&quot;int&quot;&gt; select count(*) from t_emp&lt;/select&gt; Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。 junit测试 @Testpublic void testEmpCount() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); int count = employeeMapper.selectEmpCount(); log.info(&quot;count = &quot; + count);&#125; 细节解释： select标签，通过resultType指定查询返回值类型！ resultType &#x3D; “全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可” 别名问题： https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： &lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： &lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt; &lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： @Alias(&quot;author&quot;)public class Author &#123; ...&#125; 下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。 别名 映射的类型 _byte byte _char (since 3.5.10) char _character (since 3.5.10) char _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte char (since 3.5.10) Character character (since 3.5.10) Character long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal biginteger BigInteger object Object object[] Object[] map Map hashmap HashMap list List arraylist ArrayList collection Collection 2.3.3 返回实体类对象Mapper接口的抽象方法 Employee selectEmployee(Integer empId); SQL语句 &lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt; &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来。 增加全局配置自动识别对应关系 在 Mybatis 全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名 &lt;!-- 在全局范围内对Mybatis进行配置 --&gt;&lt;settings&gt; &lt;!-- 具体配置 --&gt; &lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt; &lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt; &lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt; &lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 2.3.4 返回Map类型适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。 Mapper接口的抽象方法 Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); SQL语句 &lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;&lt;select id=&quot;selectEmpNameAndMaxSalary&quot; resultType=&quot;map&quot;&gt; SELECT emp_name 员工姓名, emp_salary 员工工资, (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资 FROM t_emp WHERE emp_salary=( SELECT MAX(emp_salary) FROM t_emp )&lt;/select&gt; junit测试 @Testpublic void testQueryEmpNameAndSalary() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; resultMap = employeeMapper.selectEmpNameAndMaxSalary(); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = resultMap.entrySet(); for (Map.Entry&lt;String, Object&gt; entry : entrySet) &#123; String key = entry.getKey(); Object value = entry.getValue(); log.info(key + &quot;=&quot; + value); &#125;&#125; 2.3.5 返回List类型查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。 Mapper接口中抽象方法 List&lt;Employee&gt; selectAll(); SQL语句 &lt;!-- List&lt;Employee&gt; selectAll(); --&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp&lt;/select&gt; junit测试 @Testpublic void testSelectAll() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); List&lt;Employee&gt; employeeList = employeeMapper.selectAll(); for (Employee employee : employeeList) &#123; log.info(&quot;employee = &quot; + employee); &#125;&#125; 2.3.6 返回主键值 &#x3D;&#x3D;自增长类型主键&#x3D;&#x3D; Mapper接口中的抽象方法 int insertEmployee(Employee employee); SQL语句 &lt;!-- int insertEmployee(Employee employee); --&gt;&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;&lt;insert id=&quot;insertEmployee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;empId&quot;&gt; insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; junit测试 @Testpublic void testSaveEmp() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Employee employee = new Employee(); employee.setEmpName(&quot;john&quot;); employee.setEmpSalary(666.66); employeeMapper.insertEmployee(employee); log.info(&quot;employee.getEmpId() = &quot; + employee.getEmpId());&#125; 注意 Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。 非自增长类型主键 而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！ 使用 selectKey 帮助插入UUID作为字符串类型主键示例： &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() as id &lt;/selectKey&gt; INSERT INTO user (id, username, password) VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125; )&lt;/insert&gt; 在上例中，我们定义了一个 insertUser 的插入语句来将 User 对象插入到 user 表中。我们使用 selectKey 来查询 UUID 并设置到 id 字段中。 通过 keyProperty 属性来指定查询到的 UUID 赋值给对象中的 id 属性，而 resultType 属性指定了 UUID 的类型为 java.lang.String。 需要注意的是，我们将 selectKey 放在了插入语句的前面，这是因为 MySQL 在 insert 语句中只支持一个 select 子句，而 selectKey 中查询 UUID 的语句就是一个 select 子句，因此我们需要将其放在前面。 最后，在将 User 对象插入到 user 表中时，我们直接使用对象中的 id 属性来插入主键值。 使用这种方式，我们可以方便地插入 UUID 作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。 2.3.7 实体类属性和数据库字段对应关系 别名对应 将字段的别名设置成和实体类属性一致。 &lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt; &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 关于实体类属性的约定：getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。 全局配置自动识别驼峰式命名规则 在Mybatis全局配置文件加入如下配置： &lt;!-- 使用settings对Mybatis全局进行设置 --&gt;&lt;settings&gt; &lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; SQL语句中可以不使用别名 &lt;!-- Employee selectEmployee(Integer empId); --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 使用resultMap 使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系 &lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;&lt;resultMap id=&quot;selectEmployeeByRMResultMap&quot; type=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt; &lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt; &lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt; &lt;result column=&quot;emp_salary&quot; property=&quot;empSalary&quot;/&gt;&lt;/resultMap&gt;&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;&lt;select id=&quot;selectEmployeeByRM&quot; resultMap=&quot;selectEmployeeByRMResultMap&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 2.4 CRUD强化练习 准备数据库数据 首先，我们需要准备一张名为 user 的表。该表包含字段 id（主键）、username、password。创建SQL如下： CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(50) NOT NULL, `password` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实体类准备 接下来，我们需要定义一个实体类 User，来对应 user 表的一行数据。 @Data //lombokpublic class User &#123; private Integer id; private String username; private String password;&#125; Mapper接口定义 定义一个 Mapper 接口 UserMapper，并在其中添加 user 表的增、删、改、查方法。 public interface UserMapper &#123; int insert(User user); int update(User user); int delete(Integer id); User selectById(Integer id); List&lt;User&gt; selectAll();&#125; MapperXML编写 在 resources &#x2F;mappers目录下创建一个名为 UserMapper.xml 的 XML 文件，包含与 Mapper 接口中相同的五个 SQL 语句，并在其中，将查询结果映射到 User 实体中。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;!-- 定义一个插入语句，并获取主键值 --&gt; &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO user(username, password) VALUES(#&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot;&gt; UPDATE user SET username=#&#123;username&#125;, password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;delete&quot;&gt; DELETE FROM user WHERE id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- resultType使用user别名，稍后需要配置！--&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;user&quot;&gt; SELECT id, username, password FROM user WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;!-- resultType返回值类型为集合，所以只写范型即可！ --&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; SELECT id, username, password FROM user &lt;/select&gt; &lt;/mapper&gt; MyBatis配置文件 位置：resources: mybatis-config.xml&#x20; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 效果测试 package com.atguigu.test;import com.atguigu.mapper.UserMapper;import com.atguigu.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;import java.util.List;/** * projectName: com.atguigu.test */public class MyBatisTest &#123; private SqlSession session; // junit会在每一个@Test方法前执行@BeforeEach方法 @BeforeEach public void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession(); &#125; @Test public void createTest() &#123; User user = new User(); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.insert(user); System.out.println(user); &#125; @Test public void updateTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectById(1); user.setUsername(&quot;root&quot;); user.setPassword(&quot;111111&quot;); userMapper.update(user); user = userMapper.selectById(1); System.out.println(user); &#125; @Test public void deleteTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.delete(1); User user = userMapper.selectById(1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void selectByIdTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectById(1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void selectAllTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.selectAll(); System.out.println(&quot;userList = &quot; + userList); &#125; // junit会在每一个@Test方法后执行@@AfterEach方法 @AfterEach public void clear() &#123; session.commit(); session.close(); &#125;&#125; 2.5 mapperXML标签总结MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。 select标签： MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单： &lt;select id=&quot;selectPerson&quot; resultType=&quot;hashmap&quot; resultMap=&quot;自定义结构&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125; &lt;/select&gt; 这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号：#{id} ${key} MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： // 近似的 JDBC 代码，非 MyBatis 代码...String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); select 元素允许你配置很多属性来配置每条语句的行为细节： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 insert, update 和 delete标签： 数据变更语句 insert，update 和 delete 的实现非常接近： &lt;insert id=&quot;insertAuthor&quot; statementType=&quot;PREPARED&quot; keyProperty=&quot;&quot; keyColumn=&quot;&quot; useGeneratedKeys=&quot;&quot; timeout=&quot;20&quot;&gt;&lt;update id=&quot;updateAuthor&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt;&lt;delete id=&quot;deleteAuthor&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 三、MyBatis多表映射3.1 多表映射概念 我们定义sql并指定返回的结果; mybatis 执行我们编写的sql, 根据我们想要的结果返回结果集映射; mybatis使用代理接口, 底层执行相应的方法. &#x3D;&#x3D;多表查询时我们需要设计存储数据的实体类, 类中除了自己的属性外, 还有其他类对象, 所以自己定义结果集映射&#x3D;&#x3D; 多表查询结果映射思路 上面课程中，我全面讲解了单表的mybatis操作！但是开发中更多的是多表查询需求，这种情况我们如何让进行处理？ MyBatis 思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序查询需求，那就太好了，而 ResultMap 就是 MyBatis 就是完美答案。&#x20; 官方例子：我们如何映射下面这个语句？&#x20; &lt;!-- 非常复杂的语句 --&gt;&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。 我们先来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。 虽然它看起来令人望而生畏，但其实非常简单。&#x20; &lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt; &lt;/constructor&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt; &lt;/association&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt; &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt; &lt;/collection&gt; &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt; 你现在可能看不懂，接下来我们要学习将多表查询结果使用ResultMap标签映射到实体类对象上！ 我们的学习目标： &#x3D;&#x3D;多表查询语句使用&#x3D;&#x3D; &#x3D;&#x3D;多表结果承接实体类设计&#x3D;&#x3D; &#x3D;&#x3D;使用ResultMap完成多表结果映射&#x3D;&#x3D; 实体类设计方案 多表关系回顾：（双向查看） 一对一 夫妻关系，人和身份证号 一对多| 多对一 用户和用户的订单，锁和钥匙 多对多 老师和学生，部门和员工实体类设计关系(查询)：（单向查看） 对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系 实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！ 例如： public class Customer &#123; private Integer customerId; private String customerName;&#125;public class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系&#125; 对多: 用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系： 实体类设计：对多关系下，类中只要包含对方类型集合属性即可！ public class Customer &#123; private Integer customerId; private String customerName; private List&lt;Order&gt; orderList;// 体现的是对多的关系&#125;public class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系 &#125;//查询客户和客户对应的订单集合 不要管! 多表结果实体类设计小技巧： &#x3D;&#x3D;对一，属性中包含对方对象&#x3D;&#x3D; &#x3D;&#x3D;对多，属性中包含对方对象集合&#x3D;&#x3D; 只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！ 无论多少张表联查，实体类设计都是两两考虑! 在查询映射的时候，只需要关注本次查询相关的属性！例如：查询订单和对应的客户，就不要关注客户中的订单集合！ 多表映射案例准备 数据库： CREATE TABLE `t_customer` (`customer_id` INT NOT NULL AUTO_INCREMENT, `customer_name` CHAR(100), PRIMARY KEY (`customer_id`) );CREATE TABLE `t_order` ( `order_id` INT NOT NULL AUTO_INCREMENT, `order_name` CHAR(100), `customer_id` INT, PRIMARY KEY (`order_id`) ); INSERT INTO `t_customer` (`customer_name`) VALUES (&#x27;c01&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o1&#x27;, &#x27;1&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o2&#x27;, &#x27;1&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o3&#x27;, &#x27;1&#x27;); 实际开发时，一般在开发过程中，不给数据库表设置外键约束。原因是避免调试不方便。一般是功能开发完成，再加外键约束检查是否有bug。 实体类设计： 稍后会进行订单关联客户查询，也会进行客户关联订单查询，所以在这先练习设计 @Datapublic class Customer &#123; private Integer customerId; private String customerName; private List&lt;Order&gt; orderList;// 体现的是对多的关系 &#125; @Datapublic class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系 &#125; 3.2 对一映射 需求说明 根据ID查询订单，以及订单关联的用户的信息！ OrderMapper接口 public interface OrderMapper &#123; Order selectOrderWithCustomer(Integer orderId);&#125; OrderMapper.xml配置文件 &lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;&lt;resultMap id=&quot;selectOrderWithCustomerResultMap&quot; type=&quot;order&quot;&gt; &lt;!-- 先设置Order自身属性和字段的对应关系 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt; &lt;!-- 使用association标签配置“对一”关联关系 --&gt; &lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt; &lt;!-- javaType属性：一的一端类的全类名 --&gt; &lt;association property=&quot;customer&quot; javaType=&quot;customer&quot;&gt; &lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;&lt;select id=&quot;selectOrderWithCustomer&quot; resultMap=&quot;selectOrderWithCustomerResultMap&quot;&gt; SELECT order_id,order_name,c.customer_id,customer_name FROM t_order o LEFT JOIN t_customer c ON o.customer_id=c.customer_id WHERE o.order_id=#&#123;orderId&#125;&lt;/select&gt; 对应关系可以参考下图： Mybatis全局注册Mapper文件 &lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt; &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt; &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 @Slf4jpublic class MyBatisTest &#123; private SqlSession session; // junit会在每一个@Test方法前执行@BeforeEach方法 @BeforeEach public void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession(); &#125; @Test public void testRelationshipToOne() &#123; OrderMapper orderMapper = session.getMapper(OrderMapper.class); // 查询Order对象，检查是否同时查询了关联的Customer对象 Order order = orderMapper.selectOrderWithCustomer(2); log.info(&quot;order = &quot; + order); &#125; // junit会在每一个@Test方法后执行@@AfterEach方法 @AfterEach public void clear() &#123; session.commit(); session.close(); &#125;&#125; 关键词 在“对一”关联关系中，我们的配置比较多，但是关键词就只有：association和javaType 3.3 对多映射 需求说明 查询客户和客户关联的订单信息！ CustomerMapper接口 public interface CustomerMapper &#123; Customer selectCustomerWithOrderList(Integer customerId);&#125; CustomerMapper.xml文件 &lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;&lt;resultMap id=&quot;selectCustomerWithOrderListResultMap&quot; type=&quot;customer&quot;&gt; &lt;!-- 映射Customer本身的属性 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt; &lt;!-- collection标签：映射“对多”的关联关系 --&gt; &lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt; &lt;!-- ofType属性：集合属性中元素的类型 --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot;&gt; &lt;!-- 映射Order的属性 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;&lt;select id=&quot;selectCustomerWithOrderList&quot; resultMap=&quot;selectCustomerWithOrderListResultMap&quot;&gt; SELECT c.customer_id,c.customer_name,o.order_id,o.order_name FROM t_customer c LEFT JOIN t_order o ON c.customer_id=o.customer_id WHERE c.customer_id=#&#123;customerId&#125;&lt;/select&gt; 对应关系可以参考下图： Mybatis全局注册Mapper文件 &lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt; &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt; &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt; &lt;mapper resource=&quot;mappers/CustomerMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 @Testpublic void testRelationshipToMulti() &#123; CustomerMapper customerMapper = session.getMapper(CustomerMapper.class); // 查询Customer对象同时将关联的Order集合查询出来 Customer customer = customerMapper.selectCustomerWithOrderList(1); log.info(&quot;customer.getCustomerId() = &quot; + customer.getCustomerId()); log.info(&quot;customer.getCustomerName() = &quot; + customer.getCustomerName()); List&lt;Order&gt; orderList = customer.getOrderList(); for (Order order : orderList) &#123; log.info(&quot;order = &quot; + order); &#125;&#125; 关键词 在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType” 3.4 多表映射总结3.4.1 多表映射优化 setting属性 属性含义 可选值 默认值 autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL 我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！ 修改mybati-sconfig.xml: &lt;!--开启resultMap自动映射 --&gt;&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; 修改teacherMapper.xml &lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;tId&quot; column=&quot;t_id&quot; /&gt; &lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;&lt;!-- &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; &gt; &lt;id property=&quot;sId&quot; column=&quot;s_id&quot; /&gt;&lt;!-- &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt; &lt;/collection&gt;&lt;/resultMap&gt; 对于多表查询来说, 本质只有一对一, 比如客户 订单 订单项三张表, 先是客户和订单, 然后再订单和订单项, 订单项的表和客户没有关系 先设计客户实体类, 包含一个订单的List, 再设计一个订单的实体类, 包含订单项的List 写三表查询的sql xml文件中配置resultMap, 再订单的collection中嵌套订单项的collection 3.4.2 多表映射总结 关联关系 配置项关键词 所在配置文件和具体位置 对一 association标签&#x2F;javaType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 对多 collection标签&#x2F;ofType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 四、MyBatis动态语句4.1 动态语句需求和简介经常遇到很多按照很多查询条件进行查询的情况，比如智联招聘的职位搜索等。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？ 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 4.2 if和where标签使用动态 SQL 最常见情景是根据条件包含 where &#x2F; if 子句的一部分。比如： &lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;&lt;select id=&quot;selectEmployeeByCondition&quot; resultType=&quot;employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp &lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt; &lt;where&gt; &lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt; &lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt; &lt;if test=&quot;empName != null&quot;&gt; &lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt; or emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 2000&quot;&gt; or emp_salary&gt;#&#123;empSalary&#125; &lt;/if&gt; &lt;!-- 第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;? 第二种情况：部分条件满足 WHERE emp_salary&gt;? 第三种情况：所有条件都不满足 没有where子句 --&gt; &lt;/where&gt;&lt;/select&gt; 4.3 set标签&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;&lt;update id=&quot;updateEmployeeDynamic&quot;&gt; update t_emp &lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt; &lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt; &lt;set&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125;, &lt;/if&gt; &lt;if test=&quot;empSalary &amp;lt; 3000&quot;&gt; emp_salary=#&#123;empSalary&#125;, &lt;/if&gt; &lt;/set&gt; where emp_id=#&#123;empId&#125; &lt;!-- 第一种情况：所有条件都满足 SET emp_name=?, emp_salary=? 第二种情况：部分条件满足 SET emp_salary=? 第三种情况：所有条件都不满足 update t_emp where emp_id=? 没有set子句的update语句会导致SQL语法错误 --&gt;&lt;/update&gt; 4.4 trim标签(了解)使用trim标签控制条件部分两端是否包含某些字符 prefix属性：指定要动态添加的前缀 suffix属性：指定要动态添加的后缀 prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值 suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值 &lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByTrim&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp &lt;!-- prefix属性指定要动态添加的前缀 --&gt; &lt;!-- suffix属性指定要动态添加的后缀 --&gt; &lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 3000&quot;&gt; emp_salary&gt;#&#123;empSalary&#125; and &lt;/if&gt; &lt;if test=&quot;empAge &amp;lt;= 20&quot;&gt; emp_age=#&#123;empAge&#125; or &lt;/if&gt; &lt;if test=&quot;empGender==&#x27;male&#x27;&quot;&gt; emp_gender=#&#123;empGender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4.5 choose&#x2F;when&#x2F;otherwise标签在多个分支条件中，仅执行一个。 从上到下依次执行条件判断 遇到的第一个满足条件的分支会被采纳 被采纳分支后面的分支都将不被考虑 如果所有的when分支都不满足，那么就执行otherwise分支 &lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByChoose&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where &lt;choose&gt; &lt;when test=&quot;empName != null&quot;&gt;emp_name=#&#123;empName&#125;&lt;/when&gt; &lt;when test=&quot;empSalary &amp;lt; 3000&quot;&gt;emp_salary &amp;lt; 3000&lt;/when&gt; &lt;otherwise&gt;1=1&lt;/otherwise&gt; &lt;/choose&gt; &lt;!-- 第一种情况：第一个when满足条件 where emp_name=? 第二种情况：第二个when满足条件 where emp_salary &lt; 3000 第三种情况：两个when都不满足 where 1=1 执行了otherwise --&gt;&lt;/select&gt; 4.6 foreach标签基本用法 用批量插入举例 &lt;!-- collection属性：要遍历的集合 item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象 separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符 open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串 close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串 index属性：这里起一个名字，便于后面引用 遍历List集合，这里能够得到List集合的索引值 遍历Map集合，这里能够得到Map集合的key --&gt;&lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;,&quot; open=&quot;values&quot; index=&quot;myIndex&quot;&gt; &lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt; (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)&lt;/foreach&gt; 批量更新时需要注意 上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置： atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true 对应的foreach标签如下： &lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;&lt;update id=&quot;updateEmployeeBatch&quot;&gt; &lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt; update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125; &lt;/foreach&gt;&lt;/update&gt; 关于foreach标签的collection属性 如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来： Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list] 在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。 4.7 sql片段抽取重复的SQL片段 &lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;&lt;sql id=&quot;mySelectSql&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp&lt;/sql&gt; 引用已抽取的SQL片段 &lt;!-- 使用include标签引用声明的SQL片段 --&gt;&lt;include refid=&quot;mySelectSql&quot;/&gt; 五、MyBatis高级扩展5.1 Mapper批量映射优化 需求 Mapper 配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。 配置方式 Mybatis 允许在指定 Mapper 映射文件时，只指定其所在的包： &lt;mappers&gt; &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;&lt;/mappers&gt; 此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。 资源创建要求 Mapper 接口和 Mapper 配置文件名称一致 Mapper 接口：EmployeeMapper.java Mapper 配置文件：EmployeeMapper.xml Mapper 配置文件放在 Mapper 接口所在的包内 可以将mapperxml文件放在mapper接口所在的包！ 可以在sources下创建mapper接口包一致的文件夹结构存放mapperxml文件 5.2 插件和分页插件PageHelper 相当于JavaWeb中的过滤器, 在提交到mybatis中执行前先经过拦截器 有分页插件后, 不用在SQL中写limit, 插件自动完成分页 5.2.1 插件机制和PageHelper插件介绍MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。 具体来说，MyBatis 的插件机制包括以下三个组件： Interceptor（拦截器）：定义一个拦截方法 intercept，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。 Invocation（调用）：实际上是对被拦截的方法的封装，封装了 Object target、Method method 和 Object[] args 这三个字段。 InterceptorChain（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。 插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 @Intercepts 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。 PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper 的使用方式。 https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#如何配置数据库方言 5.2.2 PageHelper插件使用 pom.xml引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt; mybatis-config.xml配置分页插件 在 MyBatis 的配置文件中添加 PageHelper 的插件： &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 其中，com.github.pagehelper.PageInterceptor 是 PageHelper 插件的名称，dialect 属性用于指定数据库类型（支持多种数据库） 页插件使用 在查询方法中使用分页： @Testpublic void testTeacherRelationshipToMulti() &#123; TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class); PageHelper.startPage(1,2); // 查询Customer对象同时将关联的Order集合查询出来 List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();// PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(allTeachers); System.out.println(&quot;pageInfo = &quot; + pageInfo); long total = pageInfo.getTotal(); // 获取总记录数 System.out.println(&quot;total = &quot; + total); int pages = pageInfo.getPages(); // 获取总页数 System.out.println(&quot;pages = &quot; + pages); int pageNum = pageInfo.getPageNum(); // 获取当前页码 System.out.println(&quot;pageNum = &quot; + pageNum); int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数 System.out.println(&quot;pageSize = &quot; + pageSize); List&lt;Teacher&gt; teachers = pageInfo.getList(); //获取查询页的数据集合 System.out.println(&quot;teachers = &quot; + teachers); teachers.forEach(System.out::println);&#125; 5.3 逆向工程和MybatisX插件 面向过程的Java和面向过程的数据库进行互动时, 用JDBC的方案相当于Java向数据库投降了. 现在使用ORM的思维方法, 最终应用就是MyBatis, 对外提供crud的方法, 生成对应的sql语句. 这样下Java依然是面向对象思维, 调用Mybatis方法, 相当于中间人. 像hiernate是全自动的ORM框架, 虽然淘汰了, 但有点怨(自动生成的也比大多数程序员写的要好) 5.3.1 ORM思维介绍 ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!! 最终: 让我们可以使用面向对象思维进行数据库操作！！！ ORM 框架通常有半自动和全自动两种方式。 半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。 全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。 下面是半自动和全自动 ORM 框架的区别： 映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。 查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。 性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。 学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。 常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。 5.3.2 逆向工程&#x20; MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。&#x20; MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。&#x20; 总的来说，MyBatis 的逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。 注意：逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！ 5.3.3 逆向工程插件MyBatisX使用&#x20; MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤： 安装插件： 在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。 使用 IntelliJ IDEA连接数据库 连接数据库 填写信息 展示库表 逆向工程使用 查看生成结果 逆向工程案例使用 正常使用即可，自动生成单表的crud方法！ package com.atguigu.mapper;import com.atguigu.pojo.User;/*** @author Jackiechan* @description 针对表【user】的数据库操作Mapper* @createDate 2023-06-02 16:55:32* @Entity com.atguigu.pojo.User*/public interface UserMapper &#123; int deleteByPrimaryKey(Long id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; 六、MyBatis总结 核心点 掌握目标 mybatis基础 使用流程, 参数输入,#{} ${},参数输出 mybatis多表 实体类设计,resultMap多表结果映射 mybatis动态语句 Mybatis动态语句概念, where , if , foreach标签 mybatis扩展 Mapper批量处理,分页插件,逆向工程","tags":["数据库","Java","Mybatis"],"categories":["技术","记录"]},{"title":"JDBC 学习","path":"/2023/01/23/JDBC/","content":"概述JDBC(Java Database Connectivity) : 在Java代码中, 使用jdbc提供的方法, 可以发送字符串类型的sql语句到数据库管理软件, 并且获取语句执行结果, 进而实现数据库数据的curd 小结 jdbc是Java连接数据库技术的统称 jdbc是由两个部分组成: Java提供的jdbc规范 各个数据库厂商实现的驱动jar包 jdbc技术是一种典型的面向接口编程 优势只需要学习jdbc接口规范, 既可以操作所有数据库软件 项目中切换数据库, 只需要更新第三方数据库驱动jar包, 不需要更改代码 jdbc核心api和使用路线jdbc技术组成 jdk下jdbc规范接口, 存储在Java.sql和javax.sql包中的api 为了项目代码的可移植性，可维护性，SUN公司从最初就制定了Java程序连接各种数据库的统一接口规范。这样的话，不管是连接哪一种DBMS软件，Java代码可以保持一致性。 各个数据库厂商提供的驱动jar包 因为各个数据库厂商的DBMS软件各有不同，那么内部如何通过sql实现增、删、改、查等管理数据，只有这个数据库厂商自己更清楚，因此把接口规范的实现交给各个数据库厂商自己实现。 jar包 java程序打成的一种压缩包格式，你可以将这些jar包引入你的项目中，然后你可以使用这个java程序中类和方法以及属性了! 设计具体核心类和接口 DriverManager获取连接； 接着建立连接； PreparedStatement（最常用）发送sql语句；\\ 若是查询操作，则对应的查询结果放在Result中。 DriverManager 将第三方数据库厂商的实现驱动jar注册到程序中 可以根据数据库连接信息获取connection Connection 和数据库建立的连接,在连接对象上,可以多次执行数据库curd动作 可以获取statement和 preparedstatement,callablestatement对象 Statement | PreparedStatement | CallableStatement 具体发送SQL语句到数据库管理软件的对象 不同发送方式稍有不同 Result 面向对象思维的产物, 抽象成数据库的查询结果表 存储DQL的查询数据库结果的对象 需要我们进行解析, 获取具体的数据库数据 JDBC核心API package com.database.api.statement;import com.mysql.cj.jdbc.Driver;import java.sql.*;public class StatementQueryPart &#123; public static void main(String[] args) throws SQLException &#123; //1. 注册驱动 DriverManager.registerDriver(new Driver()); //2. 连接数据库 String url = &quot;jdbc:mysql://127.0.0.1:3306/atguigudb&quot;; String username = &quot;root&quot;; String password = &quot;qyingli001234&quot;; Connection connection = DriverManager.getConnection(url, username, password); //创建statement Statement statement = connection.createStatement(); //发送sql语句, 获取返回结果 String sql = &quot;select email from employees;&quot;; ResultSet resultSet = statement.executeQuery(sql); //进行结果解析 while (resultSet.next()) &#123;//有就下一行数据// int id = resultSet.getInt(&quot;id&quot;);// String account = resultSet.getString(&quot;account&quot;);// String nickname = resultSet.getString(&quot;password&quot;);// System.out.println(id + &quot; &quot; + account + &quot; &quot; + nickname); String email = resultSet.getString(&quot;email&quot;); System.out.println(email); &#125; //关闭 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 全新JDBC拓展提升自增长主键回显实现功能需求 java程序获取插入数据时mysql维护自增长维护的主键id值,这就是主键回显 作用: 在多表关联插入数据时,一般主表的主键都是自动生成的,所以在插入数据之前无法知道这条数据的主键,但是从表需要在插入数据之前就绑定主表的主键,这时可以使用主键回显技术: 也就是, 在插入订单的数据时, 用返回主键确认对应的是那一个订单项 功能实现 继续沿用之前的表数据 /** * 返回插入的主键！ * 主键：数据库帮助维护的自增长的整数主键！ * @throws Exception */@Testpublic void returnPrimaryKey() throws Exception&#123; //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.获取连接 Connection connection = DriverManager.getConnection( &quot;jdbc:mysql:///atguigu?user=root&amp;password=qyingli001234&quot;); //3.编写SQL语句结构 String sql = &quot;insert into t_user (account,password,nickname) values (?,?,?);&quot;; //4.创建预编译的statement，传入SQL语句结构 /** * TODO: 第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS * 1. 告诉statement携带回数据库生成的主键！ * PrepareDStatemnt返回Java程序时带上主键 * 2. 获取司机装主键值的结果对象, 一行一列, 获取对应的数据 * ResultSet resultSet = statement.getGeneratedKeys() */ PreparedStatement statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); //5.占位符赋值 statement.setObject(1,&quot;towgog&quot;); statement.setObject(2,&quot;123456&quot;); statement.setObject(3,&quot;二狗子&quot;); //6.执行SQL语句 【注意：不需要传入SQL语句】 DML int i = statement.executeUpdate(); //7.结果集解析 if(i &gt; 0) &#123; System.out.println(&quot;i = &quot; + i); //一行一列的数据！里面就装主键值！ id=值, 固定用getGeneratedKeys ResultSet resultSet = statement.getGeneratedKeys(); //移动光标到第一行 resultSet.next(); //获取第一列的数据 int anInt = resultSet.getInt(1);//指向第一列 System.out.println(&quot;anInt = &quot; + anInt); &#125; //8.释放资源 statement.close(); connection.close();&#125; 批量数据插入性能提升功能需求 批量数据插入优化 提升大量数据插入效率 功能实现/** *改动了三处：（1）路径（2）必写values，且后面不加;（3）装货addBatch()最后executeBatch(); * 批量细节： * 1.url?rewriteBatchedStatements=true * 2.insert 语句必须使用 values * 3.语句后面不能添加分号; * 4.语句不能直接执行，每次需要装货 addBatch() 最后 executeBatch(); * * 批量插入优化！ * @throws Exception */@Testpublic void batchInsertYH() throws Exception&#123; //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.获取连接 Connection connection = DriverManager.getConnection (&quot;jdbc:mysql:///atguigu?rewriteBatchedStatements=true&quot;,&quot;root&quot;,&quot;root&quot;); //3.编写SQL语句结构 String sql = &quot;insert into t_user (account,password,nickname) values (?,?,?)&quot;; //4.创建预编译的statement，传入SQL语句结构 /** * TODO: 第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS * 告诉statement携带回数据库生成的主键！ */ long start = System.currentTimeMillis(); PreparedStatement statement = connection.prepareStatement(sql); for (int i = 0; i &lt; 10000; i++) &#123; //5.占位符赋值 statement.setObject(1,&quot;ergouzi&quot;+i); statement.setObject(2,&quot;lvdandan&quot;); statement.setObject(3,&quot;驴蛋蛋&quot;+i); //6.装车 statement.addBatch(); &#125; //发车！ 批量操作！ statement.executeBatch(); long end = System.currentTimeMillis(); System.out.println(&quot;消耗时间：&quot;+(end - start)); //7.结果集解析 //8.释放资源 connection.close();&#125; jdbc中数据库事务实现章节目标使用jdbc代码,添加数据库事务动作! 开启事务 事务提交 &#x2F; 事务回滚 事务概念回顾事务概念 数据库事务就是一种SQL语句执行的缓存机制,不会单条执行完毕就更新数据库数据,最终根据缓 存内的多条语句执行结果统一判定! 一个事务内所有语句都成功及事务成功,我们可以触发commit提交事务来结束事务,更新数据! 一个事务内任意一条语句失败,及事务失败,我们可以触发rollback回滚结束事务, 数据回到事务之前状态! 举个例子: 临近高考,你好吃懒做,偶尔还瞎花钱,父母也只会说’&#x3D;&#x3D;你等着!&#x3D;&#x3D;’,待到高考完毕! 成绩600+,翻篇,庆祝! 成绩200+,翻旧账,男女混合双打! 优势 允许我们在失败情况下,数据回归到业务之前的状态! 场景 一个业务****涉及多条修改数据库语句! 例如: 经典的转账案例,转账业务(加钱和减钱) 批量删除(涉及多个删除) 批量添加(涉及多个插入) 事务特性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生， 要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰， 即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的， 接下来的其他操作和数据库故障不应该对其有任何影响 事务类型 自动提交 : 每条语句自动存储一个事务中,执行成功自动提交,执行失败自动回滚! (MySQL) 手动提交: 手动开启事务,添加语句,手动提交或者手动回滚即可! SQL开启事务方式【事务都在一个连接中】 针对自动提交: 关闭自动提交即可,多条语句添加以后,最终手动提交或者回滚! (推荐) SET autocommit = off; //关闭当前连接connection自动事务提交方式 # 只有当前连接有效 # 编写SQL语句即可 SQL SQL SQL #手动提交或者回滚 【结束当前的事务】 COMMIT / ROLLBACK ; 手动开启事务: 开启事务代码,添加SQL语句,事务提交或者事务回滚! (不推荐) 呼应jdbc技术​ try&#123; connection.setAutoCommit(false); //关闭自动提交了 //connection.setAutoCommit(false)也就类型于SET autocommit = off//注意,只要当前connection对象,进行数据库操作,都不会自动提交事务//数据库动作!//statement - 单一的数据库动作 c u r d //connection - 操作事务 connection.commit(); &#125;catch(Execption e)&#123; connection.rollback(); &#125; - 数据库表数据```Java-- 继续在atguigu的库中创建银行表CREATE TABLE t_bank( id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;账号主键&#x27;, #ATUO意味着可以不用传入, 让系统自动sh account VARCHAR(20) NOT NULL UNIQUE COMMENT &#x27;账号&#x27;, money INT UNSIGNED COMMENT &#x27;金额,不能为负值&#x27;) ; INSERT INTO t_bank(account,money) VALUES (&#x27;ergouzi&#x27;,1000),(&#x27;lvdandan&#x27;,1000); 代码结构设计 jdbc事务实现 测试类 /** * @Author 赵伟风 * Description: 测试类 */public class BankTest &#123; @Test public void testBank() throws Exception &#123; BankService bankService = new BankService(); bankService.transfer(&quot;ergouzi&quot;, &quot;lvdandan&quot;, 500); &#125;&#125;- BankService/** * @Author 赵伟风 * Description: bank表业务类,添加转账业务 */public class BankService &#123;//一个事物最基本的是在同一个连接中connection，一个转账方法是一个事物，将connection传入dao//实现层即可，dao层不用关闭connection，由事物统一关闭 /** * 转账业务方法 * @param addAccount 加钱账号 * @param subAccount 减钱账号 * @param money 金额 */ public void transfer(String addAccount,String subAccount, int money) throws ClassNotFoundException, SQLException &#123; System.out.println(&quot;addAccount = &quot; + addAccount + &quot;, subAccount = &quot; + subAccount + &quot;, money = &quot; + money); //注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //获取连接 Connection connection = DriverManager.getConnection (&quot;jdbc:mysql:///atguigu&quot;, &quot;root&quot;, &quot;root&quot;); int flag = 0; //利用try代码块,调用dao try &#123; //开启事务(关闭事务自动提交) connection.setAutoCommit(false); BankDao bankDao = new BankDao(); //调用加钱 和 减钱 bankDao.addMoney(addAccount,money,connection); System.out.println(&quot;--------------&quot;); bankDao.subMoney(subAccount,money,connection); flag = 1; //不报错,提交事务 connection.commit(); &#125;catch (Exception e)&#123; //报错回滚事务 connection.rollback(); throw e; &#125;finally &#123; connection.close(); &#125; if (flag == 1)&#123; System.out.println(&quot;转账成功!&quot;); &#125;else&#123; System.out.println(&quot;转账失败!&quot;); &#125; &#125;&#125;- BankDao：具体操作方法/** * @Author 赵伟风 * Description: 数据库访问dao类 */public class BankDao &#123; /** * 加钱方法 * @param account * @param money * @param connection 业务传递的connection和减钱是同一个! 才可以在一个事务中! * @return 影响行数 */ public int addMoney(String account, int money,Connection connection) throws ClassNotFoundException, SQLException &#123; String sql = &quot;update t_bank set money = money + ? where account = ? ;&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); //占位符赋值 preparedStatement.setObject(1, money); preparedStatement.setString(2, account); //发送SQL语句 int rows = preparedStatement.executeUpdate(); //输出结果 System.out.println(&quot;加钱执行完毕!&quot;); //关闭资源close preparedStatement.close(); return rows; &#125; /** * 减钱方法 * @param account * @param money * @param connection 业务传递的connection和加钱是同一个! 才可以在一个事务中! * @return 影响行数 */ public int subMoney(String account, int money,Connection connection) throws ClassNotFoundException, SQLException &#123; String sql = &quot;update t_bank set money = money - ? where account = ? ;&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); //占位符赋值 preparedStatement.setObject(1, money); preparedStatement.setString(2, account); //发送SQL语句 int rows = preparedStatement.executeUpdate(); //输出结果 System.out.println(&quot;减钱执行完毕!&quot;); //关闭资源close preparedStatement.close(); return rows; &#125;&#125; 连接池使用连接池作用传统缺点 不使用数据库连接池，每次都通过DriverManager获取新连接，用完直接抛弃断开，连接的利用率太低，太浪费。 对于数据库服务器来说，压力太大了。我们数据库服务器和Java程序对连接数也无法控制，很容易导致数据库服务器崩溃。 我们就希望能管理连接。 我们可以建立一个连接池，这个池中可以容纳一定数量的连接对象，一开始，我们可以先替用户先创建好一些连接对象，等用户要拿连接对象时，就直接从池中拿，不用新建了，这样也可以节省时间。然后用户用完后，放回去，别人可以接着用。 可以提高连接的使用率。当池中的现有的连接都用完了，那么连接池可以向服务器申请新的连接放到池中。 直到池中的连接达到“最大连接数”，就不能在申请新的连接了，如果没有拿到连接的用户只能等待。 全新JDBC使用优化以及工具类封装过程： 注册驱动 获取连接 编写SQL语句 创建statement 占位符赋值 发送SQL语句 结果解析 回收资源 1.0版本我们封装一个工具类,内部包含连接池对象,同时对外提供连接的方法和回收连接的方法! 2.0版本优化工具类v1.0版本,考虑事务的情况下, &#x3D;&#x3D;如何一个线程的不同方法获取同一个连接!&#x3D;&#x3D; ThreadLocal的介绍：线程本地变量：为同一个线程存储共享变量使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、Session等 ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。 1、ThreadLocal对象.get: 获取ThreadLocal中当前线程共享变量的值。 2、ThreadLocal对象.set: 设置ThreadLocal中当前线程共享变量的值。 3、ThreadLocal对象.remove: 移除ThreadLocal中当前线程共享变量的值。 service.trsanfer()调用了dao.add()方法和dao.sub()方法, 他们共处一个线程, 只需要在调用service时get一个connection放到ThreadLocal里, 之后的add和sub去用就行 2.0工具类import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;//事物时，Service和dao属于同一线程，不用再传参数了/*这个工具类的作用就是用来给所有的SQL操作提供“连接”，和释放连接。这里使用ThreadLocal的目的是为了让同一个线程，在多个地方getConnection得到的是同一个连接。这里使用DataSource的目的是为了（1）限制服务器的连接的上限（2）连接的重用性等 */public class JDBCTools &#123; private static DataSource ds; private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;(); static&#123;//静态代码块，JDBCToolsVersion1类初始化执行 try &#123; Properties pro = new Properties(); pro.load(ClassLoader.getSystemResourceAsStream(&quot;druid.properties&quot;)); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; Connection connection = tl.get(); if(connection == null)&#123;//当前线程还没有拿过连接，就给它从数据库连接池拿一个 connection = ds.getConnection(); tl.set(connection); &#125; return connection; &#125; public static void free() throws SQLException &#123; Connection connection = tl.get(); if(connection != null)&#123; tl.remove(); connection.setAutoCommit(true);//避免还给数据库连接池的连接不是自动提交模式（建议） connection.close(); &#125; &#125;&#125; 高级应用封装BaseDao前面的封装只做了第一和第八步, 整体依然繁琐 基本上每一个数据表都应该有一个对应的DAO接口及其实现类，发现对所有表的操作（增、删、改、查）代码重复度很高，所以可以抽取公共代码，给这些DAO的实现类可以抽取一个公共的父类，我们称为BaseDao 将重复的代码封装到basedao中, 而增删改查中, 增删和改都是返回int, 调用update, 所以单独所谓一个方法, 查调用query方法, 单独一个. 即DQL语句和非DQL语句 public abstract class BaseDao &#123; /* 通用的增、删、改的方法 String sql：sql Object... args：给sql中的?设置的值列表，可以是0~n */ protected int update(String sql,Object... args) throws SQLException &#123;// 创建PreparedStatement对象，对sql预编译 Connection connection = JDBCTools.getConnection(); PreparedStatement ps = connection.prepareStatement(sql); //设置?的值 if(args != null &amp;&amp; args.length&gt;0)&#123; for(int i=0; i&lt;args.length; i++) &#123; ps.setObject(i+1, args[i]);//?的编号从1开始，不是从0开始，数组的下标是从0开始 &#125; &#125; //执行sql int len = ps.executeUpdate(); ps.close(); //这里检查下是否开启事务,开启不关闭连接,业务方法关闭! //connection.getAutoCommit()为false，不要在这里回收connection,由开启事务的地方回收 //connection.getAutoCommit()为true，正常回收连接 //没有开启事务的话,直接回收关闭即可! if (connection.getAutoCommit()) &#123; //回收 JDBCTools.free(); &#125; return len; &#125; /* 通用的查询多个Javabean对象的方法，例如：多个员工对象，多个部门对象等 这里的clazz接收的是T类型的Class对象， 如果查询员工信息，clazz代表Employee.class， 如果查询部门信息，clazz代表Department.class， 返回List&lt;T&gt; list */ protected &lt;T&gt; ArrayList&lt;T&gt; query(Class&lt;T&gt; clazz,String sql, Object... args) throws Exception &#123; // 创建PreparedStatement对象，对sql预编译 Connection connection = JDBCTools.getConnection(); PreparedStatement ps = connection.prepareStatement(sql); //设置?的值 if(args != null &amp;&amp; args.length&gt;0)&#123; for(int i=0; i&lt;args.length; i++) &#123; ps.setObject(i+1, args[i]);//?的编号从1开始，不是从0开始，数组的下标是从0开始 &#125; &#125; ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); ResultSet res = ps.executeQuery(); /* 获取结果集的元数据对象。 元数据对象中有该结果集一共有几列、列名称是什么等信息 */ ResultSetMetaData metaData = res.getMetaData(); int columnCount = metaData.getColumnCount();//获取结果集列数 //遍历结果集ResultSet，把查询结果中的一条一条记录，变成一个一个T 对象，放到list中。 while(res.next())&#123; //循环一次代表有一行，代表有一个T对象 T t = clazz.newInstance();//要求这个类型必须有公共的无参构造 //把这条记录的每一个单元格的值取出来，设置到t对象对应的属性中。 for(int i=1; i&lt;=columnCount; i++)&#123; //for循环一次，代表取某一行的1个单元格的值 Object value = res.getObject(i); //这个值应该是t对象的某个属性值 //获取该属性对应的Field对象 //String columnName = metaData.getColumnName(i);//获取第i列的字段名 //这里再取别名可能没办法对应上 String columnName = metaData.getColumnLabel(i);//获取第i列的字段名或字段的别名 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true);//这么做可以操作private的属性 field.set(t, value); &#125; list.add(t); &#125; res.close(); ps.close(); //这里检查下是否开启事务,开启不关闭连接,业务方法关闭! //没有开启事务的话,直接回收关闭即可! if (connection.getAutoCommit()) &#123; //回收 JDBCTools.free(); &#125; return list; &#125; protected &lt;T&gt; T queryBean(Class&lt;T&gt; clazz,String sql, Object... args) throws Exception &#123; ArrayList&lt;T&gt; list = query(clazz, sql, args); if(list == null || list.size() == 0)&#123; return null; &#125; return list.get(0); &#125;&#125;","tags":["数据库","Java","JDBC"],"categories":["技术","记录"]},{"title":"摄影? 社死!","path":"/2022/05/08/关于我们/","content":"先看片人像作品展示其他作品关于我们摄影师Qyingli 一个喜欢数码科技的有个成为Rock Star的幻想的九流臭拍照的人。 母胎单身。 来张中二的他拍图 FanC 本想与诗歌相伴，却跌落美食的深渊，无法自拔。 心系白椿，蜀葵谁会。 服务内容相关内容会有更新补充，烦请关注拍摄设备 相机： 全画幅 佳能6D单反 APSC画幅 佳能80D单反 镜头： 50mm F1.8 人像镜头 24-105mm F4 变焦镜头 三脚架 照片毕业季留下自己美好的回忆，记录自己略带遗憾的青春 全体毕业照：多年之后再次翻看，回想与大学同窗的点点滴滴 学士服的纪念：将刹那的青春变成永恒，那年，那人，那些。 个人写真：最美好的青春，值得纪念 底片 所有底片全部简修 精修 精修数量15张 交片 拍摄完成后一周内交付 费用 班级单位 349CNY&#x2F;单 个人写真 99CNY&#x2F;单","tags":["摄影"],"categories":["记录"]},{"title":"网页小项目--日期转化","path":"/2022/05/04/日期转化--网页demo/","content":"demo","tags":["JavaScript"]},{"title":"网络运行","path":"/2022/04/17/网络运作/","content":"互联网所有的传输都通过RCP&#x2F;IP协议族来传输，TCP&#x2F;IP是面向连接的可靠字节流服务协议 TCP&#x2F;IP协议族有四层 应用层：提供特定于应用程序的协议 HTTP FTP IMAP(邮件) 网络控制层 发送数据包到计算机上使用特定的端口号的应用程序 网络层 使用IP地址将数据包发送到特定的计算 链路层 将二进制数据包与网络信号相互之间转换TCP的可靠 tcp在建立连接会进行三次握手，每个收到的数据包都会向发送方发送ack确认，已确保发送成功 IP的传输 IP是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标IP TCP传输的质量和顺序 当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的ack确认，会再次重新发送 IP和IP地址的区别 Ip是一种协议 有两种标准 IPv4 2^32次方和IPv6 2^128 IP地址是一串数字192.0.0.1 网络传输 个人电脑 猫 local ISP 互联网服务提供商 regional ISP 经过多个主干网络 NSP 网络服务提供商 大型网络 卖带宽给ISP NAP 每个NSP连接到至少三个网络访问点 ISP NSP 所有网络提供都携带路由器，每个路由有当前子网络ip的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。 DNS服务 存在意义是IP别名，不让公司丢客户，也容易记，DNS是一个分布式数据库，存储了域名和IP的对应关系","tags":["计算机网络","互联网"],"categories":["技术"]},{"title":"PS认识摄影后期","path":"/2022/03/22/特师傅的人像后期/","content":"第一课 不做多余的事搞清楚两个问题 存在什么问题构图 曝光 色彩 反差 瑕疵等等 照片的情绪是什么 从这两方面去确定具体的步骤 工具滤色的意思就是去掉黑色,保留白色 色阶增加立体感,调整局部时只关注调整部位,使用蒙版擦出 曲线 调整幅度克制 在照片反差比较大的时候,如果要保留一定的视觉宽容度,可以将曲线的顶端和低端分别下压和提升一点.使照片明暗更加均衡一些. 饱和度工具 调整局部或者全图的饱和度 色相饱和度 调整某一种颜色的色相或者饱和度 图层调整颜色 拾色器选中想要的颜色,然后画笔涂抹到想要修改的区域,选择颜色(只影响颜色).即可完成局部调整. 色彩 主色调是黄色和橙色,那么与之相对应的就是青色会比较好.而暗部是偏紫色的,所以将暗部修正 第二课 合格的照片,漂亮的后期思路好的照片建立在内容 轻松的情绪颜色不必太浓郁,对比度不能太高,通透感是目标 对于大多数作品来说,要想好三个问题: 照片有没有明显的后期无法解决的问题没有明显bug,但后期能否让它更加出众 是否清楚主题和情绪,是否已经有了相应的后期计划. 拍摄逆光照片时,如果要拍出轮廓光,需要背景衬托. 修复瑕疵 渲染氛围 调整光影 后期和拍照从根本上来说是一件事的两个步骤 工具曲线调整白平衡 分为亮部，灰色区域，暗部。进行分别选区 暗部吸管保留5的亮度（B），亮部保留95。 滤镜的氛围渲染 调整密度，画笔选择想要的颜色范围。 可以二次增加浓度 人物皮肤通透 建立选区，曲线调整 画笔除去人物衣服、头发，保持人物身上和环境光的和谐状态。 第三课 清新阳光感后期思路光线一般有两种光： 太阳直射光，比较硬，逆光时可以形成轮廓光 散射光，相对柔和，随环境变化，注意对主体光影变化的影响。 阳光下色彩比较艳丽，所以用清新感的后期来中和。 阳光会照亮好看的东西，也会照亮杂乱的东西；会照亮环境层次，也会让明亮过度分明；会照亮皮肤，也会让皮肤的瑕疵看的更加清楚 。后期突出“明亮“ ”清新“的要素。 调色时时刻要记住互补色，这往往是不错的选择 工具曲线工具点击小手，可以调节选中部分的参数。 色相饱和度工具改变画面中的颜色，比如例子中将椅子的橙色调整为黄色，与衣服的蓝色形成互补色。 选区降低画面中主体以外的饱和度，可以增加清新感，但要保留一定的颜色过度。 第四课 夜景人像思路拍摄 不去拍便不会修 找到角度合适的主光源，不一定时最亮的，可以原理主光源，找到氛围 环境比人物轮廓亮，人物不会融入到环境中 后期光比平衡 维持白平衡平衡的前提下带点冷色 曝光调整 光影 区分不同的光比，对比的效果 滤镜-&gt;偏青色-&gt;进行染色，勾选保留明度，只对颜色进行染色。40左右 选中人物和对比色区域，恢复初始颜色（在蒙版上点击ALT键可以看到选区）。如果边缘比较锐利，可以用黑色画笔进行边缘过度。（选择蒙版，按住CRT键显示选区，可以再次添加效果） 选择橙色滤镜，注意人物颜色。 氛围 曲线，整体偏暗一点，对比度不要太高。反复调节。不要把注意力放在局部。 亮部调整氛围，暗部可以添加暗角 进一步颜色调节 明度提升时饱和度会降低 拾色器选中颜色浓郁区域的颜色，非极端情况不要超过对角线。 人物肤色调整，CTRL+I反转蒙版，擦出皮肤。人物肤色和环境相关。 CTRL+shift+E+I合并所有图层并复制一个。去掉I只合并。 添加高斯模糊，大小大概可以看到人物轮廓，然后选择滤色，不透明度降低。 曲线，色阶进一步调整氛围，人物身上对比度和环境尽量保持一致。 地面饱和度不要太高。 第五课 暖调照片后期思路 黄色,橙色,红色都是暖调照片的必备部分 暖调照片并不是黄,单一的变黄照片会比较闷 先建立温暖的基调 再调整光影 适合轻松自然的照片,也是和严肃的照片,保留明暗过度 工具微调身体比例CTRL+J复制图层,选取工具选择调整范围,按住shift键拉伸 可选颜色即利用互补色原理调整 选择黄色&gt;加深黄色,&gt;减少青色.选择红色&gt;加深黄色,减少洋红. 颜色曲线可以理解为用对应的颜色去照 加红,减蓝 降低局部饱和度选区工具选中,(羽化)建立黑白图层,调整不透明度 曲线加渐变 提高暗部 减少点蓝色 使用渐变工具 调整不需要改变的地方 柔焦 添加后进行局部调整 第六课 冷调照片后期思路：冷暖是人们长期以来与环境相处的结果。 夜景的冷色调往往比较容易后期，因为它具备了相应的情绪和环境，难点在阴天。 阴天拍照和可以选择纵深比较大的场景，利用虚化增加层次感。 冷调照片中人物肤色可以有一定程度偏色，因为受到环境的影响。 工具去个天花板。。。 选区工具选中 编辑&gt;填充&gt;内容识别&gt;仿制图章 色彩平衡调整画面颜色对比 比如选择暗部，和亮度颜色分开，但不要调整过头。 可选颜色使画面主要颜色统一 蓝色青色靠拢 青色》加蓝 蓝色》加青色，黑色减少一些 减少洋红》加黄，减红 黑色 明度可以影响颜色的饱和度 黑色越多饱和度越高，黑色越少，白色越多，饱和度就降低。 色彩范围（HSL辅助）降低反差 shift增加选区 选区做一些羽化，大小与范围有关，这样调色后不会很明显。 色彩容差低一些比较好 建立空白图层，选中一种颜色，降低不透明度 曲线添加暗角滤镜》其他》高反差保留CTRL+shift+E CTRL+shift+U黑白 半径10以内，使有明暗分界线，增加轮廓的清晰度 模式选择柔光 可以在添加柔焦后使用 第七课 人物肤色 皮肤颜色主要取决于两个因素： 皮肤本身颜色 环境光照颜色 肤色本身的色相是相似的。亚洲人是偏橙的红色。 条状为色相，从上到下是明度，从左到右是饱和度。 调节 饱和度、明度、色相 夜景保留人物亮度，将环境亮度压低-&gt;氛围 注意自然，光的扩散，画图多次涂抹制造渐变。 第九课 阴天照片 俯拍、顶光变成了顺光 侧拍、注意模特是否适合 阴天对比度不高， 光影 近处亮、远处暗。或者相反 选择并遮住-&gt;羽化，扩大选区 选择-&gt;色彩范围 选择明暗处 曲线或者色阶调整，曲线中可以调整RGB曲线调整光线颜色 近处暗部可以利用曲线工具压低，增加点氛围 保持主体的细节 人物层次感 保留细节 色彩 绿色太多可以偏黄一些，红色也可以黄一些。可选颜色工具 色彩平衡，高光阴影和阴影颜色形成对比 人物肤色 第十课 统一色调拍摄 拍摄时的场景差别 光源角度变换 场景元素差异 一组照片尽可能在同一场景拍摄，光源角度变化，焦距便变化不要太大。","tags":["摄影","PS"],"categories":["记录"]},{"title":"VS Code配置学习笔记","path":"/2022/03/06/VS Codo学习笔记/","content":"写在开始 劝退提醒：如果你只是学习C，不想特别麻烦的配置，那么我建议去官网下在新版visual studio，或者使用国内大牛改进的Dev-C++小熊猫C++。两者链接如下： 下载 Visual Studio Tools - 免费安装 Windows、Mac、Linux (microsoft.com) 小熊猫C++ (gitee.io) 为什么我喜欢使用VS Code？对于刚起步学习，其实只需要做到好看，好用就可以了，而VS Code正好满足了这两点。 体积小，打开速度飞快 巨多的插件可供下载，满足自定义需求！！！ 清爽的界面！！！满足你的码农梦！！！ 支持云端保存配置 支持多种高级语言（虽然现在用不到） 下载安装官网下载：Download Visual Studio Code - Mac， Linux， Windows 或者可以在联想应用商店下载。 安装时可以将所有勾都打上 第一次安装完成后一般会在右下角提示你安装中文插件，点击安装重启软件即可 如果你没有看到提示的话，也可以在拓展市场搜索Chinese安装,就是点左边那个四个方框的东西。 打开文件夹在VS Code里面写C代码不像在Dev一样是新建项目，而是使用打开文件夹，之后的调式配置文件等都放在文件夹当中，即不打开文件夹就不能使用调式（因为那样就没有配置文件了嘛）。 这里我建议你在硬盘新建一个文件夹专门存放C相关的文件，比如叫做VsCode_C（不要有中文）。 然后点击打开文件夹，再点击添加到信任。 搭建C&#x2F;C++环境如果，我是如果现在你在文件夹下新建一个名为hello的C文件，然后码上这些内容： #include&lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, fucking world!&quot;); return 0&#125; 如果是Dev的话运行代码会提示你少打了一个“;”，但在Vs Code中现在你没有这个机会，因为你会发现你压根没有办法运行这段代码，更不用提报错了。 当然不是因为我们的操作有误，而是因为Vs Code本事并不是一个像Dev-C++一样的编译器，而是一个编辑器。如果你读了全网黑的谭浩强的C程序设计第一章的话应该对这俩个东西有点印象，如果没有的话……那还楞着干嘛呀，愣着呀！ 咳，回到正题。编辑器你可以把他理解为一个”Word“，他只是提供给你一个写代码的平台，其本身并不能不运行它，因为对于电脑而言，这些东西它丫根本不认识，你必须想办法把这段很看起来无聊的代码翻译成电脑能看的懂得二进制机器码，而干这个事就叫编译器。也就是把源文件-&gt;可执行文件的这个过程。 现在我们知道了，因为Vs Code它只是一个编辑器，不包含编译功能，因此我们需要自己安装编译器、调试器等编译套件，使两者结合起来，这个过程就是搭建环境。 在Windows平台编译套装一般都使用Mingw。 GCC,全称GNU Complier Collertion，意思时GNU编译套件。不过不是原版的GCC，而是它在Windows下的特制版MinGW(全称Minimalist GNU on Windows）。它实际上是将GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。 这里建议在联想应用商店下载TDM-GCC - 联想软件商店，这样你就不用手动下载文件包再去配置环境变量了。 环境变量是 Windows 系统中用来指定运行环境的一些参数，它包含了关于系统及当前登录用户的环境信息字符串。当用户运行某些程序时，系统除了会在当前文件夹中寻找某些文件外，还会到环境参数的默认路径中去查找程序运行时所需要的系统文件。 在安装的时候取消勾选检查更新，在国内速度非常慢，当然如果你有梯子的话，这个我们后面再说。。。 开始使用Mingw安装完成后，我们在你刚才新建的文件夹下新建一个名为“.vscode”的文件夹用来保存配置文件（是文件夹，不是文件，并且注意这个.），然后再新建一个文件夹保存我们平时写的代码。这两个文件夹都是在VSCODE-C这个文件夹下的。 然后我们在在Exercise下新建一个C文件，比如text.c。这时它会提示你安装C&#x2F;C++的拓展，如果你比较非没有出现的话，像上面一样可以自己手动搜索添加就可以了。 然后码一个hello world #include&lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, fucking world!&quot;); return 0;&#125; 调试（运行）再次强调，调试必须在一个文件夹内进行，并且文件路径不能有中文和空格。 现在我们按F5进行调试，在上面出现的选择框中选择“C++ (GBD&#x2F;LLDB)”，“gcc&#x2F;g++”就可以了，软件会自动生成文件。 拓展C&#x2F;C++ Compile Run虽然通过前面的配我们已经可以运行代码了，但是我们平时练习都是一些单程序，通过调试的方法运行就显得比较麻烦，不够优雅，并且调试的速度也比较慢，看的人着急。所以我们可以借助一个拓展来实现一键编译。 安装之后只需要按下F6就可以一键编译你写的程序。 Material Icon Theme一个图标插件，让你的Vs Code更加帅气 One Dark Pro一个主题插件，更你的Vs Code更加帅气有多种风格可选 其他中文乱码解决的方法有两个： 不写中文（？？？） 看到左下角的设置图标没，点它，然后顶部搜索”编码“，设置文字编码格式为GBK。 禅模式让你在coding的时候更加专注 查看-&gt;外观-&gt;禅模式 快捷键这里不多说，只说几个个我写代码时最常用的。 代码格式化：Ctrl + Alt + f 注释选中行：Ctrl + / 如果已经注释，再按一次会取消注释 缩放界面：Ctrl + +或者Ctrl + - 一键替换变量名：F2 或者 Ctrl + F2（光标位于哪个变量，其所有出现过的地方都会同时改） 一键替换选中内容：Ctrl + F2（选中的内容出现过的地方都会改，相当于Ctrl + H） ……","tags":["vscode, 笔记, C/C++"],"categories":["技术"]},{"title":"JavaScript小项目--骰子游戏","path":"/2022/03/04/JavaScript小项目--骰子游戏/","content":"intro案例demo 先简单说下规则吧, 有时候玩起来还挺上头的😂😂😂 玩起来掷骰子, 然后比谁的点数大 两个人轮番投掷 投到点数 “1”会清空当前轮次的点数(赌狗玩法) 可以主动保存当前投出的点数(见好就收) 最后看谁的点数先到100 总结HTML &amp; CSS页面比较简单, 整体就是一个Grid的布局 没有做移动端优化, 但是设计了获胜界面, 这里主要还是以JavaScript为主 JavaScript 控制页面元素的变动 比如点数增加, 骰子图片这些 使用隐藏属性 在获胜的时候隐藏按钮 基础代码逻辑 开局时候的数据状态, 游玩过程中数据的保存, 然后再结束后清空并开始新的轮次 整体麻雀虽小, 但很适合作为基础编程练习 之前零碎的一些笔记… Hositing“变量提升” 意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。这是变量提升背后的工作原理。JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。但JavaScript中只有声明的变量会提升，初始化的不会。 let和const不会被提升，它们在时间死区中。 // 三种基本声明console.log(me);console.log(job);console.log(year);var me = &#x27;qyingli&#x27;let job = &#x27;programer&#x27;const year 2002;// 函数可以先使用再声明，但如果将函数写成表达式，则会被视为值。为定义的值视为0// console.log(me)会提升为Undefined，而log.(job)则是在声明前不能工作。 ‘This’ Keyword当前执行上下文（global、function 或 eval）的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。 this keyword&#x2F;variable: Special variable that is created for every execution context (every function).Takes the value of (points to) the “owner” of the function in which the this keyword is used。 他的值是在函数被实际调用时赋值。 ​ console.log(this);const calcAge = function (birthYear) &#123; console.log(2037-birthYear); console.log(this);&#125;;calcAge(2002);//此时this为undefined，因为就是zheconst calcAgeArrow = birthYear =&gt; &#123; console.log(2037-birthYear); console.log(this);&#125;;calcAge(2003);//此时this为窗口变量，因为箭头函数没有自己的this，他会使用父项的this。const qyingli = &#123; year:2002, calcAg e: function() &#123; console.log(this); console.log(2037 - this.year) &#125;&#125;qyingli.calcAge();//动态 var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2var A = &#123; name: &#x27;张三&#x27;, describe: function () &#123; return &#x27;姓名：&#x27;+ this.name; &#125;&#125;;var B = &#123; name: &#x27;李四&#x27;&#125;;B.describe = A.describe;B.describe() // &quot;姓名：李四&quot;//A.describe 属性被赋给 B，于是 B.describe 就表示 describe 方法所在的当前对象是 B，所以 this.name 就指向 B.name。 这种差异的原因，就在于函数体内部使用了 this 关键字。很多教科书会告诉你，this 指的是函数运行时所在的环境。对于 obj.foo() 来说，foo 运行在 obj 环境，所以 this 指向 obj；对于 foo() 来说，foo 运行在全局环境，所以 this 指向全局环境。所以，两者的运行结果不一样。 详情见这里,(按住crtl键点击) 常规函数和箭头函数//var firstName = &#x27;Matilda&#x27;;const jonas = &#123; firstName: &#x27;Jonas&#x27;, year: 1991, calcAge: function () &#123; console.log(this); console.log(2037 - this.year); Solution 1 const self = this; // self or that const isMillenial = function () &#123; console.log(self); console.log(self.year &gt;= 1981 &amp;&amp; self.year &lt;= 1996); &#125;; // Solution 2 const isMillenial = () =&gt; &#123; console.log(this); console.log(this.year &gt;= 1981 &amp;&amp; this.year &lt;= 1996); &#125;; isMillenial(); &#125;, greet: () =&gt; &#123; console.log(this); console.log(`Hey $&#123;this.firstName&#125;`); &#125;,&#125;;jonas.greet();jonas.calcAge();// arguments keywordconst addExpr = function (a, b) &#123; console.log(arguments); return a + b;&#125;;addExpr(2, 5); addExpr(2, 5, 8, 12);var addArrow = (a, b) =&gt; &#123; console.log(arguments); return a + b;&#125;;addArrow(2, 5, 8); Primitive VS. Reference Values 在堆中的值改变时修改初始值，而在栈中的则会创建一个新的空间 // Objects vs. primitiveslet age = 30;let oldAge = age;age = 31;console.log(age);console.log(oldAge);const me = &#123; name: &#x27;Jonas&#x27;, age: 30,&#125;;const friend = me;friend.age = 27;console.log(&#x27;Friend:&#x27;, friend);console.log(&#x27;Me&#x27;, me);///////////////////////////////////////// Primitives vs. Objects in Practice// Primitive typeslet lastName = &#x27;Williams&#x27;;let oldLastName = lastName;lastName = &#x27;Davis&#x27;;console.log(lastName, oldLastName);// Reference typesconst jessica = &#123; firstName: &#x27;Jessica&#x27;, lastName: &#x27;Williams&#x27;, age: 27,&#125;;const marriedJessica = jessica;marriedJessica.lastName = &#x27;Davis&#x27;;console.log(&#x27;Before marriage:&#x27;, jessica);console.log(&#x27;After marriage: &#x27;, marriedJessica);// marriedJessica = &#123;&#125;;// Copying objects 深度克隆会赋值所有，而潜克隆只会赋值第一级const jessica2 = &#123; firstName: &#x27;Jessica&#x27;, lastName: &#x27;Williams&#x27;, age: 27, family: [&#x27;Alice&#x27;, &#x27;Bob&#x27;],&#125;;const jessicaCopy = Object.assign(&#123;&#125;, jessica2);jessicaCopy.lastName = &#x27;Davis&#x27;;jessicaCopy.family.push(&#x27;Mary&#x27;);jessicaCopy.family.push(&#x27;John&#x27;);console.log(&#x27;Before marriage:&#x27;, jessica2);console.log(&#x27;After marriage: &#x27;, jessicaCopy);*/","tags":["JavaScript"],"categories":["技术"]},{"title":"C++复习笔记","path":"/2021/12/07/C++/","content":"C++类和对象 定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。 声明类的对象，就像声明基本类型的变量一样。 私有成员要通过方法进行使用 补充：new出来的空间可以自己控制，而普通的声明则不可以。 构造函数 与类名相同，在创建类时执行，无返回类型，也没有void。 可用于为有些成员变量设置初始值 ::作用域解析运算符 因为构造函数总是在创建对象时被调用，所以很适合用来舒适化为选定值。 在不提供参数的情况下被调用的构造函数被称为默认构造函数，当没有默认构造函数时，程序会自动创建，但并不会初始化为0； 当构造函数的参数有默认值时，也是默认构造函数。 初始化列表Line::Line( double len): length(len)&#123; cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;&#125;//上面等同于Line::Line( double len)&#123; length = len; cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;&#125;//假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，可以使用上面的语法，只需要在不同的字段使用逗号进行分隔：C::C( double a, double b, double c): X(a), Y(b), Z(c)&#123; ....&#125;//需要注意的是，初始化列表的初始化顺序是按照声明的顺序，而不是出现在初始化列表的顺序，所以最好保持一致 析构函数 腭化符号~ 当对象不在作用域内或者通过delete删除时调用，所以析构函数很适合重置变量以及释放动态分配的内存和其他资源。 不带有任何参数 拷贝函数 用一个已知的对象去初始化未知对象 浅复制赋值类的对象时，复制的是其指针，而不是指向的缓冲区，结果是两个对象指向同一块动态分配的内存，销毁其中一个，会导致另有一个对象的指针拷贝无效，威胁程序的稳定性。 而深复制是将当前对象指向的内容复制给当前对象新分配的内存当中。 指向类的指针 一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **-&gt;**，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。 #include &lt;iostream&gt; using namespace std;class Box&#123; public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) &#123; cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl; length = l; breadth = b; height = h; &#125; double Volume() &#123; return length * breadth * height; &#125; private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box&#125;;int main(void)&#123; Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 Box *ptrBox; // Declare pointer to a class. // 保存第一个对象的地址 ptrBox = &amp;Box1; // 现在尝试使用成员访问运算符来访问成员 cout &lt;&lt; &quot;Volume of Box1: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl; // 保存第二个对象的地址 ptrBox = &amp;Box2; // 现在尝试使用成员访问运算符来访问成员 cout &lt;&lt; &quot;Volume of Box2: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl; return 0;&#125; 类的静态成员 我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。 静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，在初始化时赋值是一个初始值，而在外面定义是分配内存，两者是不一样的。 静态方法没有this指针。 class Box &#123; static int objectCount; //声明&#125;;// 初始化类 Box 的静态成员 其实是定义并初始化的过程int Box::objectCount = 0;//也可这样 定义却不初始化int Box::objectCount; 对象指针date *p;p = &amp;d;d.show(); == d-&gt;show(); == (*p).show(); // 三种表示方法date &amp;w = d; //对象的引用，w为d的别名 对象数组date q[3] = &#123;date(1), date(2), date(0)&#125;; // 在一个类中使用另外一个类class person&#123; string name; int age; char gender; Date date;\tpublic: Person(string n, int a, char g, int y, int m, int d):date(y,m,d) // 使用了date类 &#123; name = n; age = a; gender = g; &#125; //常成员函数，对象 //void show() const 加上const后不再允许对函数进行修改 void show()] &#123; cout &lt;&lt; name &lt;&lt; age &lt;&lt; gender &lt;&lt; endl; date.show(); &#125;&#125;;int main()&#123; Person p(&quot;sam&quot;, 18, &quot;m&quot;, 1, 1, 1); p.show(); return 0;&#125; static为所有对象创建一个公有空间 友元类&amp;函数 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。 尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend class Box&#123; double width;public: double length; friend void printWidth( Box box ); friend class Bigbox; void setWidth( double wid );&#125;;class Bigbox&#123; public: void Print(int width, Box &amp;box) &#123; box.setWidth(width); cout &lt;&lt; &quot;Width of box:&quot; &lt;&lt; box.width&lt;&lt;endl; &#125;&#125;;// 成员函数定义void Box::setWidth( double wid )&#123; width = wid;&#125; // 请注意：printWidth() 不是任何类的成员函数void printWidth( Box box )&#123; /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;&#125; this指针 this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，拥有其地址，通过它可以访问当前对象的所有成员。 所谓当前对象，是指正在使用的对象。例如对于stu.show();，stu 就是当前对象，this 就指向 stu。 class Box&#123; public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) &#123; cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl; length = l; breadth = b; height = h; &#125; double Volume() &#123; return length * breadth * height; &#125; int compare(Box box) &#123; return this-&gt;Volume() &gt; box.Volume(); &#125; private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box&#125;; int main(void)&#123; Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 if(Box1.compare(Box2)) &#123; cout &lt;&lt; &quot;Box2 is smaller than Box1&quot; &lt;&lt;endl; &#125; else &#123; cout &lt;&lt; &quot;Box2 is equal to or larger than Box1&quot; &lt;&lt;endl; &#125; return 0;&#125; Constructor called. Constructor called. Box2 is equal to or larger than Box1 内联函数 C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。 引入内联函数的目的是为了解决程序中函数调用的效率问题， 这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。 继承 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，您不需要重新编写新的数据成员和成员方法，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类 class Date &#123; private: int year, month, day; public: Date() &#123; year = 0; day = 0; month = 0; &#125; Date(int y, int m, int d) &#123; year = y; month = m; day = d; &#125;&#125;;// 在一个类中使用另外一个类class person&#123; string name; int age; char gender; Date date;\tpublic: Person(string n, int a, char g, int y, int m, int d):date(y,m,d) // 使用了date类 &#123; name = n; age = a; gender = g; &#125; //常成员函数，对象 //void show() const 加上const后不再允许对函数进行修改 void show() &#123; cout &lt;&lt; name &lt;&lt; age &lt;&lt; gender &lt;&lt; endl; date.show(); &#125;&#125;;// 继承class Student:public Person&#123; int grade, score; public: Student(string n, int a, char g, int y, int m, int d,int d, int grade, int s):Person(n,a,y,m,d) &#123; this-&gt;grade = grade; score = s; &#125; void show() &#123; Person::show(); cout&lt;&lt;grade&lt;&lt;score&lt;&lt;endl; &#125; &#125;;int main()&#123; Person p(&quot;Sam&quot;, 18, &quot;m&quot;, 1, 1, 1); p.show(); Student s(&quot;Alex&quot;, 18, &quot;m&quot;, 1, 1, 1); s.show; return 0;&#125; protected继承，派生可以访问基类的对象，但派生的实例（外部类）不可以 private继承，派生类和外部的类都不可以访问基类 使用final可以禁止继承，即被声明为final的类不能作为基类。有时候一个对象已经非常完善，不想被继承，就可以使用final。 继承中的特点有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 1.public 继承：基类不变 2.protected 继承：基类 public-&gt;protected，protected ，private-&gt;private 3.private 继承：基类全变private 但无论哪种继承方式，上面两点都没有改变： 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问 虚继承为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。 虚继承让D里的A只会有一份 多态与虚函数 虚函数class A&#123;public: virtual void foo() &#123; cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl; &#125;&#125;;class B:public A&#123;public: void foo() &#123; cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl; &#125;&#125;;int main(void)&#123; A *a = new B(); a-&gt;foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的! return 0;&#125; 这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。 它虚就虚在所谓”推迟联编”或者”动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。 虚函数只能借助于指针或者引用来达到多态的效果。 析构函数最好使用虚函数是因为基类指向派生类时，不会调用派生类的析构。 使用虚函数解决菱形继承问题时，是在继承方式上选为virtual 多态 Polymorphism C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数，即动态绑定。将派生类对象视为基类对象，并执行派生类实现。 形成多态必须具备三个条件： 1、必须存在继承关系； 2、继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字Virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）； 3、存在基类类型的指针或者引用，通过该指针或引用调用虚函数，到运行时才知道时那个对象； 同一个函数在不同地方形态不同 #include &lt;iostream&gt; using namespace std; class Shape &#123; protected: int width, height; public: virtual Shape( int a=0, int b=0) //多态必须有虚函数 &#123; width = a; height = b; &#125; int area() &#123; cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl; return 0; &#125;&#125;;class Rectangle: public Shape&#123; public: Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125; int area () &#123; cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl; return (width * height); &#125;&#125;;class Triangle: public Shape&#123; public: Triangle( int a=0, int b=0):Shape(a, b) &#123; &#125; int area () &#123; cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl; return (width * height / 2); &#125;&#125;;// 程序的主函数int main( )&#123; Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = &amp;rec; // 调用矩形的求面积函数 area shape-&gt;area(); // 存储三角形的地址 shape = &amp;tri; // 调用三角形的求面积函数 area shape-&gt;area(); return 0;&#125; 赋值兼容性 需要基类对象的任何地方，都可以用公有派生类对象代替。通过公有继承,派生类得到了基类中除构造函数和析构函数以外的所有成员。实际上，公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决 纯虚函数 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 &#x3D;0: 纯虚函数 最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。 class Shape //基类&#123; public: virtual void area() //虚函数 virtual void area() = 0; //纯虚函数 &#123; &#125;&#125;;class Circle:public Shape //派生类&#123; int radius; public: Circle(int r) &#123; radius = r; &#125; void area() //重写父类的area函数 &#123; cout&lt;&lt;&quot;area=&quot;&lt;&lt;3.14*radius*radius&lt;&lt;endl; &#125;&#125;;class Rectangle：public Shape&#123;\tint width, height; public: Rectangle(int w, int h) //构造函数 &#123; width = w; height = h; &#125; void area() &#123; cout&lt;&lt;&quot;area&quot;&lt;&lt;width*height&lt;&lt;endl; &#125;&#125;;void getArea (Shape *p) //如果Shape里的area没有加virtual，则执行原本的，加了则执行多态中的&#123; p-&gt;area();&#125;int main()&#123; Circle c(1); Rectangle r(3,3); getArea(&amp;c); //根据赋值兼容性，用子类代替父类，所以执行时再确定使用的对象是哪一个； return 0;&#125; 抽象类抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。 1. 抽象类的定义： 称带有纯虚函数的类为抽象类。 2. 抽象类的作用： 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。 可用于实例化对象的类被称为具体类 3. 使用抽象类时注意： 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。 如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。 抽象类是不能定义对象的。 // 基类class Shape &#123;public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125;protected: int width; int height;&#125;; // 派生类class Rectangle: public Shape&#123;public: int getArea() //实现纯虚函数 &#123; return (width * height); &#125;&#125;;class Triangle: public Shape&#123;public: int getArea() &#123; return (width * height)/2; &#125;&#125;; 运算符重载 将已有的运算符赋予新的含义，解决特定的问题 我们可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。 重载的运算符是带有特殊名称的函数，函数名是由关键字 **operator **和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表. 如果定义的函数为类的非成员函数，则需要传递两个参数，对于类的成员函数，只需要一个，另一个通常是当前调用的，对于双目运算符。 class Box&#123; public: double getVolume(void) &#123; return length * breadth * height; &#125; void setLength( double len ) &#123; length = len; &#125; void setBreadth( double bre ) &#123; breadth = bre; &#125; void setHeight( double hei ) &#123; height = hei; &#125; // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125; private: double length; // 长度 double breadth; // 宽度 double height; // 高度&#125;;// 程序的主函数int main( )&#123; Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl; return 0;&#125; ++用int来区分前置和后置 不能重载的运算符 **.**：成员访问运算符 .*, **-&gt;***：成员指针访问运算符 **::**：域运算符 sizeof：长度运算符 **?:**：条件运算符 模板模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 **vector **。 比如方法都一样，而数据类型不同 template &lt;typename type&gt; ret-type(返回值) func-name(parameter list)&#123; //函数主体&#125; 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 比较大小 #include &lt;iostream&gt;#include &lt;string&gt; using namespace std;// 一个栗子template &lt;typename T&gt;inline (T const&amp;) Max (T const&amp; a, T const&amp; b) &#123; return a &lt; b ? b:a; &#125; int main ()&#123; int i = 39; int j = 20; cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; double f1 = 13.5; double f2 = 20.7; cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; string s1 = &quot;Hello&quot;; string s2 = &quot;World&quot;; cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; return 0;&#125; 类模板与函数模板一样 template &lt;class/template type&gt; class class-name &#123;&#125; 文件读写 C++ 文件和流 打开文件在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 关闭文件void close(); 写入文件在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 读取文件在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 #include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std; int main ()&#123; char data[100]; // (1)定义输出流对象 //以写模式打开文件 ofstream outfile; outfile.open(&quot;afile.dat&quot;);// open是对象的一个成员 cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Enter your name: &quot;; cin.getline(data, 100); //对象，长度 // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;Enter your age: &quot;; cin &gt;&gt; data; cin.ignore(); //把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。 // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); return 0;&#125; $./a.outWriting to the fileEnter your name: ZaraEnter your age: 9Reading from the fileZara9 关于cin.ignore() 关于 cin.ignore() ，完整版本是 cin.ignore(int n, char a), 从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，则 cin.ignore()函数执行终止；否则，它继续等待。它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。比如可以这么用：cin.ignore(1024,’ ’)，通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 起作用，所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。 other指针数组 首先它是一个数组，其次他的内部存储着指针，可以理解为指针类型的数组 const int MAX = 3;int main ()&#123; int var[MAX] = &#123;10, 100, 200&#125;; int *ptr[MAX]; for (int i = 0; i &lt; MAX; i++) &#123; ptr[i] = &amp;var[i]; // 赋值为整数的地址 &#125; for (int i = 0; i &lt; MAX; i++) &#123; cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; *ptr[i] &lt;&lt; endl; &#125; return 0;&#125;//使用一个char类型的指针数组存储字符串，每个指针数组大小为4#include &lt;iostream&gt; using namespace std;const int MAX = 4; int main ()&#123; const char *names[MAX] = &#123; &quot;Zara Ali&quot;, &quot;Hina Ali&quot;, &quot;Nuha Ali&quot;, &quot;Sara Ali&quot;, &#125;; for (int i = 0; i &lt; MAX; i++) &#123; cout &lt;&lt; &quot;Value of names[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; names[i] &lt;&lt; endl; &#125; return 0;&#125; C++引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护 和指针的区别 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 语法： 类型&amp; 变量名 int&amp; x &#x3D; s; #include &lt;iostream&gt; using namespace std; double vals[] = &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;; double&amp; setValues(int i) &#123; //返回类型是一个引用 double&amp; ref = vals[i]; return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i] &#125; // 要调用上面定义函数的主函数int main ()&#123; cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) &#123; cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; vals[i] &lt;&lt; endl; &#125; setValues(1) = 20.23; // 改变第 2 个元素 setValues(3) = 70.8; // 改变第 4 个元素 cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl; for ( int i = 0; i &lt; 5; i++ ) &#123; cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; vals[i] &lt;&lt; endl; &#125; return 0;&#125;/*vals[0] = 10.1vals[1] = 12.6vals[2] = 33.1vals[3] = 24.1vals[4] = 50改变后的值vals[0] = 10.1vals[1] = 20.23vals[2] = 33.1vals[3] = 70.8vals[4] = 50*/ new ​\tnew操作，创建一个对象并为该对象创建内存空间，最后再返回指向该内存的指针。其空间再堆上 需要注意的是new的使用格式，new出来的是一段空间的首地址。所以一般需要用指针来存放这段地址。 int *a &#x3D; new int(10); &#x2F;&#x2F;动态创建整型数，无参数是 * a&#x3D;0，有参数则 * a &#x3D; 参数 int *p &#x3D; new int[10]; &#x2F;&#x2F;创建一个有10个元素的动态整型数组，没有赋值，元素为随机数 int *p &#x3D; new int[10] (); &#x2F;&#x2F;创建一个有10个元素的动态整型数组，并都赋值为0 int example1()&#123; //可以在new后面直接赋值 int *p = new int(3); //也可以单独赋值 //*p = 3; //如果不想使用指针，可以定义一个变量，在new之前用“*”表示new出来的内容 int q = *new int; q = 1; cout &lt;&lt; q &lt;&lt; endl; return *p;&#125; int* example2()&#123; //当new一个数组时，同样用一个指针接住数组的首地址 int *q = new int[3]; for(int i=0; i&lt;3; i++) q[i] = i; return q;&#125; struct student&#123; string name; int score;&#125;; int *a = new int[5];class A &#123; ...&#125; //声明一个类 AA *obj = new A(); //使用 new 创建对象delete []a;delete obj;/*这里我们注意，new int[5] 仅仅分配了空间， 但是 new A()，不仅仅为对象obj在队上分配了空间， 而且还调用了 A的构造函数，生成了这个对象。所以 new A() 这样方式的功能如下:- 在堆上分配空间- 在分配的空间上调用对象的构造函数（这也是 new 和 malloc的主要区别，是否调用构造函数）*/","tags":["C","C++"],"categories":["记录"]},{"title":"了解CPU底层运行原理","path":"/2021/12/07/认识CPU/","content":"加法一位二进制加法 一个异或门得到本位，一个与门得到进位 多位加法 方案一 有两个以上的1时产生进位 方案二 分为AB相同和AB不同来区分 串行进位全加法器行波进位全加法器 延迟高。需要得到上一个的进位才能计算 并行进位加法器如果单看 进位和本位的计算 通过简单分析，其实进位在输入数据的一瞬间就可以得到 模块化设计","tags":["电子技术","CPU","模电"],"categories":["记录","技术"]},{"title":"布达佩斯大饭店","path":"/2021/05/17/布达佩斯大饭店/","content":"在观看之前,便早早已经听闻过电影的许多特点,比如配乐,构图,色彩搭配……所以我是抱着比较高的期待去的,到整部影片结束时,就故事层面而言,老实讲没有带个我非常大的冲击,或者是感动…… 但很有意思的一点是,在整个观看过程中我牢牢的”抓进”电影中,这很大程度是因为影片讲故事的方式. 一个悬疑类型的故事,搭配上轻快节奏的配乐,再加上美到极致的画面,这种体验我很难用文字描述出来,就…真的非常的享受,你说故事真相吧,我相信大部分很早就猜到了,但伴随着影片不断带来的视觉冲击和出人意料的表达手段,你会不自觉的跟着作者预设的路线走. 对称,强烈的色彩碰撞,色调……我想这部影片被解读最多的部分应该就是他的画面了吧,以至于你在购买商品时会看到”布达佩斯大饭店”配色的选项.的确,人们很难不被导演变态般呈现出的画面所惊艳,","tags":["电影"],"categories":["碎碎念"]},{"title":"windows软件推荐","path":"/2020/01/26/软件推荐/","content":"intro因为搞机多年,从windows7一直被”教育”过来的我,可以负责人的说windos系统如果没有一些”工具类”软件辅助的话,是怎么用都不舒服,再好的硬件都是白搭. 而在列好推荐推荐单并附上安装链接后,我觉得如果就这么丢给他们话,那在这种情况下就算我再怎么说这些软件有多么多么好用,不也是百搭.所以这次不如干脆来个简单梳理,说下我日常使用这些软件的感受和推荐理由,一方面对其他人使用windows可能会有更大的帮助,另一方面在以后推荐时也会更有”底气”了呢…[手动狗头] 需要注意的是下面对每款软件的看法都只是我根据自身的使用情况得出的,和你不同是非常正常的.因为就算抛开什么人生观、价值观…我们基本的使用环境和习惯就不同,所以对你来说只能作为参考. 居家杀人放火必备Chrome关于浏览器的选择似乎一直都是windos用户讨论的一个话题,从各种全家桶浏览器到UC、猎豹、火狐,也用过一段时间Edge,最终选择了chrome,一路过来鬼知道我经历了什么. 其他浏览器这里暂不讨论,说几点我为什么选择chrome: 界面轻便简洁; 突出的置顶标签栏、一个简洁的地址栏、隐藏的收藏栏… 关于chrome的UI设计,我想用两位Google设计师的话: Alex Ainslie:”Chrome被设计为几乎不可见的” Joel Beukelman:”我们的设计动机是，使设计变成更加人性化的一个启动点，而不是仅仅作为搜索的技术切入点。” 浏览性能强大; 墓碑机制、、Blink、学习使用者习惯进行智能调度等机制下,我感受到的就是启动快、占用低、稳定性高…在综合性能上chrome几乎没有对手. 海量优秀插件,总有亿款适合你; 有句话叫”没有插件的chrome不是真正的chrome”,听起来好像有点唬人,但确实如此.笔记、翻译、脚本、广告拦截、翻X…毫不夸张的说,chrome的插件商店比微软的应用商店有用多了. 你们有的,我都有 账号数据同步、密码填充、网页翻译、进程管理、开发者工具页、好用的下载…chrome几乎满足我对浏览器的所有幻想. 与其说是浏览器,我觉得更像是个[系统],就是windows上最好的浏览器,没有之一. Potplayer视频播放器那么多,我为什么推荐Potplayer? 友好的开始 无脑安装,无需设置,打开即用; 界面UI界面、视频打开迅速、播放界面布局规整,不会有任何杂乱的东西,让你的注意力留在内容上. 我第一次用就是这样的感受,对小白非常友好; 播放功能完善 视频、音频、字幕格式的支持属于基础中的基础,而PotPlayer的优势在于内置了多种解码器,几乎可以对所有非加密视频格式直接播放,在此基础下依然保持了小巧的体积. 视频调速或许没什么好说的,PotPlayer默认X和C为调速快捷键,最牛的是能够做到调速不调频,无论以几倍速度播放(最高12倍),声音都不会变成”小黄人”. 视频旋转虽然我几乎不用,但对于经常观看短视频的人来说会变得非常关键. 视频锐化、降噪、消色块等功能或许不经常使用,但PotPalyer都给了你选择. 详尽的设置菜单前面说了PotPlayer对于大部分人都可以”安装即用”,但并不意味它功能少 基础的界面调整,播放、字幕、音频的调整;进阶的有视频补帧、远程播放NAS视频、滤镜设置等等,进入设置后看着各种貌似很牛逼但又看不懂的参数让我觉得一切似乎都没那么简单… PotPlayer最厉害的地方在于它在简洁和复杂之间找到了一个很好的平衡点,不会劝退小白,也能留住大佬,绝对的属于居家杀人放火必备. Bandzip解压缩软件那么多,我为什么选择Bandzip? 界面简洁老牌的WinRAR免费版打开就是广告,还有那”复古”的界面和图标,而Bandzip正好相反,免费使用、无广告、简洁的界面和图标,给人第一印象不会像WinRAR那样恶劣. 特色功能 支持压缩包内文件修改,吹爆; 右键预览压缩包文件; 自动解压并创建文件夹，治愈了解压文件后一下子出现满屏幕文件时的痛苦; 解压速度飞快(Bandzip会先将文件解压到临时文件夹当中，然后再拷贝到你所选择的目标文件夹里,可以减少不必要的等待); 无广告; dism++ 界面简单,操作门槛低. 融入系统清理、启动项管理、驱动管理等许多常用Windows设置与一身、数种系统优化工具于一体; [![88Crxx.md.png](https://s1.ax1x.com/2020/03/15/88Crxx.md.png)](https://imgtu.com/i/88Crxx) 效率工具Listary就搜索本身而言,这款软件我认为做到了快、准、狠 快双击CTRL键就可以在任意界面呼出搜索栏的操作可以快速适应,也不会和其他软件冲突; 呼出迅速,搜索窗口简洁干净; 整个过程都是那么的优雅. 准搜索就是为了快速找到我们想要的文件,对此Listary的几个功能非常值得来说说. 首字母匹配 按文件类型匹配 执行网页搜索,如百度搜索时只需要键入”bd＋空格＋搜索内容”,或者是天猫搜索商品并按销量排序等等等 快速打开常用文件夹 其他如模糊搜索,按打开频率优先匹配等常规功能都一个不落. 详细的配置说明可以 狠免费版基本拥有所有功能…其实主要是为了配合上面两位哥们儿… 这么牛逼的软件windows怎么就不内置它呢? Everything虽然listary可以搜索文件,但everything可以访问NTFS文件系统的USN日志,在数秒内完成搜索硬盘中的文件,并实时监测所有文件的增改情况,所有文件都可以实时显示. 对于搜索文件,强无敌. Feem可以在多设备之间传输文件,快速共享文本,图片和文件,并且延迟极低. (微软应用商店搜索下载) Quick look按住空格键就可以快速预览文件; 预览过程中也可以简单编辑文件; Ditto剪贴板增强软件,可以复制&#x2F;粘贴多条内容.但貌似现在windows10已经原生支持历史剪贴板,win+v即可唤起,对我来说已经没必要安装了. Capslock+我是比较偏向”纯键盘输入”的,因为这可以让我更好的集中注意力,但键盘上的方向键离得太远,不容易盲操作,直到我发现Capslock+后,很大程度上改变了我的使用习惯. 它的设计理念就是将原本不太常用又十分顺手的 Capslock 键改造为和 Ctrl、Alt、Shift 类似的修饰键，实现文本输入增强、窗口切换、快速搜索等功能。 以文本输入为例，通过 Capslock 键配合以下辅助按键实现大部分文本操作需求，不再需要在鼠标和键盘间来回切换。 Capslock + E &#x2F; D &#x2F; S &#x2F; F（上 &#x2F; 下 &#x2F; 左 &#x2F; 右) Capslock + I &#x2F; K &#x2F; J &#x2F; L（上 &#x2F; 下 &#x2F; 左 &#x2F; 右选中文字） Capslock + W &#x2F; R（向左 &#x2F; 右删除文字） Capslock + A &#x2F; G（光标向左 &#x2F; 右跳一个单词，对英文、代码特别有用） Capslock + ; &#x2F; P（移动光标至行首 &#x2F; 行末） Capslock + U &#x2F; O（选中光标至行首 &#x2F; 行末文字） Capslock + Backspace（删除光标所在行所有文字） Capslock + Enter（无论光标是否在行末都能新起一个换行而不截断原句子） …… 此外，Capslock+ 还能实现文本替换、音乐控制、文本翻译、重载程序、转义字符等更多功能， 详细的使用说明可以去官网查看. 格式工厂最熟为人知的格式转换工具. 界面直观(有点丑),上手难度低; 支持文件类型多,什么都能转; 可以简单处理操作文件; 免费; 不过在我使用过程中经常会崩溃,不知道是不是BUG; 在安装时会后捆绑软件需要注意. 系统优化Geek uninstallerwindows在卸载软件后,总会留下一些残余文件,而geek uninstaller可以在卸载后自动扫描残留文件,完成深度卸载; 自身体积非常小,简洁纯净,并且不用安装. Eartrumpet听音乐、看电影、浏览网页媒体… 这些场景间往往都需要频繁调整音量,非常麻烦 现在Eartrumpet可以很好解决这个问题,它可以为软件单独设置音量,或者选择使用哪个麦克风,不会再因为频繁调整音量而烦恼,用了回不去系列. (微软应用商店搜索下载) CCleaner清理垃圾软件那么多,我为什么主要推荐CCleaner? 界面简洁直观它很明白自己是一清理软件,界面设计都为此服务.(比如，你可以在标题栏的位置看到自己的 电脑系统版本、处理器、内存和显卡) “轻松”清理软件左侧分布着: 轻松清理 用起来确实很轻松,垃圾分析和清理过程都非常快,通常就是眼睛扫一遍进度条的时间.清理的内容主要是Windows资源管理器(如最近打开的文档等)、系统(如清空回收站等)、浏览器记录(如历史记录)以及高级(如IIS日志文件等)四项 自定义清理 对系统和软件使用过程中产生的无用文件有详细的分类,配合[轻松清理]基本可以告别垃圾文件. 注册表 windows在安装软件时会生成注册表,但卸载后却会一直存在.CCleaner的注册表允许在清理之前备份,方式清理后产生故障而无法修复. 工具 里面的几个功能都挺使用的,但卸载不支持批量处理,软件更新速度奇慢,重复文件不支持一键删除…希望以后更新能加入. CCleaner分为专业版和免费版,付费版更多优化,基础功能上没有明显区别,但都无广告. 文字书写编辑 Typora个人觉得是windows上最好的markdown编辑器. 好看 界面简洁美观; 多中主题选择; 很”人性化” 多种语法风格选择; 几乎完美的实时预览,真正做到了Hybrid View 右键即可一键添加表格,图片(拖入图片自动添加,网络图片托入自动保存本地) 完整且好用的文件系统(导入支持多种格式文件,导出支持PDF) 专注模式,大纲&#x2F;文件侧边栏 …… 并且完全免费,不过我使用过程总有时在第一次打开文件会突然卡住崩溃,不知道是不是BUG; Typora或许不是windows下最好的markdown编辑器,但是我用的最舒服的一个. 幕布一款以层级折叠式文字来整理内容的大纲文档工具 相对于传统笔记更注重逻辑性,这种形式更加清晰地展现内容之间的逻辑结构，极减少了我们整理格式的压力。 在幕布中每段内容对应一个”主题”,主题与主题之间通过层级形成联系,在这种形式下再搭配少量快捷键,无需鼠标就可以完成大部分操作. 而幕布最具特色的就是可以一键转换脑图形式(思维导图),你可以在行文完毕后思考如何进行层次化梳理,寻找文字背后的逻辑和结构关系. 幕布目前支持网页版、iOS &amp; Android 手机客户端、Windows &amp; Mac 电脑客户端，多平台的支持上也非常给力,基本涵盖了所有常用的设备. 再加上体验良好的云同步,多设备之间的使用体验非常好. 或许幕布的开发者可能考虑到本身使用逻辑不同于传统笔记软件,初次接触可能会不太”友好”,所以在一开始给出了[软件介绍]与[入门指南] 并且里面的内容并不是上来就给你说各种使用技巧、快捷键什么的,而是让初次接触的用户先明白”幕布是什么?可以做什么?”之后再去学习使用,对于新手非常友好这点必须点赞. 我现在是将幕布作为主力笔记本,如果你之前没有使用过类似软件的话,非常值得去体验下. OneNote我并不使用OneNote,不是因为它不好,而是并不适合我… OneNote最吸引我的是笔记页面: 它没有页面大小,拿起笔就可以尽情书写 面板高度自由,可以随意批注、图画 结构化的分类方便查找和复习. 并且都是在接近传统笔记本的书写体验基础下做到的,但是前提是你要有一个平板和一支笔. 而我都没有… 再加上经常抽风的云同步,所以我一般写东西会选择Typora,记笔记用幕布. 当然,提出OneNote并不是为了吐槽,不适合我并不代表不适合你,如果你还没有找到适合自己的笔记软件,不妨可以试试OneNote,这款老牌笔记软件或许会给你一些不一样的体验. 下载IDM是我用过最强大的下载工具. 界面简洁(虽然有点复古);结构化的组织形式 下载文件效应快,且多数都能慢速下载; 下载文件自动分类,这点真的要吹爆; 自带chrome插件,且支持多种下载方式; 唯一的缺点就是需要付费(这是我的问题!!!) Pandownload尽管我经常骂着百度早日倒闭,但不得不承认的是百度云盘几乎变成了现在最重要的网络资源分享渠道,但官方的网盘软件在无会员的情况下几乎处于不可用的状态,而并不便宜的会员价格对于我这样使用频率并不高的人来说[性价比]太低,这时候Pandownload的出现极大程度解决了许多我使用网盘的困惑. 虽然名字中有[download],但我想说在下载方面Pandownload其实并不强大,0到2G之间的小文件下载时多数都可以跑满网速(有小概率翻车),但遇上大文件大概率会翻车导致”回到解放前”,官网给出的说明是”目前百度是针对账号进行限速的，当一个非会员账号下载量达到一定阈值就会触发限速（大概10G左右）。” 那我为什么依然推荐Pandownload? 使用网盘我们不是一上来就下载,在此之前有一个非常痛苦的过程－找资源 虽然早就一些网盘搜索网站,但需要每次打开网页,加载速度稳定性也并不省心,而Pandownload内置了两个搜索平台,资源多、查找速度快、现在寻找资源只需要”输入、过滤、保存&#x2F;下载”,让[找文件]这件事变得如此轻松; 还有如网盘文件清理,搜索历史,不错的UI,自动打开粘贴板链接,稳定的更新等附加Buff,所以对于[网盘下载],Pandownload是我用的最舒服的一个. 先水到这里…","tags":["Windows","软件"],"categories":["碎碎念"]},{"title":"想说些东西,关于手机拍照","path":"/2020/01/24/手机拍照/","content":"intro前几天偶然在便签中看到自己以前没拍成的一期视频逐字稿,看了遍后索性就练练手写出了这篇文章.(主要还是在家太闲了) 随时随地,记录生活点滴抓住一些瞬间，留住一些事物，用新的视角发现周围……发朋友圈装个B？并不需要了解拍照的意义是什么,因为这些对我而言,其实就够了。 理想的记录设备 -手机我们拿手机拍照时，光拍的到还不够，我们也希望还能拍的好(暂且把拍不好这锅甩给设备),又摄的远…这几年来大家都见证了国内社交网络媒体的发展,挑选手机时不再问“是不是真八核?”，而逐渐开始关注起拍照这事儿。厂商也顺应发展趋势一路狂赶，经历从老鸟口中的“捏个影儿”到“4000万像素徕卡”，“潜望式镜头摄月”……现在又蹦出个一亿像素，我们这看着确实是有点“唬人”😂。这眼看“人民日益增长的摄影需求同辣鸡设备之间的矛盾”要解决,可多数消费者选购时还是抛出灵魂拷问，“这玩意儿是真的不？”。 这次我选出了几个常见的宣传词汇,给拿出来掰扯掰扯。 那些营销词汇 8P镜头厂商在发布会上所说的6P，7P的这个P，指的是Plastic，意思是镜头由n个塑料镜片组成. 但事实上因为玻璃(glass)除了透光率以为,在光学折射，热膨胀系数上相比塑料都有天然优势，所以真正的好镜片应该是玻璃的,而少有厂商采用的原因也很简单——贵。😳 不过也不用担心,在手机每年几个亿的销售量下,上游供应链厂商在塑料镜片的技术进步上是非常快,如今差距远没有我们想象的大.并且我们一个消费者在手机上倒也不必在乎那个是P,那个是G,只需要知道镜片在手机相机系统中主要起到过滤杂光和矫正成像的作用,理论上镜片的工艺和成本相同的情况下，镜片的数量越多效果越牛逼. 底大一级压死人 “底”很重要? “底”指的是手机镜头中的图像传感器. 传感器的感光面积越大能带来——捕捉更多光线，获得更强的感光性能，更优的信噪比等等,并且这些影响都是决定性的.这么看似乎的确是能“压死人”，但别忘了手机受制内部空间大小,留给传感器的空间十分有限，不可能像专业相机一样为了画质体积上可以”放飞自我”. 手机上目前“底”最大的ISOCELL Bright HMX传感器有1&#x2F;1.33英寸感光面积，对比常规的1&#x2F;2.55,1&#x2F;2英寸的感光面积，确实算大底，但就算跟残幅的APS-C相机的比,也只然是个弟弟. 型号 有效像素 感光面积（单位：英寸） IMX 586 8000×6000 1&#x2F;2 IMX 363 4032×3024 1&#x2F;2.55 ISOCELL Bright HMX 12032×9024 1&#x2F;1.33 Exmor CMOS sensor 6000×4000 1.8 所以”底大”确实是能”压死人”,但也不要因为迷恋于传感器大小而忽略了优秀的成像素质是相机系统的综合结果.(尤其是子手机上) 定制传感器我的主观看法是定制主要解决的是现有的硬件不能满足厂商对于产品预期目标。 这事儿如果不是某某某企业高管之间的互撕，普通消费者不一定会关注. 举例来说,华为P30 Pro中定制的索尼IMX 607，将色彩滤波阵列(CFA)用感光能力更为优秀的RYYB取代原有RGBG排列的拜尔阵列(Bayer Array)，最终的结构就是夜景画质独孤求败；比如iPhone 11 Pro影像系统中三摄之间默契的配合，超高的动态范围和细节，定制传感器同样功不可没。类似的还有2008年苹果和英特尔联合研发的CPU解决了轻薄本的CPU占用面积大和功耗高的问题——信封中的MacBook.这些案例背后，定制的硬件固然重要，但华为有着麒麟990做背书，打磨三代后的算法；苹果有着地表最强的移动端芯片A13和计算摄影（computational photograpny）加持；所以手机要有优秀的成像素质,那算法，传感器，芯片缺一不可，如果还相信有定制传感器就能够为所欲为，那就真图样图森破了。再说，我们是因为看到[结果]牛逼去关注，试想如果华为RYYB更多的是色偏，iPhone 11 Pro被千元机干翻，定制这事儿还来引来消费者关注吗？ 所以作为消费者没必要在这里费心。 摄像头越多越牛？ 为什么手机没有像相机一样只用一个镜头成像？ 答案其实很简单，因为手机不能更换镜头，很难做到像相机一样可以覆盖人眼在同一位置所看到的所有景物。 综合型三摄 如果以26mm广角＋52mm长焦和13mm超广角为例，三颗镜头对应的视角约为80°，46°，120°，基本覆盖了人眼的视角范围，同时三颗镜头中13mm适合风景,26mm日常,50mm人像经典焦段,应该是最为[实用]的一套配置. TOF战未来?另外TOF镜头现在也厂商采用，如果我们搜索它的应用，你会看到如AR装修，VR游戏，全息影像……这些技术都挺牛X的，或许会再一次改变未来，但可能有点太超前了，以至于目前硬件，应用，市场都没有准备，so如果你的手机有TOF，可以想这是在为[未来]做准备。 潜望式镜头在手机上潜望式镜头可以做出超长焦镜头，超越人眼的视角限制，能拍到我们想拍但看不到的景象. 再以华为P30 Pro为例来看通过潜望式镜头主要实现了什么: 10X混合变焦,50X数码变焦 算拍月亮 1.在变焦上,13倍之间是通过主摄裁切实现,因为主摄本身就有4000万像素,在配合上超分辨抖动算法就能得到比直接裁切更高的清晰度,35倍之间再超分辨率算法的基础上把5倍长焦镜头的画面合成到中央,进一步提升清晰度,五到十倍之间用长焦镜头再加超分辨率算法.2.月亮模式是在变焦系统基础上做出的一个具体到使用场景的应用,通过50X数码变焦拍出一张月亮照片,再通过一套AI算法[优化]后显示到用户屏幕上. 可以看到通过潜望式镜头＋算法可以得到远超过使用普通长焦镜头手机的变焦能力,这点上确实牛逼.But我认为在手机上高倍变焦其实不怎么重要,因为它的应用场景实在是非常有限,并且进一步挤占了内部空间不得不在体积妥协.那潜望式镜头它牛逼吗?从我得知的结果来看确实牛,但我认为潜望式镜头并不适合大部分用户,而拍月亮Emmmm…… 手机多镜头的现状上面说了多摄像头带来的一些进步,但事实上作为大部分人选购目标的中低端手机上,多摄像头更多是作为营销概念存在,为什么这么说呢? 我们看看在京东上1000~2500元价位销量价高的三个品牌不同机型的摄像头配置: 机型 主摄 副摄1 副摄2 副摄3 荣耀9X 广角 景深镜头 &#x2F; &#x2F; 红米K30 广角 超广角 微距镜头 景深镜头 RealmeX2 广角 超广角 微距镜头 景深镜头 红米和reamle四摄中的200万像素微距镜头画质感人(超广角镜头也可以作为微距镜头使用);200万像素景深镜头(负责深度计算的，实现背景虚化,实际并不直接参与成像)可以用超广角代替(理论上只要有比主摄视角更广的镜头，都可以作为景深摄像头);看似四摄,其实跟iPhone11这种双摄没什么区别,而荣耀这边[单摄]可还行? 小结所以摄像头越多拍照越好这种说法是非常极其相当扯淡的. 而且无论是旗舰机还是千元机,大部分照片都是由主摄一颗镜头完成的(iPhone11系列除外),画质好坏主要由主摄决定,副摄更多是起补充焦段作用,不要把多摄手机想的有多神. 大光圈 越大越牛? 表达光线通过镜头速率的参数–光圈 光圈值f&#x2F;&#x3D;焦距&#x2F;孔径 不知道大家知否还记得初中物理的小孔成像，这个”孔”其实就是镜头中的光圈。举个经常听到的栗子，光圈好比水管的口径，光圈越大，水管口径越粗，同时间内流进的水就越多，对应到镜头就是进的光越多。 大光圈的意义主要在于能获得更快的快门速度－手持拍摄不容易糊片,获取更多光线－提升夜景画质,更浅的景深－奶油般化开的背景虚化.但光圈并不是越大越好，大光圈会导致中心画面发红，边缘画质下降，锐度降低，落到照片上就是观感比较”肉”,并且是大底＋大光圈会放大焦平面不平的现象,表现到实际场景中就是拍文档时边缘文字会变模糊.但手机传感器比较小,使得这些负面影响都不明显,最重要的是由于手机光圈基本都是固定不可调节的,所以在手机上大光圈即正义. 等效光圈关于光圈再多说两句,我们平时看到的光圈值只是一个系数,实际进光量多少需要以入射光瞳直径衡量,即同样的虚化效果需要同样的入射光瞳直径. 入射光瞳直径&#x3D;焦距&#x2F;光圈系数 举例来说传感器尺寸为1&#x2F;2.3英寸的手机上,26mm焦距下F1.8的光圈带来的虚化效果相当于全画幅相机的F11,差距非常明显。 所以手机上实现的背景虚化大多时候都是通过算法模拟,而不是靠大光圈. 一亿像素方向错了？ 像素越高画质越好是错的传感器横向像素数×纵向像素数得出的称为有效像素，粗略换算后也就是我们口中所说的多少多少万像素，理论上像素越高，就能扑捉到－更多细节，照片也就会越清晰。 像素:指在由一个数字序列表示的图像中的一个最小单位。 分辨率:指单位长度内像素点的数量，单位通常为像素&#x2F;英寸（ppi） 单个像素面积*像素数量 &#x3D; 传感器感光总面积 Ｂut，这得加一个条件——光线充足.前面说过手机由于内部空间是固定的,传感器尺寸提升空间有限,那通过上面公式我就可以知道,传感器感光面积不变时增加像素总数的结果就是单像素感光面积变小,这样相机在低照度条件下因为获取不到足够的光线,”看东西”就会不清晰,再谈细节就变得毫无意义. 单像素感光面积&#x3D;传感器感光面积&#x2F;像素数量 拿厂商们用了一年的传感器IMX586来说,虽然像素数远高于以往普通传感器,但是单像素感光面积其实很小(0.8um),但是IMX586的默认会像素四合一(1.6um)后以1200万模式输出,但是这样在细节上其实和普通手机拉不开差距,但是你可以强开4800万模式,但是暗光画质会遭重创…(太多但是写法有点抄袭致敬*王跃琨*) 像素数或许没你想得那么重要大多数人要的并不是高像素,而是高细节.所以我们只需要理解,照片细节主要取决于像素数量和每个像素的清晰度.像素清晰度&#x3D;进光量,而进光量取决单像素感光面积,而单像素感光面积其实取决于传感器感光面积,所以厂商选择IMX586并不是应为它像素高,而是因为底大,在手机上高像素只是大底带来的一个副产品. 而像素数量我想说的是,在我们的生活环境中,现在的手机拍出的照片画面细节往往都是超预期的呈现给你,相机画质的瓶颈早就不再是像素数量.为什么这么说呢? 我们的手机屏幕(1080P)只有约200万像素,你家的4K电视也不过800万像素,电影院放映的电影普遍也只有400万像素,而你在看时有没有觉得显示不清晰呢?就算是有着惊为天人显示效果的Pro Display XDR屏幕像素数都不到1200万,所以明白了吗???至于一亿像素方向错没错,你应该自己做出判断. 这里最后,希望你能明白 优秀的照片不是因为放大多少倍以后还能看清细节而被人们记住的. 总结 首先,很高兴你直接从Inor[拖]到总结,完美的忽略了我. 看完上面内容,那先来个简单的总结: 单单是高像素,或者是多摄像头,又或者是大底,都不能得出优秀的拍摄素质. 无论是手机,还是相机,优秀的拍摄素质都是镜头,光圈,传感器,算法等等一套拍摄系统的综合结果.(而手机相比相机硬件提升空间处于劣势,在强大算力支撑下的软件算法就是其优势,并已经开始有弯道超车的势头) 手机的相机系统往往没有绝对的好坏,适合你的才是最好的. 最后对于好的[拍照手机]?大家可以参考爱否的这期视频前半段. 更多的焦段覆盖 更漂亮的色彩 更准的曝光和宽容度 更好的虚化效果 写这篇文章的主要目的,就是想装装逼通过一些常见的营销词汇来对相机拍照的一些基础知识进行简单梳理,能让大家不再被各种参数看蒙蔽,不再轻易被厂商的宣传搞昏了头了,毕竟授人以鱼不如授之以渔.如果你通过这篇文章对拍照产生了点兴趣那我们是同志了. 尾巴写尾巴开始是都点纠结的,经历过一会儿心理斗争,最后还是没忍住写了出来!毕竟能坚持看到这儿的是有耐心的,不怕我啰嗦的 看到它不知道你会想起什么,这是以前在老房子厕所旁用手机拍的.从摄影技法上来说,没什么构图,也看不出什么章法,但对我而言却有着重要的意义.画面中长满苔藓苔藓墙上的破砖瓦,一旁的烂泥墙,从中住着长大,不知修补过多少次的瓦房…在拍摄时我完全没有想到这些承载着过去记忆的事物会这么快便从我的生活中消失,如今看到照片会觉得自己很幸运,因为照片帮我留住一些片段. 对于拍照,现在我只能说:手中的设备怎么样,所处生活的环境如何,是否了解摄影技法,这都不怎么重要,重要的是有没有去[发现],去[记录];手中的设备会变,生活环境会变,对摄影技法的了解会变,不变的是照片的情感表达.","tags":["摄影","手机"],"categories":["碎碎念"]},{"title":"我的第一篇博客","path":"/2020/01/19/我的第一篇博客/","content":"I’m a little used to wandering outside the rain."}]