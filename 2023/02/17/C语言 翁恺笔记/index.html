
<!DOCTYPE html><html lang="zh-Hans">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.2.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>C语言 翁恺学习笔记 - BlueofWarmth</title>

  
    <meta name="description" content="一切的开始">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言 翁恺学习笔记">
<meta property="og:url" content="http://blueofwarmth.github.io/2023/02/17/C%E8%AF%AD%E8%A8%80%20%E7%BF%81%E6%81%BA%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="BlueofWarmth">
<meta property="og:description" content="一切的开始">
<meta property="og:locale">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220123171111202.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/05/1FkOmSuHjoqlEnf.png">
<meta property="og:image" content="c:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220222130609011.png">
<meta property="og:image" content="c:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220222133345453.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/05/P2W1uOhTkcIXiE3.png">
<meta property="og:image" content="c:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220305094333920.png">
<meta property="og:image" content="c:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220305112706398.png">
<meta property="og:image" content="c:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220305113245798.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220309213749172.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310101417702.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310101645585.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310113431903.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310131250365.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310154013727.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220311210740476.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220311214450977.png">
<meta property="og:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220311220805688.png">
<meta property="og:image" content="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220331085344434.png">
<meta property="og:image" content="c:/Users/Qyingli/AppData/Roaming/Typora/typora-user-images/image-20220331093043121.png">
<meta property="og:image" content="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220405093845425.png">
<meta property="og:image" content="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220408164323442.png">
<meta property="og:image" content="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220408170444088.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/xZRalzk5gwLCKQB.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/q2R3i7MuKs49WFX.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/CYeK8gL9xARwyTG.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/bpSe35wQrGCV1UB.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/ZSQhMFjykJfq4YI.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/PwvnMGrBybjUzcd.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/06/thLdv5GNfoY3VcA.png">
<meta property="og:image" content="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220426091756093.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/07/HSJw5fpzVIcLAO1.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/07/kZBCJh9GNxMc46E.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/07/rXWcCIPzlZANwUJ.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/07/CbWyzlJt46kQVFd.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/07/LisQphna51OyfkW.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/07/dAH5aYlXGmSe7TE.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/OjvzeYcVCFLQP8K.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/11/chftVxAPMs4wezl.png">
<meta property="article:published_time" content="2023-02-17T07:44:52.000Z">
<meta property="article:modified_time" content="2024-06-04T10:26:07.121Z">
<meta property="article:author" content="QyingliBoost">
<meta property="article:tag" content="C">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/qyingli/pictureonline/raw/master/image-20220123171111202.png">
  
  
  
  <meta name="keywords" content="C,编程">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/img/photo.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Qyingli</div><div class="sub cap">十号荣耀, 谁不曾不想.</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="社交" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/2023/12/22/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"><span class="title">Java学习笔记 -第二阶段</span></a><a class="item title" href="/2023/12/04/Java%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"><span class="title">Java学习笔记 -第一阶段</span></a><a class="item title" href="/2024/02/04/Java%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/"><span class="title">Java学习笔记 -第三阶段</span></a><a class="item title" href="/2024/02/07/%E4%B8%80,%20%E4%BA%8C%20Maven%20&%20Spring/"><span class="title">Maven & Spring 学习</span></a><a class="item title" href="/2024/02/07/Servlet-JSP/"><span class="title">Servlet & JSP</span></a><a class="item title" href="/2022/03/04/JavaScript%E5%B0%8F%E9%A1%B9%E7%9B%AE--%E9%AA%B0%E5%AD%90%E6%B8%B8%E6%88%8F/"><span class="title">JavaScript小项目--骰子游戏</span></a><a class="item title" href="/2023/06/04/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E4%BB%B6-0-1/"><span class="title">前端三大件项目--美食计划</span></a><a class="item title" href="/2024/05/04/%E5%85%AB%E8%82%A1%E6%96%87Java%E5%9F%BA%E7%A1%80/"><span class="title">Java基础复习</span></a><a class="item title" href="/2023/06/04/Hexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"><span class="title">Hexo 搭建过程记录</span></a><a class="item title" href="/2022/05/04/%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96--%E7%BD%91%E9%A1%B5demo/"><span class="title">网页小项目--日期转化</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E6%8A%80%E6%9C%AF/%E8%AE%B0%E5%BD%95/">记录</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2023-02-17T07:44:52.000Z">2023-02-17</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2024-06-04T10:26:07.121Z">2024-06-04</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>C语言 翁恺学习笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h4 id="两种循环"><a href="#两种循环" class="headerlink" title="两种循环"></a>两种循环</h4><ul>
<li>do-while循环和while循环很像，区别是在循环体执⾏结束的时候才来判断条件。也就是说，⽆论如何，循环都会执⾏⾄少⼀遍，然后再来判断条件。与while循环相同的是，条件满⾜时执⾏循环，条件不满⾜ 时结束循环</li>
<li>注意,在do-while循环中,<br>do<br>{<br>循环体<br>} while (条件)<strong>;</strong></li>
</ul>
<h3 id="循环计算"><a href="#循环计算" class="headerlink" title="循环计算"></a>循环计算</h3><ul>
<li>计算之前先保存原始的值,后面可能有用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="type">int</span> t =x;</span><br></pre></td></tr></table></figure>

<ul>
<li>计数循环</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count =<span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    count --; <span class="comment">// 对于一个变量进行减一的操作.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发射!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="循环应用"><a href="#循环应用" class="headerlink" title="循环应用"></a>循环应用</h2><h3 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> a = rand();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><ul>
<li>每次召唤rand()就得到一个随机的整数</li>
</ul>
<h4 id="100"><a href="#100" class="headerlink" title="%100"></a>%100</h4><ul>
<li>x%n的结果是[0,n-1]的一个整数</li>
</ul>
<h3 id="计算平均数"><a href="#计算平均数" class="headerlink" title="计算平均数"></a>计算平均数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (number != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum += number;</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;d&quot;</span>, &amp;number);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, <span class="number">1.0</span>*sun/count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="keyword">if</span> (number != <span class="number">-1</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        sum += number;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (number != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="整数逆序"><a href="#整数逆序" class="headerlink" title="整数逆序"></a>整数逆序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="type">int</span> digit;</span><br><span class="line"><span class="type">int</span> ret =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(x &gt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    digit =x%<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, digit);</span><br><span class="line">    ret =ret*<span class="number">10</span> + digit; </span><br><span class="line">    x /=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">pritnf(<span class="string">&quot;%d&quot;</span>, ret);</span><br></pre></td></tr></table></figure>

<h1 id="第五周-思想"><a href="#第五周-思想" class="headerlink" title="第五周 思想"></a>第五周 思想</h1><h2 id="第三种循环"><a href="#第三种循环" class="headerlink" title="第三种循环"></a>第三种循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环像一个计数循环:设定一个计数器,初始化它,然后在计数器到达某值之前,重复执行循环体,而每执行一轮循环,计数器值以一定步骤进行调整,比如加1或减1.</p>
<p>for(i&#x3D;0; i&lt;5; i&#x3D;i+1)<br>{<br>    printf(“%d”, i);<br>}</p>
<p>for&#x3D;对于</p>
<ul>
<li>for(count&#x3D;10; count&gt;0; count–)</li>
<li>可以读成:”对于的一开始的count&#x3D;10,当count&gt;0时,重复做循环体,每一轮循环在做完循环体内语句后,使得count–.”</li>
</ul>
<p>小套路</p>
<ul>
<li>做求和的程序时,记录结果的变量应该初始化为0,而做求积变量时,记录结果的变量应该初始化为1.</li>
</ul>
<p>for and while</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	fact *=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">    fact *=i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环</p>
<p>for(初始动作;条件;每轮的动作)<br>{}</p>
<ul>
<li>for中每一个表达式都是可以省略的</li>
</ul>
<p>Tips for loops</p>
<ul>
<li>如果有固定次数,用for;</li>
<li>如果必须执行一次,用do_while;</li>
<li>其他情况用while;</li>
</ul>
<h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="循环控制-1"><a href="#循环控制-1" class="headerlink" title="循环控制"></a>循环控制</h3><p>break vs continue</p>
<ul>
<li>break; 跳出循环</li>
<li>continue; 跳过循环这一轮剩下的语句进入下一轮;</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220123171111202.png" alt="image-20220123171111202"></p>
<h3 id="嵌套的循环"><a href="#嵌套的循环" class="headerlink" title="嵌套的循环"></a>嵌套的循环</h3><h4 id="100以内的素数"><a href="#100以内的素数" class="headerlink" title="100以内的素数"></a>100以内的素数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x cut </span><br><span class="line">x =<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> cut =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cut &lt;<span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> isPrime =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>; i &lt;x; i++)</span><br><span class="line">        <span class="keyword">if</span>(x %i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isPrime =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    cut++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isPrime =<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pirntf(<span class="string">&quot;%d/t&quot;</span>, x);</span><br><span class="line">	<span class="keyword">if</span>(cut &gt;<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套循环时的break"><a href="#嵌套循环时的break" class="headerlink" title="嵌套循环时的break"></a>嵌套循环时的break</h2><h3 id="凑硬币例子"><a href="#凑硬币例子" class="headerlink" title="凑硬币例子"></a>凑硬币例子</h3><ul>
<li>如何用1角,2角和5角的硬币凑出10元以内的金额呢?</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> one, two, five;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (one =<span class="number">1</span>; one &lt;x*<span class="number">10</span>; one ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (two =<span class="number">1</span>; two &lt; x*<span class="number">10</span>/<span class="number">2</span>; two ++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span> (five =<span class="number">1</span>; five &lt; x*<span class="number">10</span>/<span class="number">5</span>; five ++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (one + two + five == x*<span class="number">10</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;可以用%d个1角加%d个2角加%d个5角得到%d元\n&quot;</span>, one, two, five, x);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><ul>
<li>只对它所在的哪层循环做</li>
</ul>
<h4 id="接力break"><a href="#接力break" class="headerlink" title="接力break"></a>接力break</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> one, two, five;</span><br><span class="line"><span class="type">int</span> <span class="built_in">exit</span> =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span> (one =<span class="number">1</span>; one &lt;x*<span class="number">10</span>; one ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (two =<span class="number">1</span>; two &lt; x*<span class="number">10</span>/<span class="number">2</span>; two ++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span> (five =<span class="number">1</span>; five &lt; x*<span class="number">10</span>/<span class="number">5</span>; five ++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (one + two + five == x*<span class="number">10</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;可以用%d个1角加%d个2角加%d个5角得到%d元\n&quot;</span>, one, two, five, x);</span><br><span class="line">               <span class="built_in">exit</span> =<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exit</span> ==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exit</span> ==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> one, two, five;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (one =<span class="number">1</span>; one &lt;x*<span class="number">10</span>; one ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (two =<span class="number">1</span>; two &lt; x*<span class="number">10</span>/<span class="number">2</span>; two ++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span> (five =<span class="number">1</span>; five &lt; x*<span class="number">10</span>/<span class="number">5</span>; five ++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (one + two*<span class="number">2</span> + five*<span class="number">5</span> == x*<span class="number">10</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;可以用%d个1角加%d个2角加%d个5角得到%d元\n&quot;</span>, one, two, five, x);</span><br><span class="line">               <span class="keyword">goto</span> out;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out;</span><br></pre></td></tr></table></figure>

<p>goto语句可以指定到任意位置</p>
<h2 id="循环应用-1"><a href="#循环应用-1" class="headerlink" title="循环应用"></a>循环应用</h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>改变符号，在求和中给出了两种</p>
<p>int sign &#x3D;1;<br>sum +&#x3D;sign*sum;<br>sign&#x3D;-sign;</p>
<p>double sign&#x3D;1.0;<br>sum &#x3D;sign&#x2F;i;<br>sign &#x3D;-sign;</p>
<h3 id="分解整数"><a href="#分解整数" class="headerlink" title="分解整数"></a>分解整数</h3><ul>
<li>输入一个非负整数，正序输出它的每一位数字</li>
</ul>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">sacnf(<span class="string">&quot;%d, &amp;x&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d =x%<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d);</span><br><span class="line">    x /=<span class="number">10</span>；</span><br><span class="line">&#125; <span class="keyword">while</span> (x &gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>做到了倒叙输出，但是没有空格。<br>在解决空格问题的时候，可以添加if语句。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">sacnf(<span class="string">&quot;%d, &amp;x&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d =x%<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d);</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">9</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    x /=<span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>利用if判断解决了空格的问题，但是输出结果依然是逆序的。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">sacnf(<span class="string">&quot;%d, &amp;x&quot;</span>);</span><br><span class="line"></span><br><span class="line">x = <span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span> mask =<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d =x/mask;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d);</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    x %=mask;</span><br><span class="line">    mask /=<span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>首先x除以mask，得到了最高位数字，然后X再以10000取余，得到去除最高位的2345，再将mask降低以为，循环即可得到正序结果。但是这样处理只能计算五位数，如果计算X的位数？</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x =<span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span> mask =<span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	x /=<span class="number">10</span>;</span><br><span class="line">	n++;</span><br><span class="line">&#125; <span class="keyword">while</span> (x&gt;<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n=%d/n&quot;</span>, n);</span><br></pre></td></tr></table></figure>

<p>根据输入的X来输出对应的位数？</p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x =<span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span> mask =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	x /=<span class="number">10</span>;</span><br><span class="line">	mask *=<span class="number">10</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (x&gt;<span class="number">9</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mask);</span><br></pre></td></tr></table></figure>

<p>如果是X&gt;0，会多输出一个0。</p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>如果输出的x是1，那么得到的mask是10 ，因为do-while循环无论怎样，都会先做一轮循环，所以这里应该要用while循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x;</span><br><span class="line">sacnf(&quot;%d&quot;, &amp;x);</span><br><span class="line"></span><br><span class="line">int mask =1;</span><br><span class="line">int t =x;</span><br><span class="line">while (t&gt;9)</span><br><span class="line">&#123;</span><br><span class="line">	t /=10;</span><br><span class="line">	mask *=10;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">	int d =x/mask;</span><br><span class="line">	printf(&quot;%d&quot;, d);</span><br><span class="line">	if (x&gt;9)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	x %=mask;</span><br><span class="line">	mask /=10;</span><br><span class="line">&#125; while (mask&gt;0);</span><br><span class="line">printf(&quot;\n&quot;); </span><br></pre></td></tr></table></figure>



<h3 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h3><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> min;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">	min =b;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	min =a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">int</span> ret =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;min; i++);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a%i ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (b%i ==<span class="number">0</span>)</span><br><span class="line">        ret =i;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d和%d的最大公约数是%d&quot;</span>, a, b, ret);</span><br></pre></td></tr></table></figure>

<h4 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h4><ol>
<li>如果B等于0，计算结束，A就是最大公约数；</li>
<li>否则，计算A除以B的余数，让A等于B，而B等于那个余数；</li>
<li>回到第一步。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> origa =a;</span><br><span class="line"><span class="type">int</span> origb =b;</span><br><span class="line"><span class="keyword">while</span> (b !=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    t =a%b;</span><br><span class="line">    a =b;</span><br><span class="line">    b =t;</span><br><span class="line">&#125;</span><br><span class="line">pirntf(<span class="string">&quot;%d和%d的最大公约数就是%d&quot;</span>, origa, origb, a);</span><br></pre></td></tr></table></figure>

<h1 id="第六周-数据类型"><a href="#第六周-数据类型" class="headerlink" title="第六周 数据类型"></a>第六周 数据类型</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h4><ul>
<li>支持强类型的观点认为明确的类型有助于今早发现程序中的简单错误</li>
<li>反对强类型的观点认为过于强调类型迫使程序员面对底层、实现而非事务逻辑。</li>
<li>总的来说，早期语言强调类型，面向底层的语言强调类型</li>
<li>C语言需要类型，但是对类型的安全检查并不足够</li>
</ul>
<h4 id="C语言的类型"><a href="#C语言的类型" class="headerlink" title="C语言的类型"></a>C语言的类型</h4><ul>
<li><p>整数</p>
<ul>
<li>char, short, int, long, long long</li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li>float, double, long double</li>
</ul>
</li>
<li><p>逻辑</p>
<ul>
<li>bool</li>
</ul>
</li>
<li><p>指针</p>
</li>
<li><p>自定义类型</p>
</li>
</ul>
<h4 id="类型的不同"><a href="#类型的不同" class="headerlink" title="类型的不同"></a>类型的不同</h4><ul>
<li>名称</li>
<li>输入输出时格式化</li>
<li>表达数的范围</li>
<li>内存中所占据的大小 <strong>int就是用来表达寄存器的</strong></li>
<li>内存中的表达形式：二进制数、编码</li>
</ul>
<p>sizeof </p>
<ul>
<li>是一个运算符，给出某个类型或变量在内存中所占据的字节数<ul>
<li>sizeof(int)</li>
<li>sizeof(i)</li>
</ul>
</li>
</ul>
<h3 id="整数的内部表达"><a href="#整数的内部表达" class="headerlink" title="整数的内部表达"></a>整数的内部表达</h3><h4 id="如何表达负数"><a href="#如何表达负数" class="headerlink" title="如何表达负数"></a>如何表达负数</h4><ul>
<li><p>一个字节可以表达的数：</p>
<ul>
<li>00000000–11111111（0-255）</li>
</ul>
</li>
<li><p>三种方案</p>
<ol>
<li>仿照十进制，有一个特殊的标志表示负数</li>
<li>取中间的数为0，如10000000表示0，比他小的是负数，大的是正数。</li>
<li>补码</li>
</ol>
</li>
</ul>
<h4 id="是用补码"><a href="#是用补码" class="headerlink" title="是用补码"></a>是用补码</h4><ul>
<li><p>考虑-1，我们希望-1+1-&gt;0。<strong>什么东西加上1会是0？</strong>**</p>
<ul>
<li>0 -&gt; 00000000</li>
<li>1 -&gt; 00000001</li>
<li>11111111 + 00000001 –&gt; 100000000</li>
</ul>
</li>
<li><p>因为0 - 1 –&gt; - 1，所以</p>
<ul>
<li>(1)00000000 - 00000001 –&gt; 1111 1111 &#x2F;&#x2F;计算机内部是8个bit，多出的那个1会被丢掉</li>
<li>11111111二进制为255，做补码时为-1</li>
<li>同理，对于-a，其补码就是0 - a，实际是2^n ( (1)00000000 ) - a，n是这种类型的位数。</li>
</ul>
</li>
<li><p><strong>补码的意义就是拿补码和原码可以加出一个溢出的”零“。</strong></p>
</li>
</ul>
<h3 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h3><ul>
<li>char: 1字节：-128~127</li>
<li>short: 2字节：-32768~32767</li>
<li>int: 取决于编译器（CPU），通常的意义是“一个字”</li>
<li>long: 4字节</li>
<li>long long :8字节</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">255</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d, i=%d&quot;</span>, c, i);</span><br></pre></td></tr></table></figure>

<h4 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h4><ul>
<li>如果一个字面量常熟想要表达自己是unsigned，可以在后面加u</li>
<li>unsigned的设计初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了<strong>移位</strong></li>
</ul>
<h4 id="整数越界"><a href="#整数越界" class="headerlink" title="整数越界"></a>整数越界</h4><ul>
<li>整数是以纯二进制的方式进行计算的，所以：<ul>
<li>11111111 + 1 -&gt; 100000000 -&gt; 0</li>
<li>01111111 + 1 -&gt; 100000000 -&gt; -128</li>
<li>10000000 - 1 -&gt; 01111111 -&gt; 127</li>
</ul>
</li>
</ul>
<p>127 + 1 &#x3D; -128    -128 - 1 &#x3D; 127<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/07/05/1FkOmSuHjoqlEnf.png"></p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220222130609011.png" alt="image-20220222130609011" style="zoom: 50%;" />

<p>对于U来说255 + 1 &#x3D; 0    0 - 1 &#x3D; 255</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int数据类型最大数是:%u\n&quot;</span>,a<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//直接减一，将%d改为%u。</span></span><br></pre></td></tr></table></figure>

<h3 id="整数的格式化"><a href="#整数的格式化" class="headerlink" title="整数的格式化"></a>整数的格式化</h3><h4 id="8进制和16进制"><a href="#8进制和16进制" class="headerlink" title="8进制和16进制"></a>8进制和16进制</h4><ul>
<li>o开始为8，ox开始为16</li>
<li>%o用于8进制，%ox用于16进制</li>
<li>8进制和16进制只是如何把数字表达为字符串，于内部如何表达数字无关</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220222133345453.png" alt="image-20220222133345453" style="zoom:33%;" />

<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><h4 id="范围-有效数字"><a href="#范围-有效数字" class="headerlink" title="范围 有效数字"></a>范围 有效数字</h4><p>float和double都不能表示接近0附近的数，只是double的这个范围更加小而已。</p>
<p>float是7位有效数字32字长，而double是15位64字长 </p>
<p><strong>如果将%f换成%e，输出结果将以科学计数法表示，e和E效果相同。</strong></p>
<h4 id="输出精度"><a href="#输出精度" class="headerlink" title="输出精度"></a>输出精度</h4><ul>
<li>在%和f之间加上.n可以指定输出小数点后几位，这样的输出是做四舍五入的<ul>
<li>printf(“%.3f\n”, -0.0049);</li>
<li>printf(“%.30f\n”, -0.0049);</li>
</ul>
</li>
</ul>
<p>-0.005 ，49后面并不是0，数学上来说所有数是连续的；计算机来说，最终是离散的表达（普朗克长度），只是double比float更加精确。即计算机无法精确表达小数。</p>
<h4 id="浮点数到底能表示那些数？"><a href="#浮点数到底能表示那些数？" class="headerlink" title="浮点数到底能表示那些数？"></a>浮点数到底能表示那些数？</h4><ul>
<li>printf输出infi表示超过范围的浮点数：正负无穷</li>
<li>printf输出nan表示不存在的浮点数</li>
</ul>
<p>浮点运算的精度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> a, b, c;</span><br><span class="line">a = <span class="number">1.345f</span>;</span><br><span class="line">b = <span class="number">1.234f</span>;</span><br><span class="line">c = a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">2.468</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>)；</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;不想等！c = %.10f,或%f\n&quot;</span>， c,c);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>带小数点的字面量是double而非float</li>
<li>float需要用f或者F后缀来表明身份</li>
<li>f1 &#x3D;&#x3D; f2可能失败</li>
<li>fabs(f1 - f2) &lt; 1e-12 &#x3D;&#x3D; 1.0X10^-12（因为float的精度小于1e-12）</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul>
<li>char是一种个整数，也是一种特殊的类型：字符。<ul>
<li>用单引号表示的字符字面量：‘a’, ‘1’</li>
<li>‘ ‘也是一个字符</li>
<li>printf和scanf里用%c来输入输出字符</li>
</ul>
</li>
</ul>
<h4 id="混合输入"><a href="#混合输入" class="headerlink" title="混合输入"></a>混合输入</h4><ul>
<li><p>有何不同？</p>
<ul>
<li>scanf(“%d %c”, &amp;i, &amp;c);</li>
<li>scanf(“%d%c”, &amp;i, &amp;c);</li>
</ul>
<p>有空格时读完一个整数还要把后面的也读完，没有空格时读完一个整数就结束了</p>
</li>
</ul>
<h4 id="字符计算"><a href="#字符计算" class="headerlink" title="字符计算"></a>字符计算</h4><ul>
<li>一个字符加一个数字得到ASCII码表中那个数之后的字符</li>
<li>两个字符相减，得到他们在表中的距离</li>
</ul>
<h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><ul>
<li>字幕在ASCII表中是顺序排列的</li>
<li>大写字母和小写字母是分开排列的，并不在一起</li>
<li>’a’ - ‘A’可以得到两段之间的距离，于是<ul>
<li>a + ‘a’ - ‘A’可以把一个大写字母变成小写字母，而</li>
<li>a + ‘A’ - ‘a’可以把一个小写字母变成大写字母</li>
</ul>
</li>
</ul>
<h4 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h4><ul>
<li>用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符，这连个字符合起来，组成了一个字符</li>
</ul>
<p>比如printf(“如输入\”“5 7\“ 表示5英尺7英寸：”)；</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>回退一格</td>
<td>\ “</td>
<td>双引号</td>
</tr>
<tr>
<td>\t</td>
<td>到下一个表格位</td>
<td>\ ‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\ \</td>
<td>反斜杠本身</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>制表格</p>
<ul>
<li>每行的固定位置</li>
<li>一个\t使得输出从下一个制表位开始</li>
<li>用\t才能使得上下两行对齐</li>
</ul>
<h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><ul>
<li>当运算符两边出现不一致的类型时，会自动转换较大的类型</li>
<li>对于printf，任何小于int的类型都会转化成int；float会被转换成double</li>
<li>但是scanf不会，要输入short，需要%hd</li>
</ul>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li><p>(类型)值</p>
<ul>
<li>(int)10.3</li>
<li>(short)32</li>
</ul>
<p>只是从那个变量计算出了一个新的类型值，它并不改变那个变量，无论是值还是类型都不会改变</p>
</li>
<li><p>小的变量不能表达大的变量</p>
<ul>
<li>(short)32768</li>
</ul>
</li>
<li><p>强制类型转换的优先级高于四则运算</p>
</li>
</ul>
<h2 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h2><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><ul>
<li>逻辑运算是对逻辑量进行的运算结果只有0 or 1</li>
<li>逻辑量是关系运算或逻辑运算的结果</li>
</ul>
<p>栗子</p>
<ul>
<li>如何判断一个字符c是否是大写字母？<ul>
<li>c &gt;&#x3D; ‘A’ &amp;&amp; c &lt;&#x3D;‘Z’</li>
</ul>
</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (gameover == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p;ayer2move == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Your turn\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gameover == <span class="number">0</span> &amp;&amp; playermove == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your turn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h5><ul>
<li>逻辑运算是自左向右进行的，如果左边结果已经能够决定结果了，就不会做右边的计算<ul>
<li>a &#x3D;&#x3D; 6 &amp;&amp; b &#x3D;&#x3D; 1</li>
<li>a &#x3D;&#x3D; 6 &amp;&amp; b+&#x3D;1</li>
</ul>
</li>
<li>对于&amp;&amp;，左边是false时就不做右边了</li>
<li>对于||，左边时true时就不做右边了</li>
</ul>
<h3 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h3><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><ul>
<li>count &#x3D; (count &gt; 20 ) ? count -10 : count +10;</li>
<li>条件、条件满足时的值和条件不满足时的值</li>
<li>自右向左结合，把所有的分支部分都算明白，再去判断。</li>
<li><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/07/05/P2W1uOhTkcIXiE3.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">	count = count <span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count = count + <span class="number">10</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li>条件运算符的优先级高于赋值运算符，但是低于其他运算符</li>
</ul>
<h4 id="嵌套套件表达式"><a href="#嵌套套件表达式" class="headerlink" title="嵌套套件表达式"></a>嵌套套件表达式</h4><ul>
<li>count &#x3D; ( count &gt; 20 ) ? （count &lt; 50）? count - 10 : count -5 :  (count &lt; 10) ? count +10 : count +5;????</li>
<li>谭浩强直呼内行</li>
</ul>
<h3 id="逗号运算"><a href="#逗号运算" class="headerlink" title="逗号运算"></a>逗号运算</h3><ul>
<li><p>逗号⽤来连接两个表达式，并以其右边的 表达式的值作为它的结果。</p>
</li>
<li><p>逗号的优先级 是所有的运算符中最低的，所以它两边的 表达式会先计算；</p>
</li>
<li><p>逗号的组合关系是⾃左 向右，所以左边的表达式会先计算，⽽右 边的表达式的值就留下来作为逗号运算的结果。 </p>
</li>
<li><p>在for 中使用</p>
<p>for (i &#x3D; 0, j &#x3D; 10; i &lt; j; i++, j–)</p>
</li>
</ul>
<h1 id="第七周-函数"><a href="#第七周-函数" class="headerlink" title="第七周 函数"></a>第七周 函数</h1><h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><h3 id="素数求和"><a href="#素数求和" class="headerlink" title="素数求和"></a>素数求和</h3><ul>
<li>代码复制是程序质量不良的表现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = begin; i&lt;=end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d到%d&quot;</span>的和是%d\n<span class="string">&quot;, begin, end, sum);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    sum(1,10);</span></span><br><span class="line"><span class="string">    sum(20,30);</span></span><br><span class="line"><span class="string">    sum(35,45);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220305094333920.png" alt="image-20220305094333920"  />

<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><ul>
<li>函数名（参数值）</li>
<li>（）起到了表示函数调用的作用<ul>
<li>即使没有参数也需要（）</li>
</ul>
</li>
<li>如果由参数，则需要给出正确的数量和顺序</li>
<li>这些值会按照顺序依次用来初始化函数中的参数</li>
</ul>
<h3 id="从函数中返回"><a href="#从函数中返回" class="headerlink" title="从函数中返回"></a>从函数中返回</h3><h4 id="从函数中返回值"><a href="#从函数中返回值" class="headerlink" title="从函数中返回值"></a>从函数中返回值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        ret =a;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret =b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>return停止函数的执行，并送回一个值<ul>
<li>return;</li>
<li>return表达式</li>
</ul>
</li>
<li>一个函数里可以出现多个return语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = a;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret =b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    a =<span class="number">5</span>;</span><br><span class="line">    b =<span class="number">6</span>;</span><br><span class="line">    c =max(<span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">    c =max(a, b);</span><br><span class="line">    c =max(c, <span class="number">23</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以赋值给变量</li>
<li>可以再传递给函数</li>
<li>甚至可以丢弃<ul>
<li>有时候要的是副作用</li>
</ul>
</li>
</ul>
<h4 id="没有返回值的函数"><a href="#没有返回值的函数" class="headerlink" title="没有返回值的函数"></a>没有返回值的函数</h4><ul>
<li>void 函数名</li>
<li>不能使用带值得return<ul>
<li>可以没有return</li>
</ul>
</li>
<li>调用得时候不能做返回得赋值</li>
<li>如果函数有返回值，则必须使用带值得return</li>
</ul>
<h2 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a>函数的参数和变量</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul>
<li>函数先后关系，C的编译器会自上而下顺序分析你的代码</li>
<li>如果不知道，<br>旧标准会假设所调用的函数所有参数是int，返回的也是int</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span>; <span class="comment">// 声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sum(<span class="number">1</span>,<span class="number">10</span>); <span class="comment">// int sum(int, int)</span></span><br><span class="line">    sum(<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    sum(<span class="number">35</span>,<span class="number">45</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> <span class="comment">// 定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = begin; i&lt;=end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d到%d&quot;</span>的和是%d\n<span class="string">&quot;, begin, end, sum);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数头，以分号“;”结尾，就构成了函数的原型 </p>
</li>
<li><p>函数原型的目的是告诉编译器这个函数⻓什么样 </p>
<ul>
<li><p>名称 </p>
</li>
<li><p>参数（数量及类型）</p>
</li>
<li><p>返回类型</p>
</li>
</ul>
</li>
<li><p>旧标准习惯把函数原型写在调⽤它的函数⾥⾯</p>
</li>
<li><p>现在⼀般写在调⽤它的函数前⾯</p>
</li>
<li><p>原型⾥可以不写参数的名字，但是⼀般仍然写上，方便读者</p>
</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="调用函数-1"><a href="#调用函数-1" class="headerlink" title="调用函数"></a>调用函数</h4><ul>
<li>如果函数有参数，调用该函数时必须传递给它数量、类型正确的值</li>
<li>可以传递给函数的值是表达式的值，这包括：<ul>
<li>字面量</li>
<li>变量</li>
<li>函数的返回值</li>
<li>计算的结果</li>
</ul>
</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220305112706398.png" alt="image-20220305112706398" style="zoom: 50%;" />

<h5 id="类型不匹配"><a href="#类型不匹配" class="headerlink" title="类型不匹配"></a>类型不匹配</h5><ul>
<li>编译器会悄悄地替你把类型转好，但这很可能不是你想要的结果</li>
</ul>
<h4 id="传过去的是什么？"><a href="#传过去的是什么？" class="headerlink" title="传过去的是什么？"></a>传过去的是什么？</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b =<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =%d b =%d&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c只能传值给函数</strong></p>
<h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><ul>
<li>每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系</li>
<li>过去，对于函数参数表中的参数，叫做“形式参数”，调用函数时给的值，叫做“实际参数”</li>
<li>这样会误会实际参数就是实际在函数中进行计算的参数， 误会调用函数的时候把变量而不是值传进去。</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\AppData\Roaming\Typora\typora-user-images\image-20220305113245798.png" alt="image-20220305113245798" style="zoom:33%;" />

<h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><ul>
<li>函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量</li>
<li>定义在函数内部的变量就是本地变量</li>
<li>参数也是本地变量</li>
</ul>
<h4 id="变量的生存期和作用域"><a href="#变量的生存期和作用域" class="headerlink" title="变量的生存期和作用域"></a>变量的生存期和作用域</h4><ul>
<li>生存期：什么时候这个变量开始出现了，到什么时候它消亡了</li>
<li>作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）</li>
<li>对于本地变量，这两个问题的答案是唯一的：大括号内——块</li>
</ul>
<h4 id="本地变量的规则"><a href="#本地变量的规则" class="headerlink" title="本地变量的规则"></a>本地变量的规则</h4><ul>
<li>本地变量是定义在块内的<ul>
<li>它可以是定义在函数的块内</li>
<li>也可以定义在语句的块内</li>
<li>甚至可以随便拉一对大括号来定义变量</li>
</ul>
</li>
<li>程序运行进入这个块内，其中的变量不存在，离开这个块，其中的变量就消失了</li>
<li>块外面定义的变量在里面仍然有效</li>
<li>块里面定义了和外面同名的变量则掩盖了外面的</li>
<li>不能在一个块内定义同名的变量</li>
<li>本地变量不会被默认初始化</li>
<li>参数在进入函数的时候被初始化了</li>
</ul>
<h3 id="函数庶事"><a href="#函数庶事" class="headerlink" title="函数庶事"></a>函数庶事</h3><h4 id="没有参数时"><a href="#没有参数时" class="headerlink" title="没有参数时"></a>没有参数时</h4><ul>
<li>void f(void);</li>
<li>还是</li>
<li>void f();<ul>
<li>在传统的C中，他表示f函数的参数表未知，并不表示没有参数</li>
</ul>
</li>
</ul>
<h4 id="逗号运算符？"><a href="#逗号运算符？" class="headerlink" title="逗号运算符？"></a>逗号运算符？</h4><ul>
<li>调用函数时的逗号和逗号运算符怎么区分？</li>
<li>调用函数时的圆括号里的逗号时标点符号，不是运算符<ul>
<li>f(a,b)</li>
<li>f((a,b))</li>
</ul>
</li>
</ul>
<h4 id="函数里的函数？"><a href="#函数里的函数？" class="headerlink" title="函数里的函数？"></a>函数里的函数？</h4><ul>
<li>C语言不允许函数嵌套定义</li>
</ul>
<h4 id="这是？？"><a href="#这是？？" class="headerlink" title="这是？？"></a>这是？？</h4><ul>
<li><code>int i, j, sum(int a, int b);</code></li>
<li><code>return (i);</code></li>
</ul>
<h4 id="关于main"><a href="#关于main" class="headerlink" title="关于main"></a>关于main</h4><ul>
<li>int main()也是一个函数</li>
<li>要不要写int mian(void)?</li>
<li>retur 0有人看？<ul>
<li>Windows：if errorlevel 1…le</li>
</ul>
</li>
</ul>
<h1 id="第八周-数组"><a href="#第八周-数组" class="headerlink" title="第八周 数组"></a>第八周 数组</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="初识数组"><a href="#初识数组" class="headerlink" title="初识数组"></a>初识数组</h3><ul>
<li>如何写一个程序计算用户输入的数字的平均数，并输出所有大于平均数的数？</li>
<li>必须先记录每一个输入的数字，计算平均数后，再检查记录下来的每一个数字，于平均数相比，决定是否输出<ul>
<li>当然，我们不想这样&#96;int num1, num2, num3, num5, …</li>
</ul>
</li>
</ul>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p><code>int number[100]; scanf(“%d”, number[i]);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> number[<span class="number">50</span>]; <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        number[cnt] = x; <span class="comment">// 对数组中的元素赋值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, cnt);</span><br><span class="line">             <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, number[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += x;</span><br><span class="line">        cnt ++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, sum/cnt);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; cnt; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[i] &gt; sum/cnt) <span class="comment">// 使用数组中的元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number[i]); <span class="comment">// 遍历数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的定义和使用"><a href="#数组的定义和使用" class="headerlink" title="数组的定义和使用"></a>数组的定义和使用</h3><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><ul>
<li>&lt;类型&gt; 变量名称[元素数量]；<ul>
<li>int grades[100];</li>
<li>double weight[20];</li>
</ul>
</li>
<li>元素数量必须是整数；</li>
<li>C99之前：元素数量必须是编译时刻定义的字面量</li>
</ul>
<h4 id="数组-2"><a href="#数组-2" class="headerlink" title="数组"></a>数组</h4><ul>
<li>数组是一种容器（放东西的地方），特点是：<ul>
<li>其中所有的元素具有相同的类型</li>
<li>一旦创建，不能改变大小</li>
<li>*（数组中的元素在内存中是连续依次排列的）</li>
</ul>
</li>
</ul>
<h4 id="int-a-10"><a href="#int-a-10" class="headerlink" title="int a[10]"></a>int a[10]</h4><ul>
<li><p>一个int的数组；</p>
</li>
<li><p>10个单元</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220309213749172.png" alt="image-20220309213749172"></p>
</li>
<li><p>每个单元就是一个int类型的变量</p>
</li>
<li><p>可以出现在赋值的左边或者右边</p>
<ul>
<li>a[2] &#x3D; a[1] + 6;</li>
</ul>
</li>
<li><p>*在赋值左边的叫左值</p>
</li>
</ul>
<h4 id="数组的单元"><a href="#数组的单元" class="headerlink" title="数组的单元"></a>数组的单元</h4><ul>
<li>数组的每个单元就是数组类型的一个变量</li>
<li>使用数组时放在[]的数字叫做索引，索引从0开始计算，也就是定义个10，实际只能使用9个。（程序员从0开始数数）</li>
</ul>
<h4 id="有效的下标范围"><a href="#有效的下标范围" class="headerlink" title="有效的下标范围"></a>有效的下标范围</h4><ul>
<li>编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写</li>
<li>一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃<ul>
<li>segmentation fault</li>
</ul>
</li>
<li>也可能运气好，没造成严重后果</li>
<li>所以我们要保证程序只是使用有效的下标:[0，数组的大小-1]</li>
</ul>
<h4 id="计算平均数-1"><a href="#计算平均数-1" class="headerlink" title="计算平均数"></a>计算平均数</h4><ul>
<li>如果让用户先输入有多少个数字要计算，可以使用C99的新功能</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字的数量：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number[cnt];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        number[cnt] = x;</span><br><span class="line">        sum += x;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输入0到9以内的数字，统计每个数字出现了多少次</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>  number  = <span class="number">10</span>; <span class="comment">// 数组的大小</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> count[number]; <span class="comment">// 定义数组</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++) <span class="comment">// 初始化数组</span></span><br><span class="line">&#123;</span><br><span class="line">    count[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count[x] ++; <span class="comment">// 数组参与运算</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, count[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, i, count[i]); <span class="comment">// 遍历数组输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找出key在数组a中的位置</span></span><br><span class="line"><span class="comment">@param key  need to find number</span></span><br><span class="line"><span class="comment">@param a  need to find array</span></span><br><span class="line"><span class="comment">@param length  array &quot;a&quot; of length</span></span><br><span class="line"><span class="comment">@return if find, return local of &quot;a&quot;; if not find, reutn &quot;-1&quot;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[], <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">24</span>, <span class="number">33</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> loc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    loc = search(x, a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (loc != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>, x, loc);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[], <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组的集成初始化"><a href="#数组的集成初始化" class="headerlink" title="数组的集成初始化"></a>数组的集成初始化</h4><p><code>int a[] = &#123;2, 23, 53, 53, 3, 33, 22, &#125;;</code></p>
<ul>
<li>直接用大括号给出数组的所有元素的初始值</li>
<li>不需要给出数组的大小，编译器会自己数</li>
<li>如果给出了数组的大小，但是后面的初始值数量不足，则其后的元素被初始化为0</li>
</ul>
<h4 id="集成初始化时的定位"><a href="#集成初始化时的定位" class="headerlink" title="集成初始化时的定位"></a>集成初始化时的定位</h4><p><code>int a[10] = &#123;[0] = 2, [2] = 3, 5,&#125;;</code></p>
<ul>
<li>用[n]在初始化的数据中给出定位</li>
<li>没有定位的数据接在前面的位置后面</li>
<li>其他位置的值补零</li>
<li>也可以不给出数组的大小，让编译器算</li>
<li>特别适合初始数据稀疏的数组</li>
</ul>
<h4 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h4><ul>
<li>sizeof 给出整个数组所占据的内容的大小，单位是字节</li>
</ul>
<p>​	<code>sizeof(a)/sizeof(a[0])</code></p>
<ul>
<li>sizeof(a[0])给出数组中单个元素的大小</li>
<li><strong>这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码</strong>**</li>
</ul>
<h4 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h4><p><code>int a[] = &#123;2, 5, 3, 5, 7, 9, &#125;; int b[] = a</code></p>
<ul>
<li>数组变量本身不能被赋值</li>
<li>要把一个数组的所有元素交给另一个数组，必须采用遍历</li>
</ul>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310101417702.png" alt="image-20220310101417702"></p>
<ul>
<li>通常都是使用for循环，让循环变量i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标</li>
<li>常见的错误是：<ul>
<li>循环结束的条件&lt;&#x3D;数组长度，或：</li>
<li>离开循环后，继续用i的值来做数组元素的下标</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310101645585.png" alt="image-20220310101645585"></p>
<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h4 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h4><p>从2到x-1测试是否可以整除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于n要循环n-1遍<ul>
<li>当n很大时就是n遍</li>
</ul>
</li>
</ul>
<p>去掉偶数后，从3到x-1，每次加2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || (x % <span class="number">2</span> ==<span class="number">0</span> &amp;&amp; x !=<span class="number">2</span>) ) </span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; x; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果x是偶数，立刻</li>
<li>否则要循环(n-3)&#x2F;2+1遍<ul>
<li>A当n很大时就是n&#x2F;2遍</li>
</ul>
</li>
</ul>
<p>无须到x-1，到sqrt(x)就够了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || (x % <span class="number">2</span>==<span class="number">0</span> &amp;&amp; x!= <span class="number">2</span>)) </span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; <span class="built_in">sqrt</span>(x); i +=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只需要循环sqrt(x)遍</li>
</ul>
<h4 id="判断是否能被已知的且"><a href="#判断是否能被已知的且" class="headerlink" title="判断是否能被已知的且&lt;x的素数整除"></a>判断是否能被已知的且&lt;x的素数整除</h4><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310113431903.png" alt="image-20220310113431903" style="zoom: 50%;" />

<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310131250365.png" alt="image-20220310131250365" style="zoom: 50%;" />

<h4 id="构造素数表"><a href="#构造素数表" class="headerlink" title="构造素数表"></a>构造素数表</h4><ul>
<li>欲构造n以内的素数表<ol>
<li>令x为2</li>
<li>将2x、3x、4x、直至ax &lt;n的数标记为非素数</li>
<li>令x为下一个没有被标记为素数的数，重复2；直到所有的数都已经尝试完毕</li>
</ol>
</li>
</ul>
<p>伪代码</p>
<ul>
<li>欲构造n以内（不含）的素数表<ol>
<li>开辟prime[n],初始化其所有元素为1，prime[x]1表示x是素数</li>
<li>令x&#x3D;2</li>
<li>如果x是素数，则对于（i&#x3D;2; x*i&lt;n; i++)令prime[i * x]&#x3D;0</li>
<li>令x++,如果x&lt;n,重复3，否则结束</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> maxnumber = <span class="number">25</span>;</span><br><span class="line">    <span class="type">int</span> isPrime[maxnumber];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; maxnumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        isPrime[i] =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i =<span class="number">2</span>; i &lt;maxnumber; i++);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (x =<span class="number">2</span>; x &lt; maxnumber; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i =<span class="number">2</span>; i*x &lt; maxnumber; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                isPrime[i*x] =<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, x);</span><br><span class="line">        <span class="keyword">for</span> (i =<span class="number">2</span>; i &lt;maxnumber; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, isPrime[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">2</span>; i &lt; maxnumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul>
<li>int a[3] [5]</li>
<li>通常理解为a是一个三行五列的矩阵</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220310154013727.png" alt="image-20220310154013727"></p>
<h4 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][j] = i*j; <span class="comment">// 二维数组的赋值方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>a[i] [j]是一个int;</li>
<li>表示第i行第j列上的单元<ul>
<li>a[i,j]???</li>
</ul>
</li>
</ul>
<h4 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] [<span class="number">5</span>] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>列数是必须给出的，行数可以有编译器来求</strong></li>
<li>每行一个{}，逗号分隔</li>
<li>如果省略，表示补零</li>
<li>也可以用定位</li>
</ul>
<h4 id="井字棋游戏"><a href="#井字棋游戏" class="headerlink" title="井字棋游戏"></a>井字棋游戏</h4><ul>
<li>读入一个3X3的矩阵，矩阵中的数字为1表示该位置上有一个X，为0表示为O</li>
<li>程序判断这个矩阵中是否有获胜的一方，输出表示获胜一方的字符X或O，或者无人获胜</li>
</ul>
<p>读入矩阵</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> borad[size] [size];</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> num0fX, num0fO;</span><br><span class="line"><span class="type">int</span> result = <span class="number">-1</span>; <span class="comment">// -1没人赢</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j =<span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;borad[i] [j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>检查行 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; size &amp;&amp; result == <span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    num0fO = num0fX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i] [j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num0fX ++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num0fO ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num0fO == size)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num0fX == size)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j =<span class="number">0</span>; j &lt;size &amp;&amp; result == <span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    num0fX = num0fX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; siez; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (borad[i] [j] ==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num0fX ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            num0fO ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num0fO == size)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> </span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查对角线</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num0fO = num0fX = <span class="number">0</span>; <span class="number">00</span> <span class="number">01</span> <span class="number">02</span></span><br><span class="line">    				 <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line">    				 <span class="number">20</span> <span class="number">21</span> <span class="number">22</span></span><br><span class="line">   	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (borad[i] [i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num0fX ++; </span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            num0fO ++;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (borad[i] [size =i =<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num0fX ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            num0fO ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第九周-指针"><a href="#第九周-指针" class="headerlink" title="第九周 指针"></a>第九周 指针</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a>取地址运算</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符&amp;"></a>运算符&amp;</h4><ul>
<li>scanf(“%d”, &amp;i);里的&amp;</li>
<li>获得变量的地址，它的操作数必须是变量<ul>
<li>int i; printf(“%x”, &amp;x);</li>
</ul>
</li>
<li>地址的大小是否与int相同取决于编译器<ul>
<li>int i; printf(“%p”, &amp;i);</li>
</ul>
</li>
</ul>
<p>&amp;不能取得地址</p>
<ul>
<li>&amp;不能对没有地址的东西取地址<ul>
<li>&amp;(a+b)?</li>
<li>&amp;(a++)?</li>
<li>&amp;(++a)?</li>
</ul>
</li>
</ul>
<p>试试这些&amp;</p>
<ul>
<li>变量的地址</li>
<li>相邻的变量的地址</li>
<li>&amp;的结果的sizeof</li>
<li>数组的地址</li>
<li>数组单元的地址</li>
<li>相邻的数组单元的地址</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220311210740476.png" alt="image-20220311210740476" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><h4 id="想想scanf"><a href="#想想scanf" class="headerlink" title="想想scanf"></a>想想scanf</h4><ul>
<li>如果能够将取得的变量的地址传递给一个函数，能否通过这个地址在那个函数内访问这个变量？<ul>
<li>scanf(“%d”, &amp;i);</li>
</ul>
</li>
<li>scanf()的原型应该是怎样的？我们需要一个参数能保存别的变量的地址，如果表达能够保存地址的变量？</li>
</ul>
<p> 计算机的所有东西都是人做出来的，别人能想的出来的，我也能想的出来。<strong>在计算机里，没有任何黑魔法</strong>，所有的东西只是现在不知道，总会搞明白一切。</p>
<h4 id="就是指针-Point"><a href="#就是指针-Point" class="headerlink" title="就是指针 Point"></a>就是指针 Point</h4><ul>
<li><p>就是保存地址的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>* p = &amp;i;</span><br><span class="line"><span class="type">int</span>* p, q; </span><br><span class="line"><span class="type">int</span> *p, q;</span><br></pre></td></tr></table></figure>

<p>三四行的意思一样，都是表示p是一个指针，而不是p,q都是，四的写法更加好看。</p>
</li>
</ul>
<h4 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h4><ul>
<li>变量的值是内存的地址<ul>
<li>普通变量的值是实际的值；</li>
<li>指针变量的值是具有实际值的变量的地址</li>
</ul>
</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220311214450977.png" alt="image-20220311214450977" style="zoom:50%;" />

<p>作为参数的指针</p>
<ul>
<li>void f(int *p);</li>
<li>在被调用时得到了某个变量的地址；<ul>
<li>int i &#x3D; 0; f(&amp;i);</li>
</ul>
</li>
<li>在函数里面可以通过这个指针访问外面的这个i</li>
</ul>
<p>访问那个地址上的变量* 解引用符号</p>
<ul>
<li>*是一个单目运算符，用来访问指针所表示的地址上的变量</li>
<li>可以作为右值，也可以作为左值<ul>
<li>int k &#x3D; *p;</li>
<li>*p &#x3D; k + 1;</li>
</ul>
</li>
</ul>
<p>左值</p>
<ul>
<li>出现在赋值号左边的不是变量，而是值，是表达式的计算结果</li>
</ul>
<h4 id="指针的运算符"><a href="#指针的运算符" class="headerlink" title="指针的运算符&amp; *"></a>指针的运算符&amp; *</h4><ul>
<li>互相反作用<ul>
<li>*&amp;yptr -&gt; * (&amp;yptr) -&gt; * (yptr的地址) -&gt; 得到那个地址上的变量 -&gt; yptr</li>
<li><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/qyingli/pictureonline/raw/master/image-20220311220805688.png" alt="image-20220311220805688"></li>
</ul>
</li>
</ul>
<p>传入地址</p>
<p><code>int i; scanf(&quot;%d&quot;, i);</code></p>
<ul>
<li>为什么没有报错？</li>
</ul>
<h3 id="指针的应用场景"><a href="#指针的应用场景" class="headerlink" title="指针的应用场景"></a>指针的应用场景</h3><p>交换两个变量的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> swap（<span class="type">int</span> *p, <span class="type">int</span> *q)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过指针在函数中返回多个值</p>
<ul>
<li><p>函数返回多个值，某些值就只能通过指针返回</p>
<ul>
<li>传入的参数实际上是需要保存带回的结果的变量</li>
</ul>
</li>
<li><p>函数返回运算的状态，结果通过指针返回</p>
</li>
<li><p>常用的套路是让函数返回特殊的不属于有效范围的值来表示出错</p>
<ul>
<li>-1或0</li>
</ul>
</li>
<li><p><strong>但是当任何数值都是有效的可能结果时，就得分开返回了</strong>？？？</p>
</li>
</ul>
<h4 id="指针常见的错误"><a href="#指针常见的错误" class="headerlink" title="指针常见的错误"></a>指针常见的错误</h4><ul>
<li>定义了指针变量，还没有指向任何变量，就开始使用指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">k = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">*p = k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *q = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j; </span><br><span class="line">j = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*q = j;</span><br></pre></td></tr></table></figure>

<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><ul>
<li><p>函数参数表中的数组实际上就是指针</p>
<ul>
<li>sizeof(a) &#x3D;&#x3D; sizeof(int *)</li>
<li>但是可以用数组的运算符[]进行运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">55</span>,<span class="number">54</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">66</span>,<span class="number">52</span>,<span class="number">77</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> min, max;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main sizeof(a)=%lu\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main a=%p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    minmax(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]), &amp;max, &amp;min);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=%d,max=%d\n&quot;</span>, min, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minmax sizeof(a)=%lu\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minmax a=%p\n&quot;</span>, a);</span><br><span class="line">    *min = *max = a[<span class="number">0</span>];</span><br><span class="line">    *max = <span class="number">1777</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; *max)</span><br><span class="line">        &#123;</span><br><span class="line">            *max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; *min)</span><br><span class="line">        &#123;</span><br><span class="line">            *min = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h4><ul>
<li>一下四种函数原型是等价的<ul>
<li>int sum(int *ar , int n);</li>
<li>int sum(int *, int);</li>
<li>int sum(int [], int n);</li>
<li>int sum(int [], int);</li>
</ul>
</li>
</ul>
<p><strong>数组变量是特殊的指针</strong></p>
<ul>
<li>数组变量本身表达地址，所以<ul>
<li>int a[10]; int *p &#x3D; a; &#x2F;&#x2F; 无需取地址符</li>
<li><strong>但是数组的单元表达的是变量，需要用&amp;取地址</strong><ul>
<li>a &#x3D;&#x3D; &amp;a[0]</li>
</ul>
</li>
</ul>
</li>
<li>[]运算符可以对数组做，也可以对指针做：<ul>
<li>p[0] (所指位置上的值取出来，作为指针的值)  &lt;&#x3D;&#x3D;&gt; a[0]</li>
</ul>
</li>
<li>*运算符可以可以对指针做，也可以对数组做：<ul>
<li>*a &#x3D; 23;</li>
</ul>
</li>
<li>数组变量是被const的指针，所以不能被赋值<ul>
<li>int a[] &lt;&#x3D;&#x3D;&gt; int *const a &#x3D;…</li>
</ul>
</li>
</ul>
<h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><h4 id="1-指针是const"><a href="#1-指针是const" class="headerlink" title="1.指针是const"></a>1.指针是const</h4><ul>
<li><strong>表示一旦得到了某个变量的地址，不能再指向其他变量(地址不能再变）</strong><ul>
<li><code>int * const q = &amp;i; //，定义了一个const的指针q</code> </li>
<li>*q &#x3D; 26; &#x2F;&#x2F;OK，可以修改它所指向的值，但是只能指向初始化时设置的地址</li>
<li>q++; &#x2F;&#x2F;ERROR</li>
</ul>
</li>
</ul>
<h4 id="2-所指是cosnt"><a href="#2-所指是cosnt" class="headerlink" title="2.所指是cosnt"></a>2.所指是cosnt</h4><ul>
<li><strong>表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）</strong><ul>
<li>const int *p &#x3D; &i;</li>
<li>*p &#x3D; 26; &#x2F;&#x2F; ERROR! ( * p)是const</li>
<li>i &#x3D; 26; &#x2F;&#x2F;OK</li>
<li>p &#x3D; &j; &#x2F;&#x2F;OK</li>
</ul>
</li>
</ul>
<p>不同的表示：</p>
<p>int i;<br>const int * p1 &#x3D; &i;<br>int const * p2 &#x3D; &i;<br>int * const p3 &#x3D; &i;</p>
<p>判断那个被const了的标志是cosnt在*的前面还是后面。</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul>
<li><p>总是可以把一个非const的值转换成cosnt的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(cosnt <span class="type">int</span>* x)</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line">f(&amp;a); <span class="comment">// OK</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a;</span><br><span class="line"></span><br><span class="line">f(&amp;b); <span class="comment">//OK</span></span><br><span class="line">b = a + <span class="number">1</span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当要传递的参数的类型比地址大的时候，这是常用的手段；既能用比较少的字节串传递给参数，又能避免函数对外面变量的修改</p>
</li>
</ul>
<h4 id="const-数组"><a href="#const-数组" class="headerlink" title="const 数组"></a>const 数组</h4><ul>
<li>cosnt int a[] &#x3D; {1,2,3,4,5,6};</li>
<li>数组变量已经是cosnt的指针了，这里的const表明数组的每个单元都是const int</li>
<li>所以必须通过初始化进行赋值</li>
</ul>
<p>保护数组值</p>
<ul>
<li>因为要把数值传入函数时传递的是地址，所以那个函数内部可以修改数组的值</li>
<li>为了保护数组不被破坏，可以设置参数为cosnt<ul>
<li>int sum(const int a[], int length );</li>
</ul>
</li>
</ul>
<p>int *p;</p>
<p>*p &#x3D; a[0];&#x2F;&#x2F; OK<br>p &#x3D; a[0]; &#x2F;&#x2F; ERROR，p所储存的是地址，这样表示把a[0]的值赋给p,覆盖了原来的的地址，语法错误。</p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><h3 id="指针是可计算的"><a href="#指针是可计算的" class="headerlink" title="指针是可计算的"></a>指针是可计算的</h3><h4 id="1-1-2？"><a href="#1-1-2？" class="headerlink" title="1 + 1 &#x3D; 2？"></a>1 + 1 &#x3D; 2？</h4><ul>
<li><p>给一个指针加1表示要让指针指向下一个变量</p>
<p><code>int a[10]; int *p = a[0]; *(p + 1) -&gt; a[1]</code></p>
<p><code>*(p+n) = a[n]</code></p>
</li>
<li><p>如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义</p>
</li>
</ul>
<p>指针计算</p>
<ul>
<li>可以经行 +, +&#x3D;, -, -&#x3D;</li>
<li>可以++， – 挪到下一个位置去</li>
<li>两个指针可以相减， 得到的是：差值**指针类型大小</li>
</ul>
<p>*p++</p>
<ul>
<li><p>取出p所指的那个数据来，完事之后顺便把p移到下一个位置去</p>
</li>
<li><p>（*的优先级虽然高，但是没有++高）</p>
</li>
<li><p>常用于数组的连续空间操作</p>
</li>
<li><p>在某些CPU上，这可以直接被翻译为一条汇编指令</p>
</li>
</ul>
<p>指针比较</p>
<ul>
<li>&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;都可以对指针做</li>
<li>比较他们在内存中的地址，a[0]的地址比a[1]小</li>
<li>数组中的单元的地址肯定是线性递增的</li>
</ul>
<h4 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h4><ul>
<li>内存中有0地址，但是0地址不能随便碰</li>
<li>所以指针不应该具有0值</li>
<li>因此可以用0地址来表示特殊的事情：<ul>
<li>返回的指针无效</li>
<li>指针没有被真正初始化</li>
</ul>
</li>
<li>NULL（小写不管用）是一个预定定义的符号，表示0的地址（优先使用NULL表示0地址）</li>
</ul>
<p>指针类型的转换</p>
<ul>
<li><p>不同类型的指针不能相互赋值</p>
</li>
<li><p>void* 表示不知道指向什么东西的指针</p>
<ul>
<li>计算式与char*相同（但不相通？？？）</li>
</ul>
</li>
<li><p>指针  也可以转换类型</p>
<ul>
<li><p>int *p &#x3D; &i; void *q &#x3D; (void *)p;</p>
<p>i的类型还是int,但是q这时也指向i，所以通过q去看i时是void型</p>
</li>
</ul>
</li>
<li><p>这里并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量</p>
</li>
</ul>
<h4 id="用指针来做什么？"><a href="#用指针来做什么？" class="headerlink" title="用指针来做什么？"></a>用指针来做什么？</h4><ul>
<li>需要传入较大的数据做参数</li>
<li>传入数组后对数组做操作</li>
<li>函数返回不止一个结果</li>
<li>需要用函数来修改不止一个变量</li>
<li>动态申请的内存…</li>
</ul>
<h3 id="动态内存的分配"><a href="#动态内存的分配" class="headerlink" title="动态内存的分配"></a>动态内存的分配</h3><p>在C99中可以定义一个变量来实现可变数组大小，但是在C99之前是不行的；这时候需要用到malloc</p>
<ul>
<li>使用malloc需要用到新的头文件，&lt;stdlib.h&gt;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> *a;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数量：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="comment">// int a[number]; </span></span><br><span class="line">    a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(number*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 强制类型转换，然后使用malloc定义大小</span></span><br><span class="line">    <span class="keyword">for</span> (i = o; i&lt;= number; i++) <span class="comment">// 读入数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = number<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--) <span class="comment">//逆序输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// 有借有还，再借不难！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p> #include&lt;stdlib.h&gt;</p>
<p>void* malloc(size_t size);</p>
<ul>
<li>向malloc申请的空间的大小是以字节为单位的</li>
<li>返回的结果是void*，需要类型转换为自己需要的类型</li>
<li>(int*)malloc(n *sizeof(int))</li>
<li>计算机no care这个是double还是int，它只认为内存是一片连续的空间</li>
</ul>
<p>没空间了？</p>
<ul>
<li>如果申请失败则返回0，或者叫做NULL</li>
<li>你的系统能给你多少空间?</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>)) )</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分配了%d00的空间&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>指针定义了，就初始化它为0；</strong></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li>申请了没有free-&gt;长时间运行内存逐渐下降<ul>
<li>新手（低情商）：忘了</li>
<li>老手（高情商）：找不到合适的free时机</li>
</ul>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串-2"><a href="#字符串-2" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><p>以0（整数0）结尾的一串字符</p>
</li>
<li><p>0（一个int)或者‘&#x2F;0’（一个字节）是一样的，但是和‘0’不同,这个表示ASCII </p>
</li>
<li><p>0标志字符串结束，但它本身不是字符串的一部分</p>
<ul>
<li>计算字符串长度的时候不包含这个0</li>
</ul>
</li>
<li><p>字符串以数组的形式存在，以数组或指针的形式访问</p>
<ul>
<li>更多的是以指针的形式</li>
</ul>
</li>
<li><p>C语言的字符串是以 字符数组的形态存在的</p>
<ul>
<li>不能用运算符对字符串做运算</li>
<li>通过数组的方式可以遍历字符串</li>
</ul>
</li>
<li><p>唯一特殊的地方是字符串字面量可以用来初始化字符数组</p>
</li>
<li><p>以及标准库提供了一系列字符串函数</p>
</li>
</ul>
<h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><ul>
<li>“Hello” 字符串的字面量</li>
<li>“Hello”会被编译器变成一个字符数组放在某处，这个数组长度是6，<strong>结尾还有表示结束的‘0’</strong>；</li>
<li>两个相邻的字符串常量会被连接起来</li>
</ul>
<h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><p>char * s &#x3D; “hello world!”;</p>
<ul>
<li><p>s是一个指针，初始化为指向一个字符串常量</p>
<ul>
<li>由于这个常量所在的地方，所以实际上s是const char * s，但是由于历史的原因，编译器接受不带const的写法</li>
<li>但是试图对s所指的字符串做写入会造成严重的后果</li>
</ul>
</li>
<li><p>如果需要修改字符串，应该用数组：</p>
<p>char s[] &#x3D; “hello world!”;</p>
</li>
</ul>
<p>指针还是数组?</p>
<ul>
<li><p>char *str &#x3D; “hello”;</p>
</li>
<li><p>char word[] &#x3D; “hello”;</p>
<ul>
<li><p>数组：这个字符串在这里</p>
</li>
<li><p>作为本地变量空间自动被回收</p>
</li>
<li><p>指针：这个字符串不知道在哪里</p>
<ul>
<li>处理参数</li>
<li>动态分配空间</li>
</ul>
</li>
</ul>
</li>
<li><p>char* 不一定是字符串</p>
<ul>
<li>本意是指向字符的指针，可能指向的是字符的数组</li>
<li>只有它所指的字符数组有结尾0的时候，才能说他是字符串</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * s = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="comment">// s = &#x27;8&#x27;;</span></span><br><span class="line"><span class="comment">// s1[0] = 7;</span></span><br><span class="line"><span class="comment">// s = &#x27;salgjag&#x27;;</span></span><br><span class="line">s1[<span class="number">0</span>]= <span class="string">&#x27;jjj&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; s=%p, %s\n&quot;</span>, s, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1=%p, %s\n&quot;</span>, &amp;s1, s1);</span><br></pre></td></tr></table></figure>

<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><h4 id="字符串赋值？"><a href="#字符串赋值？" class="headerlink" title="字符串赋值？"></a>字符串赋值？</h4><ul>
<li>char *t &#x3D; “title”;</li>
<li>char *s;</li>
<li>s &#x3D; t;</li>
<li>并没有产生新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的；</li>
</ul>
<h4 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h4><ul>
<li>scanf读入一个单词，到空格、tab或回车为止</li>
<li>scanf是不安全的，因为不知道要读入的内容长度</li>
</ul>
<p>安全输入</p>
<ul>
<li>scanf(“%Xs”, string);</li>
<li>X表示最多允许读入的字符的数量，这个数字应该比数字的大小减一<ul>
<li>下一次的scanf从哪里开始？</li>
</ul>
</li>
</ul>
<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><ul>
<li>以为char * string就是字符串类型，定义了一个字符串类型的变量就可以直接使用了<ul>
<li>由于没有对string初始化为0，所以不一定每次运行都出错。</li>
</ul>
</li>
</ul>
<p>空字符串</p>
<ul>
<li>char buffer[100] &#x3D; “”;<ul>
<li>一个空的字符串，buffer[0] &#x3D;&#x3D; ‘\0’</li>
</ul>
</li>
<li>char buffer[] &#x3D; “”;<ul>
<li>这个数组的长度是1！！！</li>
</ul>
</li>
</ul>
<h3 id="字符串数组以及程序参数"><a href="#字符串数组以及程序参数" class="headerlink" title="字符串数组以及程序参数"></a>字符串数组以及程序参数</h3><ul>
<li>char **a<ul>
<li>a是个指针，指向另一个指针，那个指针指向一字符串</li>
</ul>
</li>
<li>char a[] []<ul>
<li>a是一个二维数组，第二个维度的大小不知道，不能编译</li>
</ul>
</li>
<li>char a[] [10]<ul>
<li>a是一个二维数组，a[x]是一个char[10]</li>
</ul>
</li>
<li>char * a[]<ul>
<li>a是一个一维数组，a[x]是一个char*</li>
</ul>
</li>
</ul>
<p>iy  &#x3D;  abs(  ix  ); &#x2F;&#x2F;int型</p>
<p>ly  &#x3D;  labs(  lx  ); &#x2F;&#x2F;long型</p>
<p>dy  &#x3D;  fabs(  dx  ); &#x2F;&#x2F;double型</p>
<h4 id="程序参数"><a href="#程序参数" class="headerlink" title="程序参数"></a>程序参数</h4><ul>
<li>int main(int argc, char const *argv[])</li>
<li>argv[0]是命令本事<ul>
<li>当使用Unix的符号，反映符号链接的名字</li>
</ul>
</li>
</ul>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="单字符输入输出"><a href="#单字符输入输出" class="headerlink" title="单字符输入输出"></a>单字符输入输出</h3><ul>
<li>putchar<ul>
<li>int putchar(int c);</li>
<li>向标准输出一个字符</li>
<li>返回写了几个字符，EOF（-1）表示写失败</li>
</ul>
</li>
<li>getchar<ul>
<li>int getchar(void)</li>
<li>从标准输入读入一个字符</li>
<li>返回类型是int是为了返回EOF(-1)<ul>
<li>windows-&gt;ctrl z</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EOF\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>每次只读一个，为什么需要按回车才会返回结果？</p>
<p>shell会有一个行编辑，在没有按回车的时候，shell不会把输人给程序</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220331085344434.png" alt="image-20220331085344434"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:/Users/Qyingli/AppData/Roaming/Typora/typora-user-images/image-20220331093043121.png" alt="image-20220331093043121"></p>
<h3 id="字符串函数strlen"><a href="#字符串函数strlen" class="headerlink" title="字符串函数strlen"></a>字符串函数strlen</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">mylen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[idx] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p><em>p的值没有改变，++改变了P存储的地址，这里的++从逻辑上讲，是让指针指向了下一个内存地址。在这里下一个内存地址就是下一个字节。++完成后，因为循环再次回到判断，做</em>运算，即取值指向的值。const *p允许读取，不允许写入，在整个过程中，没有发生写入。</p>
<ul>
<li>int strcmp（const char *s1, const char *s2);</li>
<li>比较两个字符串，返回：<ul>
<li>0：s1 &#x3D;&#x3D; s2;</li>
<li>大于0：s1 &gt; s2;</li>
<li>小于0；s1 &lt; s2;</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">in <span class="title function_">mycmp</span><span class="params">(cosnt <span class="type">char</span> *s1, cosnt <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s1[idx] == s2[idx] &amp;&amp; s1[idx] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     	idx++;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">while</span> (*s1 == *s2 &amp;&amp; *s1 != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s1++;</span><br><span class="line">        s2++;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> *s1 - *s2;</span><br></pre></td></tr></table></figure>



<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mycpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dst;</span><br><span class="line">    <span class="keyword">while</span> (*dst++ = *src++)</span><br><span class="line">    ;</span><br><span class="line">    *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">mycpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> *<span class="type">char</span> src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (src[idx])</span><br><span class="line">    &#123;</span><br><span class="line">        dst[idx] = src[idx];</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    dst[idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    mycpy(s1,s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>char *strcpy (char *restrict dst, cosnt char *restrict src);</li>
<li>把src的字符串拷贝到dst<ul>
<li>restrict表明src和dst不重叠</li>
</ul>
</li>
<li>返回dst<ul>
<li>为了能链起代码来</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220405093845425.png" alt="image-20220405093845425"></p>
<h4 id="复制一个字符串"><a href="#复制一个字符串" class="headerlink" title="复制一个字符串"></a>复制一个字符串</h4><p>从函数参数得到一个字符串，但实际我们得到的是一个指针，我们不能保证指针指向的那个字符串始终在，所以我们需要把它复制过来。</p>
<p>char *dst &#x3D; (char *)malloc(strlen(src)+1); &#x2F;&#x2F; 加一是为了结尾的0 </p>
<p>strcpy(dst, src);</p>
<h3 id="字符串函数strcat"><a href="#字符串函数strcat" class="headerlink" title="字符串函数strcat"></a>字符串函数strcat</h3><ul>
<li>char *strcat(char *restrict s1, const cahr *restrict s2);</li>
<li>把s2拷贝到s1的后面，接成一个长的字符串</li>
<li>返回s1</li>
<li>s1必须具有足够的空间</li>
<li><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220408164323442.png" alt="image-20220408164323442"></li>
</ul>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><ul>
<li>strcpy和strcat都可能出现安全问题<ul>
<li>如果目的地没有足够的空间？？？</li>
<li>尽量不要使用</li>
</ul>
</li>
</ul>
<p>安全版本</p>
<ul>
<li>char *strncpy(char *restrict dst, const char *restrict src, size_t n);</li>
<li>char *strcat(cahr *restrict s1, const char *restrict s2, size_t n);</li>
<li>int strncmp(const char *s1, const char *s2, size_t n); &#x2F;&#x2F;意思是只比较前n个就得出结论。</li>
</ul>
<h3 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a>字符串搜索函数</h3><ul>
<li>char *strchr(const char *s, int c);  &#x2F;&#x2F; 从左往右</li>
<li>char *strrchr(const char *s, int c); &#x2F;&#x2F; 从右往左</li>
<li>返回NULL表示没有找到</li>
</ul>
<p><strong>如何寻找第二个？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">strchr</span>(s, <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    <span class="type">char</span> *t = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220408170444088.png" alt="image-20220408170444088"></p>
<p>做完之后*p &#x3D; c;什么都没有发生。</p>
<h4 id="字符串中找字符串"><a href="#字符串中找字符串" class="headerlink" title="字符串中找字符串"></a>字符串中找字符串</h4><ul>
<li>char *strstr(const char *s1, const char *s2);</li>
<li>char *strcasrstr(const char *s1, const char *s2);</li>
</ul>
<h1 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h1><h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li>用符号，而不是具体的数字来表示程序中的数字，这件事枚举会比定义独立的const int更加方便</li>
</ul>
<p><code>enum COLOR &#123;RED, YELLOW, GREEN&#125;;</code></p>
<ul>
<li><p>枚举是一种用户定义的数据类型，它用关键字enum以如下语法来声明：</p>
<p><code>enum 枚举类型名字 &#123;名字0， 名字1， ... 名字n&#125;;</code></p>
</li>
<li><p>枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为他们就是常量符号，类型是int，值依次从0递增到n.</p>
</li>
<li><p>当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>red, yellow, green&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span> <span class="params">(<span class="keyword">enum</span> color c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">t</span> =</span> red;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;, &amp;t);</span></span><br><span class="line">    f(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举量可以作为值</li>
<li>枚举类型可以跟上enum作为类型</li>
<li>但是实际上是以整数来做内部计算和外部输入输出的。</li>
</ul>
<h4 id="套路：自动计数的枚举"><a href="#套路：自动计数的枚举" class="headerlink" title="套路：自动计数的枚举"></a>套路：自动计数的枚举</h4><ul>
<li>这样需要遍历所有枚举量或者需要建立一个用枚举量做下标的数组时就很方便。</li>
</ul>
<h4 id="枚举量"><a href="#枚举量" class="headerlink" title="枚举量"></a>枚举量</h4><ul>
<li><p>声明枚举量的时候可以指定值</p>
<ul>
<li><code>enum COLOR &#123;RED=1, YELLOW, GREEN=5&#125;;</code></li>
</ul>
</li>
<li><p>枚举只是int,即使给枚举类型的变量赋不存在的整数值也没有任何warning或者error.</p>
</li>
</ul>
<h4 id="枚举-2"><a href="#枚举-2" class="headerlink" title="枚举"></a>枚举</h4><ul>
<li>虽然枚举类型可以当作类型使用，但是实际上很（bu)少（hao）用</li>
<li>如果有意义上排比的名字，用枚举比const int方便</li>
<li>枚举比宏（macro)好，因为枚举有int类型。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="结构类型-1"><a href="#结构类型-1" class="headerlink" title="结构类型"></a>结构类型</h3><ul>
<li>声明结构类型</li>
</ul>
<p>一个结构就是一个复合的结构类型,一个变量表达这些数据。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/xZRalzk5gwLCKQB.png"></p>
<ul>
<li>注意结尾的分号；</li>
<li>通常会将结构体放在函数外；</li>
</ul>
<h4 id="声明结构的形式"><a href="#声明结构的形式" class="headerlink" title="声明结构的形式"></a>声明结构的形式</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/q2R3i7MuKs49WFX.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/CYeK8gL9xARwyTG.png"></p>
<ul>
<li>结构变量</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/bpSe35wQrGCV1UB.png"></p>
<ul>
<li>结构的初始化<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/ZSQhMFjykJfq4YI.png"></li>
</ul>
<h4 id="结构里的成员"><a href="#结构里的成员" class="headerlink" title="结构里的成员"></a>结构里的成员</h4><ul>
<li>结构和数组有点像</li>
<li>数组用[ ]运算符和下标访问其成员</li>
<li>结构用 “ . “ 运算符和名字访问其成员<ul>
<li>today.day</li>
<li>student.fiestName</li>
<li>pl.y</li>
<li>pl.x</li>
</ul>
</li>
</ul>
<h4 id="结构运算"><a href="#结构运算" class="headerlink" title="结构运算"></a>结构运算</h4><ul>
<li>要访问整个结构，直接用结构变量的名字</li>
<li>对于整个结构，可以做赋值、取地址，也可以传递给函数参数<ul>
<li><code>pl = (struct point)&#123;5,10&#125;; // 相当于pl.x = 5; pl.y = 10;</code></li>
<li><code>p1 = p2; // 相当于p1.x = p2.x; p1.y = p2.y;</code></li>
<li>而数组无法做这种运算</li>
</ul>
</li>
</ul>
<h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><ul>
<li>结构变量的名字并不是结构变量的地址，必须使用&amp;运算符</li>
<li>struct date * pDate &#x3D; &today;</li>
</ul>
<h4 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h4><p>字面量指处符号常量外的常量</p>
<p><code>(type-name）&#123; initializer-list &#125;</code></p>
<p><code>（type-name） &#123; initializer-list , &#125;</code></p>
<ul>
<li>today &#x3D; (struct date) {9,25,2004};</li>
<li>today &#x3D; (struct date) {.month&#x3D;9, .day&#x3D;25, .year&#x3D;2004};</li>
<li>（int [2]){19,20};</li>
</ul>
<h3 id="结构函数"><a href="#结构函数" class="headerlink" title="结构函数"></a>结构函数</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/PwvnMGrBybjUzcd.png"></p>
<ul>
<li>记住页数的经典的东西[狗头]</li>
</ul>
<h4 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h4><p>int numberofDays (strcut date d)</p>
<ul>
<li>整个结构可以作为参数的值传入函数</li>
<li>这时候是在函数内新建一个结构变量，并复制调用者的结构的值</li>
<li>也可以返回一个结构</li>
<li>这与数组不同</li>
</ul>
<h4 id="输入结构"><a href="#输入结构" class="headerlink" title="输入结构"></a>输入结构</h4><ul>
<li><p>没有直接的方式可以一次scanf一个结构</p>
</li>
<li><p>如果写一个函数用来读入结构</p>
</li>
<li><p>但是读入的结构如何传出？？？</p>
</li>
<li><p><strong>解决方案</strong></p>
<ul>
<li>使用指针，因为传入的函数是外面那个结构的克隆体，而不是指针</li>
<li>或者创建一个临时的结构变量，把这个结构返回给调用者</li>
<li>指向结构的指针</li>
<li>相比(*p).month，可以用-&gt;表示指针所指的结构变量中的成员<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/06/thLdv5GNfoY3VcA.png"></li>
</ul>
</li>
</ul>
<h4 id="结构指针参数"><a href="#结构指针参数" class="headerlink" title="结构指针参数"></a>结构指针参数</h4><ul>
<li>好处是传入传出只是一个指针的大小</li>
<li>如果需要保护传入的结果不被函数修改<ul>
<li>const struct point *p</li>
</ul>
</li>
<li><strong>返回传入的指针是一种套路</strong>，这样可以少用一次P，因为后续可能有其他函数需要这个结构的地址。让程序更加简洁。</li>
</ul>
<h3 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[] =</span> &#123;&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2002</span>&#125;, &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">2003</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dateAndTime</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">sdate</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">stiem</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="嵌套的结构"><a href="#嵌套的结构" class="headerlink" title="嵌套的结构"></a>嵌套的结构</h4><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>选择：</p>
<p>成员是</p>
<ul>
<li>一个int i还是</li>
<li>一个char c</li>
<li>sizeof(union …) &#x3D; sizeof (每个成员)的最大值</li>
</ul>
<h4 id="联合-1"><a href="#联合-1" class="headerlink" title="联合"></a>联合</h4><ul>
<li>存储<ul>
<li>所有的成员共享一个空间</li>
<li><strong>同一时间只有一个成员是有效的</strong></li>
<li>union的大小是其最大的成员</li>
</ul>
</li>
<li>初始化<ul>
<li>对第一个成员做初始化</li>
</ul>
</li>
</ul>
<p>union自己并不知道当时其中那个成员是有效的</p>
<h4 id="union的用处"><a href="#union的用处" class="headerlink" title="union的用处"></a>union的用处</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch[<span class="keyword">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line">&#125; CHI;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    CHI chi;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    chi.i = <span class="number">1234</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02hhX&quot;</span>, chi.ch[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型定义-1"><a href="#类型定义-1" class="headerlink" title="类型定义"></a>类型定义</h3><h4 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h4><ul>
<li><p>typedef</p>
<p>typedef int Length;</p>
<p>使得Length成为int类型的别名。</p>
</li>
<li><p>Length a, b, kle.</p>
</li>
<li><p>Length numbers[10];</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/Qyingli/pictureonline/raw/master/image-20220426091756093.png" alt="image-20220426091756093"></p>
<p>typedef</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125; Date;</span><br></pre></td></tr></table></figure>

<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li>定义在函数外面的全局变量</li>
<li>全局变量具有全局的生存期和作用域<ul>
<li>它们与任何函数无关</li>
<li>在任何函数内部都可使用它们</li>
</ul>
</li>
</ul>
<h4 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h4><ul>
<li>没有做初始化的全局变量会得到0值<ul>
<li>指针会得到NULL</li>
</ul>
</li>
<li>只能用编译时刻已知的值来初始化全局变量？？？</li>
<li>它们的初始化发生在main函数之前</li>
</ul>
<h4 id="被隐藏的全局变量"><a href="#被隐藏的全局变量" class="headerlink" title="被隐藏的全局变量"></a>被隐藏的全局变量</h4><ul>
<li>如果函数内部存在与全局变量同名的变量，则全局变量被隐藏</li>
</ul>
<h3 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h3><ul>
<li><p>在本地变量定义时加上static修饰符就成为静态本地变量</p>
</li>
<li><p>当函数离开时，静态本地变量会继续存在并保持其值</p>
</li>
<li><p>静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值</p>
</li>
<li><p><strong>静态本地变量实际上是特殊的全局变量</strong></p>
</li>
<li><p>它们位于相同的内存区域</p>
</li>
<li><p>静态本地变量具有全局的生存期，函数内的局部作用域</p>
<ul>
<li>static在这里的意思是局部作用域(本地可访问)</li>
<li>在程序载入内存时就已经为static分配好了内存。</li>
<li>写在函数里面表示只能有这个函数识别。</li>
</ul>
</li>
</ul>
<h3 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *p = f();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);</span><br><span class="line">	g();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">13</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(viod)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">23</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>, k);</span><br><span class="line">&#125;m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>局部变量在自动内存中，第一次输出时候还在，但是调用g函数时，这里的内存被重新使用，挤掉了原来的值。</li>
<li>如果打印i和k的地址会发现他是一样的。</li>
</ul>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li>不要使用全局变量来在函数间传递参数和结果</li>
<li>尽量避免使用全局变量<ul>
<li>丰田汽车的案子</li>
</ul>
</li>
<li>（使用全局变量和静态本地变量的函数是线程不安全的）</li>
</ul>
<h2 id="编译预处理和宏"><a href="#编译预处理和宏" class="headerlink" title="编译预处理和宏"></a>编译预处理和宏</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><h4 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h4><ul>
<li>#开头的是编译预处理指令</li>
<li>它们不是C语言的成分，但是C语言程序离不开它们</li>
<li>#define用来定义一个宏</li>
</ul>
<p>#define</p>
<ul>
<li>#define &lt; name &gt; &lt; zhi &gt;</li>
<li>注意没有结尾的分号，因为不是C的语句</li>
<li>名字必须是一个单词，值可以是各种东西</li>
<li>在C语言的编译器开始编译之前，编译预处理程序会把程序中的名字换成值<ul>
<li>完全的文本替换</li>
</ul>
</li>
</ul>
<h4 id="宏-1"><a href="#宏-1" class="headerlink" title="宏"></a>宏</h4><ul>
<li>如果一个宏的值中有其他宏的名字，也是会被替换的</li>
<li>如果一个宏的值超过一行，最后一行之前的行末需要加\</li>
<li>宏的值后面出现的注释不会被当作宏的值的一部分</li>
</ul>
<p>没有值的宏</p>
<ul>
<li>#define _DEBUG</li>
<li>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了</li>
</ul>
<h4 id="预定义的宏"><a href="#预定义的宏" class="headerlink" title="预定义的宏"></a>预定义的宏</h4><p>带着翅膀的宏</p>
<ul>
<li>_ LINE _</li>
<li>_ FILE _</li>
<li>_ DATE _</li>
<li>_ TIME _</li>
<li>_ STDC _</li>
</ul>
<h3 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h3><ul>
<li>#define cude(x) ((x)<em>(x)</em>(x))</li>
<li>宏可以带参数</li>
<li>引用时cude(4),X会被替换为4</li>
</ul>
<h4 id="错误定义的宏"><a href="#错误定义的宏" class="headerlink" title="错误定义的宏"></a>错误定义的宏</h4><ul>
<li>#define RADTODEG(x) (x*57.29578)</li>
<li>#define RADTODEG(x) (x)*57.29578</li>
</ul>
<h4 id="带参数宏的原则"><a href="#带参数宏的原则" class="headerlink" title="带参数宏的原则"></a>带参数宏的原则</h4><ul>
<li><p>一切都要括号</p>
<ul>
<li>整个值要括号</li>
<li>参数出现的每个地方都要括号</li>
</ul>
</li>
<li><p>#define RADTODEG(x) ((x)*57.29578)</p>
</li>
<li><p>可以带多个参数</p>
<ul>
<li>#define MIN(a,b) ((a)&gt;(b)?(b):(a))</li>
</ul>
</li>
<li><p>也可以组合（嵌套）使用其他宏</p>
</li>
<li><p>在大型程序的代码中使用非常普遍</p>
</li>
<li><p>可以非常复杂，如“产生”函数</p>
<ul>
<li>在#和##的帮助下</li>
</ul>
</li>
<li><p>中西方文化差异[😀]</p>
</li>
<li><p>部分宏会被inline函数代替</p>
</li>
</ul>
<h4 id="其他编译预处理指令"><a href="#其他编译预处理指令" class="headerlink" title="其他编译预处理指令"></a>其他编译预处理指令</h4><ul>
<li>条件编译</li>
<li>error</li>
<li>…</li>
</ul>
<h2 id="大程序文件"><a href="#大程序文件" class="headerlink" title="大程序文件"></a>大程序文件</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><ul>
<li>如果不给出函数原型，编译器会猜测你所调用的函数的所有参数都是int,返回类型也是一样</li>
<li>编译器在编译的时候只看当前的一个编译单元，它不会去看同一个项目中的其他编译单元以找出那个函数的原型</li>
<li>如果你的函数并非如此，程序连接的时候不会出错</li>
<li>但是执行的时候就不对了</li>
<li>所以需要在调用函数的地方给出函数的原型，以告诉编译器那个函数究竟长什么样</li>
</ul>
<h4 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li>把函数原型放在一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器再编译的时候知道函数的原型</li>
<li>在使用和定义这个函数的地方都应该#include这个头文件</li>
<li>一般的做法就是任何.c都有对应的同名.h，把所有对外公开的函数的原型和全局变量的声明都放进去</li>
</ul>
<h4 id="include"><a href="#include" class="headerlink" title="# include"></a># include</h4><ul>
<li>#include是一个编译预处理指令，和宏一样，在编译之前就处理了</li>
<li>它把那个文件的全部文本内容原封不动地插入到它所在地地方<ul>
<li>所以也不是一定要在.c文件地最前面#include</li>
</ul>
</li>
</ul>
<h4 id="“”-还是"><a href="#“”-还是" class="headerlink" title="“” 还是&lt;&gt;"></a>“” 还是&lt;&gt;</h4><ul>
<li>#icnlude有两种形式来指出要插入的文件<ul>
<li>“”要求编译器首先在当前目录（.c文件所在地目录）寻找这个文件，如果没有，到编译器指定的目录去找</li>
<li>&lt;&gt;让编译器只在指定的目录去找</li>
</ul>
</li>
<li>编译器自己知道自己地标准库地头文件在哪里</li>
<li>环境变量和编译器命令行参数也可以指定寻找头文件地目录</li>
</ul>
<h4 id="include的误区"><a href="#include的误区" class="headerlink" title="#include的误区"></a>#include的误区</h4><ul>
<li>#include不是用来引入库的</li>
<li>stdio.h里只有printf的原型，printf的代码在另外的地方</li>
<li>现在的C语言编译器默认会引入所有的标准库</li>
<li>#include&lt;stdio.h&gt;只是为了让编译器知道printf函数的原型，保证你调用的时候给出的参数值是正确的类型</li>
<li>在全局变量前面加上static表示只能在当前的.c文件中使用</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><h4 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h4><ul>
<li>int i; 是变量的定义</li>
<li>extern int i; 是变量的声明</li>
</ul>
<h4 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h4><ul>
<li>声明是不产生代码的东西<ul>
<li>函数原型</li>
<li>变量声明</li>
<li>结构声明</li>
<li>宏声明</li>
<li>枚举声明</li>
<li>类型声明</li>
<li>inline声明</li>
</ul>
</li>
<li>定义是产生代码的东西</li>
</ul>
<h4 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li>只有声明可以被放在头文件中<ul>
<li>是规则不是法律</li>
</ul>
</li>
<li>否则会造成一个项目中多个编译单元里有重名的是实体<ul>
<li>有些编译器允许</li>
</ul>
</li>
</ul>
<h4 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h4><ul>
<li>同一个编译单元里，同名的结构不能被重复声明</li>
<li>如果你的头文件里有结构的声明，很难这个头文件不会再一个编译单元里被#include多次</li>
<li>所以需要“标准头文件结构”</li>
</ul>
<h4 id="标准头文件结构"><a href="#标准头文件结构" class="headerlink" title="标准头文件结构"></a>标准头文件结构</h4><ul>
<li>运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次，带上翅膀<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/07/HSJw5fpzVIcLAO1.png"></li>
</ul>
<h1 id="第十三周-文件"><a href="#第十三周-文件" class="headerlink" title="第十三周 文件"></a>第十三周 文件</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h3><h4 id="flags-width-prec-hlL-type"><a href="#flags-width-prec-hlL-type" class="headerlink" title="%[flags] [width][.prec][hlL]type"></a>%[flags] [width][.prec][hlL]type</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/07/kZBCJh9GNxMc46E.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/07/rXWcCIPzlZANwUJ.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*d\n&quot;</span>,<span class="number">6</span>, <span class="number">123</span>); <span class="comment">// *表示6是用来填充*的</span></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/07/CbWyzlJt46kQVFd.png"></p>
<h4 id="scanf-flag-type"><a href="#scanf-flag-type" class="headerlink" title="scanf: %[flag]type"></a>scanf: %[flag]type</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/07/LisQphna51OyfkW.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%*d%d&quot;</span>, &amp;num);</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/07/dAH5aYlXGmSe7TE.png"></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>有一个东西，里面有俩个部分，一个是数据，一个是指针，这个指针指向另一个相同的东西。这就是链表<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/11/OjvzeYcVCFLQP8K.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">add</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> number)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> Node *phead)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = add(head, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>( number != <span class="number">-1</span> );</span><br><span class="line">    print(head);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="type">int</span> isFound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p=head; p; p=p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;value = number)</span><br><span class="line">        &#123;</span><br><span class="line">            isFound = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到了!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isFound)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没找到!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = head, q=<span class="literal">NULL</span>; p; q=p;p=p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;value == number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( q )</span><br><span class="line">            &#123;</span><br><span class="line">                q-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> head = p-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">add</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> number)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to linked-list</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line"></span><br><span class="line">    p-&gt;value = number;</span><br><span class="line"></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the last</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">last</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( last )</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (last-&gt;next) <span class="comment">//循环结束时，last就是最后哪一个结构。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//head的地址和head指向的那个东西的地址</span></span><br><span class="line"></span><br><span class="line">            last = last-&gt;next; <span class="comment">// 现在last指向最后一个结构中的next。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//attach</span></span><br><span class="line"></span><br><span class="line">        last-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> head = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> Node *phead)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = phead; p; p=p-&gt;next)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://s2.loli.net/2022/06/11/chftVxAPMs4wezl.png"></p>
<h4 id="How-do-we-find-the-boundary"><a href="#How-do-we-find-the-boundary" class="headerlink" title="How do we find the boundary"></a>How do we find the boundary</h4><p>当一个指针出现在arrow的左边时，以为着要使用这个指针，那么就要看看这个指针是否是NULL</p>
<h1 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h1><h2 id="4-0"><a href="#4-0" class="headerlink" title="4.0"></a>4.0</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算机循环的思想</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 计数专用cnt</span></span><br><span class="line">    <span class="type">int</span> i, j, k; <span class="comment">// 就是induce，之后用j, k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = a; i &lt;= a+<span class="number">3</span>; i++ ) <span class="comment">// 输入一个，输出三个，需要有三重循环；从外往内走，到最小时做输出；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = a; j &lt;= a+<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( k = a; k &lt;= a+<span class="number">3</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; j != k &amp;&amp; k != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i*<span class="number">100</span>+j*<span class="number">10</span>+k);</span><br><span class="line">                    cnt++; </span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">6</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                        cnt = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-水仙花数"><a href="#4-1-水仙花数" class="headerlink" title="4.1 水仙花数"></a>4.1 水仙花数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> i,first;</span><br><span class="line">    i = first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        first *= <span class="number">10</span>;</span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">    i = first;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; first*<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = i;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d = t%<span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            sum = <span class="built_in">pow</span>(d,n);</span><br><span class="line">            fin += sum;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( fin == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-九九乘法表"><a href="#4-2-九九乘法表" class="headerlink" title="4.2 九九乘法表"></a>4.2 九九乘法表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> i, j, cnt;</span><br><span class="line">    cnt = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = cnt;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%-4d&quot;</span>, i, j, i*j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">统计给定整数M和N区间内素数的 个数 并对它们 求和</span></span><br><span class="line"><span class="comment">1. 计数 </span></span><br><span class="line"><span class="comment">2. 计数后相加</span></span><br><span class="line"><span class="comment">变量：m,n. sum cnt ,i,j,k.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;m &lt;= n;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( m%<span class="number">2</span> != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> isPrime = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">3</span>; k &lt; m; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m%k == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    isPrime = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( isPrime )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += m;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, cnt, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-0-前N项和"><a href="#5-0-前N项和" class="headerlink" title="5.0 前N项和"></a>5.0 前N项和</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">计算序列 2/1 + 3/2 + 5/3 + 8/5 + ... 的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。</span></span><br><span class="line"><span class="comment">(b+c)/c</span></span><br><span class="line"><span class="comment">n输入计算位数-&gt;一个sum保存和-&gt;一个dynamic计算</span></span><br><span class="line"><span class="comment">计算过程：</span></span><br><span class="line"><span class="comment">只是找一个变量做替换，没有递增。</span></span><br><span class="line"><span class="comment">题目已经给出算法！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">    a = <span class="number">2</span>; b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> sum, dynamic;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a/b;</span><br><span class="line">        dynamic = a;</span><br><span class="line">        a += b;</span><br><span class="line">        b = dynamic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf %lf&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-化简"><a href="#5-1-化简" class="headerlink" title="5.1 化简"></a>5.1 化简</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。</span></span><br><span class="line"><span class="comment">循环（a%i!=0） 找到约数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = a<span class="number">-1</span>; a%i!=<span class="number">0</span>; i--)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">for</span> (j = b<span class="number">-1</span>; b%j!=<span class="number">0</span>; j--)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>,  i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>,  i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="谭8-15-指针"><a href="#谭8-15-指针" class="headerlink" title="谭8.15 指针"></a>谭8.15 指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">四个学生，五门课程成绩，即为一个四行五列的数组。每一行的第0个元素相然后除4.得到第一门课平均分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">float</span> n;</span><br><span class="line">    <span class="type">char</span> score[][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, score[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">avg</span><span class="params">(<span class="type">int</span> score[][<span class="number">5</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *(*(score + i) + <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一门课成绩为：%f&quot;</span>, sum/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组名是数组首元素的地址</p>
<p>*(score+0) &#x3D;&#x3D; score[0] </p>
<p>*((score+0) + 1)&#x2F;&#x2F; 第一个学生的第二门课成绩</p>
</li>
</ul>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>Share</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="http://blueofwarmth.github.io/2023/02/17/C%E8%AF%AD%E8%A8%80%20%E7%BF%81%E6%81%BA%E7%AC%94%E8%AE%B0/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item email" href="mailto:?subject=C语言 翁恺学习笔记 - BlueofWarmth&amp;body=http://blueofwarmth.github.io/2023/02/17/C%E8%AF%AD%E8%A8%80%20%E7%BF%81%E6%81%BA%E7%AC%94%E8%AE%B0/"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;Copied!&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://blueofwarmth.github.io/2023/02/17/C%E8%AF%AD%E8%A8%80%20%E7%BF%81%E6%81%BA%E7%AC%94%E8%AE%B0/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2023/06/04/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E4%BB%B6-0-1/">前端三大件项目--美食计划</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2023/02/17/%E5%9B%9B%E3%80%81SpringMVC%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E8%A1%A8%E8%BF%B0%E5%B1%82%E6%A1%86%E6%9E%B6/">SpringMVC 学习</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">QyingliBoost</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF"><span class="toc-text">两种循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AE%A1%E7%AE%97"><span class="toc-text">循环计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8"><span class="toc-text">循环应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F"><span class="toc-text">猜数游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#100"><span class="toc-text">%100</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E6%95%B0"><span class="toc-text">计算平均数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%80%86%E5%BA%8F"><span class="toc-text">整数逆序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E5%91%A8-%E6%80%9D%E6%83%B3"><span class="toc-text">第五周 思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%BE%AA%E7%8E%AF"><span class="toc-text">第三种循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-text">for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6-1"><span class="toc-text">循环控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">嵌套的循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#100%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0"><span class="toc-text">100以内的素数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E6%97%B6%E7%9A%84break"><span class="toc-text">嵌套循环时的break</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%91%E7%A1%AC%E5%B8%81%E4%BE%8B%E5%AD%90"><span class="toc-text">凑硬币例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break%E5%92%8Ccontinue"><span class="toc-text">break和continue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8A%9Bbreak"><span class="toc-text">接力break</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto"><span class="toc-text">goto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BA%94%E7%94%A8-1"><span class="toc-text">循环应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%92%8C"><span class="toc-text">求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E6%95%B4%E6%95%B0"><span class="toc-text">分解整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-text">1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-text">2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-text">3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-text">4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5"><span class="toc-text">5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6"><span class="toc-text">6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-text">求最大公约数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="toc-text">辗转相除法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E5%91%A8-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第六周 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">类型安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">C语言的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">类型的不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E8%BE%BE"><span class="toc-text">整数的内部表达</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E8%BE%BE%E8%B4%9F%E6%95%B0"><span class="toc-text">如何表达负数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E7%94%A8%E8%A1%A5%E7%A0%81"><span class="toc-text">是用补码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">数的范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unsigned"><span class="toc-text">unsigned</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%B6%8A%E7%95%8C"><span class="toc-text">整数越界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">整数的格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E8%BF%9B%E5%88%B6%E5%92%8C16%E8%BF%9B%E5%88%B6"><span class="toc-text">8进制和16进制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">浮点类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97"><span class="toc-text">范围 有效数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6"><span class="toc-text">输出精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%B0%E5%BA%95%E8%83%BD%E8%A1%A8%E7%A4%BA%E9%82%A3%E4%BA%9B%E6%95%B0%EF%BC%9F"><span class="toc-text">浮点数到底能表示那些数？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6"><span class="toc-text">字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%BE%93%E5%85%A5"><span class="toc-text">混合输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%A1%E7%AE%97"><span class="toc-text">字符计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-text">大小写转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%AD%97%E7%AC%A6"><span class="toc-text">逃逸字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-text">类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%B1%BB%E5%9E%8B"><span class="toc-text">逻辑类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF"><span class="toc-text">短路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-text">条件运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7-1"><span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%A5%97%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">嵌套套件表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97"><span class="toc-text">逗号运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E5%91%A8-%E5%87%BD%E6%95%B0"><span class="toc-text">第七周 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">函数的定义和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-text">素数求和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">调用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E"><span class="toc-text">从函数中返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">从函数中返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">没有返回值的函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-text">函数的参数和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0-1"><span class="toc-text">调用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">类型不匹配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BF%87%E5%8E%BB%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">传过去的是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC"><span class="toc-text">传值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-text">本地变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">变量的生存期和作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">本地变量的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BA%B6%E4%BA%8B"><span class="toc-text">函数庶事</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E6%97%B6"><span class="toc-text">没有参数时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-text">逗号运算符？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">函数里的函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%EF%BC%9F%EF%BC%9F"><span class="toc-text">这是？？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Emain"><span class="toc-text">关于main</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E5%91%A8-%E6%95%B0%E7%BB%84"><span class="toc-text">第八周 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%95%B0%E7%BB%84"><span class="toc-text">初识数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">数组的定义和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84"><span class="toc-text">定义数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-2"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-a-10"><span class="toc-text">int a[10]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%95%E5%85%83"><span class="toc-text">数组的单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E4%B8%8B%E6%A0%87%E8%8C%83%E5%9B%B4"><span class="toc-text">有效的下标范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E6%95%B0-1"><span class="toc-text">计算平均数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">数组的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%9B%86%E6%88%90%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组的集成初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-text">集成初始化时的定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">数组的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-text">数组的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-text">遍历数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0"><span class="toc-text">素数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0"><span class="toc-text">判断素数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%AB%E5%B7%B2%E7%9F%A5%E7%9A%84%E4%B8%94"><span class="toc-text">判断是否能被已知的且&lt;x的素数整除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%B4%A0%E6%95%B0%E8%A1%A8"><span class="toc-text">构造素数表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二维数组的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">二维数组的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%95%E5%AD%97%E6%A3%8B%E6%B8%B8%E6%88%8F"><span class="toc-text">井字棋游戏</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E5%91%A8-%E6%8C%87%E9%92%88"><span class="toc-text">第九周 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97"><span class="toc-text">取地址运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符&amp;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88"><span class="toc-text">什么是指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B3%E6%83%B3scanf"><span class="toc-text">想想scanf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E6%98%AF%E6%8C%87%E9%92%88-Point"><span class="toc-text">就是指针 Point</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-text">指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">指针的运算符&amp; *</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">指针的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">指针常见的错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-text">指针与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0"><span class="toc-text">数组参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8Econst"><span class="toc-text">指针与const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E6%98%AFconst"><span class="toc-text">1.指针是const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%80%E6%8C%87%E6%98%AFcosnt"><span class="toc-text">2.所指是cosnt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2"><span class="toc-text">转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E6%95%B0%E7%BB%84"><span class="toc-text">const 数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-text">指针运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%98%AF%E5%8F%AF%E8%AE%A1%E7%AE%97%E7%9A%84"><span class="toc-text">指针是可计算的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2%EF%BC%9F"><span class="toc-text">1 + 1 &#x3D; 2？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0%E5%9C%B0%E5%9D%80"><span class="toc-text">0地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">用指针来做什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-text">动态内存的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">常见问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-text">字符串常量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F"><span class="toc-text">字符串变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97"><span class="toc-text">字符串运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%8B%E5%80%BC%EF%BC%9F"><span class="toc-text">字符串赋值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">字符串输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-text">常见错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="toc-text">字符串数组以及程序参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="toc-text">程序参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">单字符输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0strlen"><span class="toc-text">字符串函数strlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcmp"><span class="toc-text">strcmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy"><span class="toc-text">strcpy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">复制一个字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0strcat"><span class="toc-text">字符串函数strcat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">安全问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%87%BD%E6%95%B0"><span class="toc-text">字符串搜索函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串中找字符串</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">结构类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-1"><span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-text">套路：自动计数的枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E9%87%8F"><span class="toc-text">枚举量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-2"><span class="toc-text">枚举</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">结构类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-text">声明结构的形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E9%87%8C%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">结构里的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%BF%90%E7%AE%97"><span class="toc-text">结构运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88"><span class="toc-text">结构指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">复合字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">结构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">结构作为函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%84"><span class="toc-text">输入结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0"><span class="toc-text">结构指针参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">结构中的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">嵌套的结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">类型定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88"><span class="toc-text">联合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88-1"><span class="toc-text">联合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-text">union的用处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-1"><span class="toc-text">类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义数据类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-1"><span class="toc-text">全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">全局变量初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">被隐藏的全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-text">静态本地变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">返回指针的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tips"><span class="toc-text">tips</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86%E5%92%8C%E5%AE%8F"><span class="toc-text">编译预处理和宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">编译预处理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F-1"><span class="toc-text">宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F"><span class="toc-text">预定义的宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F"><span class="toc-text">带参数的宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F"><span class="toc-text">错误定义的宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E5%AE%8F%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">带参数宏的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">其他编译预处理指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">大程序文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#include"><span class="toc-text"># include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E2%80%9D-%E8%BF%98%E6%98%AF"><span class="toc-text">“” 还是&lt;&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#include%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-text">#include的误区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-text">声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">变量的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-text">声明和定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-2"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="toc-text">重复声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%A4%B4%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">标准头文件结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E5%91%A8-%E6%96%87%E4%BB%B6"><span class="toc-text">第十三周 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">格式化输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flags-width-prec-hlL-type"><span class="toc-text">%[flags] [width][.prec][hlL]type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scanf-flag-type"><span class="toc-text">scanf: %[flag]type</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#How-do-we-find-the-boundary"><span class="toc-text">How do we find the boundary</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0"><span class="toc-text">编程练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-0"><span class="toc-text">4.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0"><span class="toc-text">4.1 水仙花数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="toc-text">4.2 九九乘法表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3"><span class="toc-text">4.3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-0-%E5%89%8DN%E9%A1%B9%E5%92%8C"><span class="toc-text">5.0 前N项和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%8C%96%E7%AE%80"><span class="toc-text">5.1 化简</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%AD8-15-%E6%8C%87%E9%92%88"><span class="toc-text">谭8.15 指针</span></a></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>Scroll to Top</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>Join Discussion</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
