
<!DOCTYPE html><html lang="zh-Hans">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.2.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>Java学习笔记 -第二阶段 - BlueofWarmth</title>

  
    <meta name="description" content="第十章 面向对象高级类变量和类方法(静态)可以在类任何地方用 类变量可以用类名访问 内存布局 static变量是对象共享,不管static变量在哪里  static变量在类加载的时候就生成了    访问类名.类变量名 对象名.类变量名(推荐) 细节 什么时候使用?  当我们需要让某個类的所有对象都共享一个变量   生命周期随着类  类方法使用 当方法中不涉及 到任何和对象相关的成员,则可以将方法设">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记 -第二阶段">
<meta property="og:url" content="http://blueofwarmth.github.io/2023/12/22/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/index.html">
<meta property="og:site_name" content="BlueofWarmth">
<meta property="og:description" content="第十章 面向对象高级类变量和类方法(静态)可以在类任何地方用 类变量可以用类名访问 内存布局 static变量是对象共享,不管static变量在哪里  static变量在类加载的时候就生成了    访问类名.类变量名 对象名.类变量名(推荐) 细节 什么时候使用?  当我们需要让某個类的所有对象都共享一个变量   生命周期随着类  类方法使用 当方法中不涉及 到任何和对象相关的成员,则可以将方法设">
<meta property="og:locale">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738417.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738689.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738272.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738779.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739703.png">
<meta property="og:image" content="c:\Users\Qyingli\Documents\MarkDown\Code\assets\image-20240116211406473.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739216.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739701.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739029.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739438.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740526.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740452.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740467.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740723.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740635.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041737832.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736855.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736682.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736122.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736863.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736616.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736770.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736495.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736689.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736464.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736729.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735578.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735818.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735556.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735544.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735317.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735177.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735255.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735449.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735487.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734901.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734601.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734000.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734615.png">
<meta property="og:image" content="c:\Users\Qyingli\Documents\MarkDown\Code\assets\image-20240118225704075.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734830.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733805.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733488.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733652.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733429.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733140.png">
<meta property="og:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041732911.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120145152801.png">
<meta property="og:image" content="http://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120171759949.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120172506884.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120172723779.png">
<meta property="og:image" content="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120173044314.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240120174324044.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240120182125097.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121125016223.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121125128578.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121130408910.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240123140231722.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121144354877.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121152400181.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121152517912.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240123143424196.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121215209832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240122134827642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240122135630180.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240123150922126.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240122161911353.png">
<meta property="article:published_time" content="2023-12-22T07:44:52.000Z">
<meta property="article:modified_time" content="2024-06-16T13:19:06.718Z">
<meta property="article:author" content="QyingliBoost">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738417.png">
  
  
  
  <meta name="keywords" content="Java">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/img/photo.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Qyingli</div><div class="sub cap">十号荣耀, 谁不曾不想.</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="社交" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/2024/06/23/JVM-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="title">JVM GC 学习</span></a><a class="item title" href="/2021/03/17/%E6%B8%B8%E6%88%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%9A%E9%92%B1%E7%9A%84%20-%20%E7%A7%91%E6%99%AE%E7%AF%87/"><span class="title">游戏是怎么赚钱的</span></a><a class="item title" href="/2023/01/23/JDBC/"><span class="title">JDBC 学习</span></a><a class="item title" href="/2024/02/07/Servlet-JSP/"><span class="title">Servlet & JSP</span></a><a class="item title" href="/2023/12/22/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"><span class="title">Java学习笔记 -第二阶段</span></a><a class="item title" href="/2023/12/04/Java%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"><span class="title">Java学习笔记 -第一阶段</span></a><a class="item title" href="/2024/02/04/Java%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/"><span class="title">Java学习笔记 -第三阶段</span></a><a class="item title" href="/2024/02/07/%E4%B8%80,%20%E4%BA%8C%20Maven%20&%20Spring/"><span class="title">Maven & Spring 学习</span></a><a class="item title" href="/2022/03/04/JavaScript%E5%B0%8F%E9%A1%B9%E7%9B%AE--%E9%AA%B0%E5%AD%90%E6%B8%B8%E6%88%8F/"><span class="title">JavaScript小项目--骰子游戏</span></a><a class="item title" href="/2023/06/04/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E4%BB%B6-0-1/"><span class="title">前端三大件项目--美食计划</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2023-12-22T07:44:52.000Z">2023-12-22</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2024-06-16T13:19:06.718Z">2024-06-16</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Java学习笔记 -第二阶段</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="第十章-面向对象高级"><a href="#第十章-面向对象高级" class="headerlink" title="第十章 面向对象高级"></a>第十章 面向对象高级</h1><h2 id="类变量和类方法-静态"><a href="#类变量和类方法-静态" class="headerlink" title="类变量和类方法(静态)"></a>类变量和类方法(静态)</h2><p>可以在类任何地方用</p>
<p>类变量可以用类名访问</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><ol>
<li><p>static变量是对象共享,不管static变量在哪里</p>
</li>
<li><p>static变量在类加载的时候就生成了</p>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738417.png" alt="image-20240114151133536"></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>类名.类变量名</p>
<p>对象名.类变量名(推荐)</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol>
<li><p>什么时候使用?</p>
<ol>
<li>当我们需要让某個类的所有对象都共享一个变量</li>
</ol>
</li>
<li><p>生命周期随着类</p>
</li>
<li><p>类方法使用</p>
<p>当方法中不涉及 到任何和对象相关的成员,则可以将方法设计成静态方法,提高开发效率(<strong>不需要创 建对象就可以使用</strong>). 比如工具类方法Math, Array</p>
</li>
</ol>
<h3 id="类方法细节"><a href="#类方法细节" class="headerlink" title="类方法细节"></a>类方法细节</h3><ul>
<li><p>类方法和普通方法都是随着类的加载而加载,将结构信息存储在方法区</p>
</li>
<li><p>类方法中无this参数, 也没有super</p>
</li>
<li><p>普通方法可对象有关,需要通过对象调用(必须在堆中开辟空间)</p>
</li>
<li><p>类方法只能访问静态变量和方法, 而普通成员都可以</p>
</li>
</ul>
<h2 id="main方法语法"><a href="#main方法语法" class="headerlink" title="main方法语法"></a>main方法语法</h2><ol>
<li>Java虚拟机需要调用类的main方法,所以访问权限必须是public</li>
<li>Java虚拟机在执行main方法时不必创建对象,所以方法必须是static</li>
<li>该方法接受String类型的数组参数, 该数组中保存执行Java命令时传递给所有运行类的参数</li>
<li>Java执行的程序参数1 参数2 参数3</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738689.png" alt="image-20240115112926769"></p>
<p>args[]可以接收参数以字符串输出</p>
<ol start="5">
<li>main方法中不能使用非静态成员</li>
</ol>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块属于类中成员,类似于方法, 将逻辑语句封装在方法体中.</p>
<p>没有方法名, 返回, 参数, 只有方法体, 不通过对象或者类显式调用, 而是加载类时, 或创建对象时隐式调用</p>
<p><code>[修饰符]&#123;&#125;;</code> </p>
<ul>
<li>只能写static</li>
<li>分号可以省略</li>
</ul>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>相当于另一种形式的构造器, 或者是对构造器的补充, 可以做初始化的操作</li>
<li>应用场景: 如果多个构造器中都有重复的语句, 可以抽取出来到初始化代码块中, 提高复用率</li>
</ul>
<h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol>
<li>static代码块作用就是对类进行初始化, 随着类的加载而执行, 只执行一次. 普通代码对象创建时执行</li>
<li>类什么时候加载! ! ! :</li>
</ol>
<ul>
<li><p>创建对象实例</p>
</li>
<li><p>创建子类对象实例, 父类会先加载</p>
</li>
<li><p>使用类的静态成员方法</p>
</li>
</ul>
<ol start="3">
<li><p>普通的代码块, 在创建对象实例时, 会被隐式调用, 被创建一次就会被调用一次. 如果只是使用静态的成员时, 普通的代码块不会被调用</p>
</li>
<li><p>创建一次对象时, 在一个类的调用顺序是 ! ! !:</p>
</li>
</ol>
<ul>
<li>静态代码静态属性初始化</li>
<li>普通代码和属性初始化</li>
<li>构造方法</li>
</ul>
<ol start="5">
<li><p>构造器的最前面隐含了super()和调用和普通代码块,</p>
<ol>
<li>super();</li>
<li>本类普通代码块</li>
<li>构造器语句;</li>
</ol>
</li>
<li><p>具有继承关系时, 他们的调用顺序:</p>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738272.png" alt="image-20240115144106013"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><blockquote>
<p>它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式(对象创建了,还没有用)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="comment">// 在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快  </span></span><br><span class="line">    <span class="keyword">private</span> Static String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//1.构造器私有化 </span></span><br><span class="line">    		<span class="comment">//2.在内部创建,静态是为了在静态方法中调用</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  <span class="comment">//2. 公共静态方法返回对象</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒汉式(使用时再创建)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="comment">// 类加载时不初始化  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用时初始化，线程不安全，需要加锁处理  </span></span><br><span class="line">    <span class="comment">//提供公共方法返回对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>需要用到final的情况:</p>
<ol>
<li>当不希望类被继承</li>
<li>不希望父类的某个方法被子类覆盖&#x2F;重写</li>
<li>不希望某个局部变量被修改</li>
</ol>
<h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ul>
<li>final修饰的属性又叫常量, 一般用XX_XX命名</li>
<li>创建时必须初始化<ul>
<li>定义时</li>
<li>构造器中  </li>
<li>代码块中</li>
</ul>
</li>
<li>final修饰的属性是静态的, 则初始化的位置只能是:<ul>
<li>定义时</li>
<li>静态代码块中, 不能在构造器中赋值, 静态的加载在构造器之前</li>
</ul>
</li>
<li>final类不能继承, 但可以实例化对象</li>
<li>如果类不是final类,  但是含有final方法, 则该方法不能重写, 但可以继承</li>
<li>一般来说, 如果类已经是final了, 方法就没必要再修饰final了. 因为类无法被继承, 自然也就不会重写</li>
<li>final不能修饰构造器</li>
<li>final和static搭配使用, 效率更高, 不会导致类加载. </li>
<li>包装类(integer, double, float, BOOlean都是final). String也是</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p>Java中的抽象类是一种特殊类型的类，它不能被实例化。抽象类通常用于定义一个通用的接口，该接口可以被其他类实现或继承。</p>
</blockquote>
<p>父类方法不确定性：</p>
<p>例如定义一个动物类，动物类有吃的方法，但是方法中不知道这时动物吃什么．</p>
<p>这时可以将类作为抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 抽象方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123; <span class="comment">// 具体方法  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;The animal moves.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用抽象类，可以创建一个继承自抽象类的具体类，并实现所有的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123; <span class="comment">// 实现抽象方法  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;The dog barks.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h3><ul>
<li><p>abstract只能修饰类和方法</p>
</li>
<li><p>一个类如果继承了抽象类, 则必须要将其实现, 除非他自己也是abstract</p>
</li>
<li><p>抽象方法不能使用private, final, static来修饰, 因为这些关键字和重写是冲突的</p>
</li>
<li><p>static不能和final一起出现, 因为static必须在调用时使用</p>
</li>
</ul>
<h3 id="抽象类实践-模板设计模式"><a href="#抽象类实践-模板设计模式" class="headerlink" title="抽象类实践, 模板设计模式"></a>抽象类实践, 模板设计模式</h3><blockquote>
<p>模板方法模式是一种行为型设计模式，它在一个方法中定义了一个算法的骨架，将某些步骤延迟到子类中实现。</p>
<p>这种模式使得子类在不改变算法结构的情况下，重新定义算法的某些特定步骤</p>
</blockquote>
<p><strong>父类定义骨架, 子类只需要关注自己需要重写的部分</strong></p>
<p>在模板方法模式中，抽象类中定义了一个模板方法，该方法包含了算法的主要逻辑。模板方法内部可以调用其他已经定义好的方法（这些方法通常是抽象的，需要在子类中实现），也可以调用一些具体的方法（这些方法通常在抽象类中实现）。</p>
<p>子类继承抽象类并实现抽象方法，以提供模板方法所需的具体逻辑。通过这种方式，子类可以在不改变算法结构的情况下，对算法的某些特定步骤进行定制。</p>
<p>模板方法模式的优势在于，它<strong>使得算法的主体逻辑只存在于一个地方</strong>，即抽象类中。这有助于代码的复用和维护。同时，通过将算法的某些步骤延迟到子类中实现，可以方便地对算法进行扩展和定制。</p>
<p>模板方法模式的使用场景包括：</p>
<ol>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>普通类: 只有具体实现</p>
<p>抽象类: 具体实现和规范(抽象方法)</p>
<p>接口: 只有规范 , 约束和实现分离</p>
<blockquote>
<p>接口就是规范,</p>
<p>接口是一种引用类型，是一种特殊的抽象类。它定义了一组方法，但没有具体实现这些方法。接口可以被看作是类的模板，它定义了类应该具有的特性。</p>
</blockquote>
<p>关键字 interface</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个名为<code>MyInterface</code>的接口，它包含了两个抽象方法和一个常量。实现这个接口的类必须提供<code>method1()</code>和<code>method2()</code>的具体实现。<code>CONSTANT</code>是一个常量，它的值不能被修改。</p>
<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p>
<p><code>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">MammalInt</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MammalInt</span>();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="细节-4"><a href="#细节-4" class="headerlink" title="细节"></a>细节</h3><ul>
<li>接口中所有方法都是public, 接口中抽象方法可以不用abstract修饰 </li>
<li>抽象类实现接口, 可以不用实现接口的方法</li>
<li>一个类可以实现多个接口 <code>public class AA implements BB, CC&#123;&#125;</code></li>
<li>接口中所有属性只能是final, 而且是public static final<ul>
<li><code>interface IB &#123;int n = 10&#125;</code></li>
<li><code>//等价于public static final</code></li>
</ul>
</li>
<li>接口中属性的访问形式: 接口名.属性名</li>
<li>接口不能继承其他类, 但是可以继承多个别的接口<ul>
<li><code>interface A extends B, C &#123;&#125;</code></li>
</ul>
</li>
<li>接口的修饰符只能是public和默认</li>
</ul>
<h3 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h3><p>实现: 实现是对继承的补充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fishable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Birdable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flying</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monkey</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Monkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">climbing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(name + <span class="string">&quot; 会爬树...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LittleMonkey</span> <span class="keyword">extends</span> <span class="title class_">Monkey</span> <span class="keyword">implements</span> <span class="title class_">Fishable</span>,Birdable &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LittleMonkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">&quot; 通过学习，可以像鱼儿一样游泳...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flying</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">&quot; 通过学习，可以像鸟儿一样飞翔...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口和继承解决的问题不同</strong></p>
<ul>
<li>继承的主要价值在于: 解决代的复用性和可维护性</li>
<li>接口的主要价值在于: 设计,  设计好各种规范(方法), 让其他类去实现这些方法.</li>
</ul>
<p><strong>接口比继承更加灵活</strong></p>
<p>继承满足is - a的关系, 而接口满足like - a 的关系</p>
<h3 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h3><p>两个类都实现了同一个方法, 创建对象时, 引用对象指向接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IP</span> &#123; &#125;</span><br><span class="line">calss Monster <span class="keyword">implements</span> <span class="title class_">IP</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">IP</span> &#123;&#125;</span><br><span class="line"><span class="comment">//Monster和Car都实现了接口IP</span></span><br><span class="line"><span class="type">IP</span> <span class="variable">ip01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line"><span class="type">IP</span> <span class="variable">ip02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="comment">//引用IP, 但运行时接口实现的实例</span></span><br></pre></td></tr></table></figure>

<h3 id="接口多态传递"><a href="#接口多态传递" class="headerlink" title="接口多态传递"></a>接口多态传递</h3> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">interFace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();<span class="comment">//接口类型的变量可以指向实现了该接口类型的对象实例</span></span><br><span class="line">        <span class="comment">//如果IH继承了IH接口,而Teacher实现了IG接口,实际上相当于Teacher类也实现了IH接口</span></span><br><span class="line">        <span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote>
<p>Java中的内部类是一种特殊的类，它被定义在另一个类的内部。根据其作用域的不同，可以分为四种类型的内部类：</p>
</blockquote>
<ol>
<li>静态内部类：使用static关键字定义的内部类，它与外部类实例无关，可以直接使用类名来访问。</li>
<li>成员内部类：作为外部类的一个成员变量，必须先创建外部类的对象才能创建内部类的对象。</li>
<li>局部内部类：在方法中定义的内部类，只能在定义它的方法中使用。</li>
<li>匿名内部类：没有名称的内部类，同时是一个对象, 通常用于实现某个接口或继承某个类，并且<strong>只使用一次</strong>。<ol>
<li>从语法上来看, 既有定义类的特征, 也有创建对象</li>
</ol>
</li>
</ol>
<p>内部类的优势在于它可以方便地访问外部类的成员变量和方法，同时也可以避免一些因为封装而导致的代码复杂度增加的问题。此外，匿名内部类可以使代码更加简洁，避免了创建无名类的烦恼。</p>
<p><strong>为了实现抽象类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;  </span><br><span class="line">    <span class="comment">// 成员内部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;  </span><br><span class="line">        <span class="comment">// 成员变量和方法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 静态内部类  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;  </span><br><span class="line">        <span class="comment">// 成员变量和方法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 局部内部类  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;  </span><br><span class="line">            <span class="comment">// 成员变量和方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 匿名内部类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outerClass</span> &#123;</span><br><span class="line">    object1 = <span class="keyword">new</span> <span class="title class_">Type</span>(parameterList) &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.hi(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//创建了一个匿名类对象object1, 匿名类是表达式形式定义的, 所以结尾是`;`结束</span></span><br><span class="line">    <span class="comment">//匿名类也是对象, 可以直接调用内部方法.</span></span><br><span class="line">    <span class="comment">//匿名内部类可以当参数传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">L</span>() &#123;</span><br><span class="line">            <span class="meta">@Overide</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">        </span><br><span class="line">       	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(L l)</span>&#123;</span><br><span class="line">            l.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">L</span> &#123;</span><br><span class="line">       	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041738779.png" alt="image-20240116140454436"></p>
<h1 id="第十一章-枚举和注解"><a href="#第十一章-枚举和注解" class="headerlink" title="第十一章 枚举和注解"></a>第十一章 枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于季节而言, 只有四个, 但是这样定义类可以创建很多个, 不能体现季节是固定的四个对象;</span></span><br><span class="line"><span class="comment">//季节这样的类</span></span><br><span class="line"><span class="comment">//1. 固定的值</span></span><br><span class="line"><span class="comment">//2. 只读, 不需要修改</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举是特殊的类, 一组常量的集合</p>
<ol>
<li>枚举类型可以包含方法和属性，并且可以重写方法。</li>
<li>枚举类型是单例的，即每个枚举值在整个程序中只会出现一次。</li>
</ol>
</blockquote>
<h3 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h3><ol>
<li>将构造器私有化, 防止被new</li>
<li>去掉set方法, 防止属性被修改</li>
<li>在Season内部直接创建固定的对象</li>
<li>加入final修饰</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calss <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="关键字enum"><a href="#关键字enum" class="headerlink" title="关键字enum"></a>关键字enum</h3><ol>
<li>使用关键字 enum 替代 class </li>
<li>SPRING(“春天”, “温暖”) 解读 常量名(实参列表) </li>
<li>如果有多个常量(对象)， 使用 ,号间隔即可 </li>
<li>如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</li>
<li>如果我们使用的是无参构造器，创建常量对象，则可以省略</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>Season(String name, String desc) &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">enum Season(String name, String desc) &#123;</span><br><span class="line">//枚举对象必须放在最前面</span><br><span class="line">    SPRING(&quot;春天&quot;, &quot;温暖&quot;), SPRING(&quot;春天&quot;, &quot;温暖&quot;), SPRING(&quot;春天&quot;, &quot;温暖&quot;);</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String desc;//描述</span><br><span class="line">  </span><br><span class="line">    private static Season(String name, String desc) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="细节-5"><a href="#细节-5" class="headerlink" title="细节"></a>细节</h4><ol>
<li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个final类</li>
<li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li>
</ol>
<h3 id="enum类方法"><a href="#enum类方法" class="headerlink" title="enum类方法"></a>enum类方法</h3><p> <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739703.png" alt="image-20240116150622450"></p>
<ol>
<li>toString: Enum 类已经重写重写过了, 返回的是当前对象名, 子类可以重写该方法, 用于返回对象的属性信息</li>
<li>name:返回当前对象名(常量名) , 子类不可以重写</li>
<li>oridinal: 返回当前对象的位置号, 默认从0开始</li>
<li>values: 返回当前枚举类中所有的常量</li>
<li>valueOf: 将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！</li>
<li>)compareTo：比较两个枚举常量，比较的就是编号</li>
</ol>
<p>调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Week week[] = <span class="keyword">new</span> <span class="title class_">Week</span>.valus();<span class="comment">// 将Week中的值给week[];</span></span><br><span class="line"><span class="comment">//增强for循环, 将week中的值取出, 传给weeks</span></span><br><span class="line"><span class="keyword">for</span>(weeks:week) &#123;</span><br><span class="line">    System.out.println(weeks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="enum实现接口"><a href="#enum实现接口" class="headerlink" title="enum实现接口"></a>enum实现接口</h3><ol>
<li>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</li>
<li>枚举类和普通类一样，可以实现接口，如下形式。 enum 类名 implements 接口 1，接口 2 {接口实现}</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。</li>
<li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li>
<li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置</li>
</ol>
<h3 id="Annotation介绍"><a href="#Annotation介绍" class="headerlink" title="Annotation介绍"></a>Annotation介绍</h3><p>使用 Annotation 时要在其前面增加 @ 符号, 并把该Annotation 当成一个修饰符使用。</p>
<p>用于修饰它支持的程序元 素 三个基本的 Annotation: </p>
<h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><p> 限定某个方法，是重写父类方法, 该注解只能用于方法</p>
<ol>
<li>@Override表示指定重写父类的方法(从编译层面验证), 如果父类没有fly方法, 则会报错</li>
<li>如果不写, 父类依然有public void fly() {}, 依然构成重写</li>
<li>只能修饰方法</li>
<li>Target是修饰注解的注解, 称为元注解</li>
</ol>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><p>用于表示某个程序元素(类, 方法等)已过时 </p>
<ol>
<li>可以修饰方法, 类, 字段, 包, 参数等等</li>
<li>做新旧版本的兼容和过度</li>
</ol>
<h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings:"></a>@SuppressWarnings:</h4><p>抑制编译器警告</p>
<ol>
<li><p>当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息 </p>
</li>
<li><p>在@SuppressWarnings( {“XXXX”} )中，可以写入你希望抑制(不显示)警告信息 </p>
</li>
<li><p>关于 SuppressWarnings 作用范围是和你放置的位置相关, </p>
<p>比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main , 通常我们可以放置具体的语句, 方法, 类</p>
</li>
</ol>
<p><strong>需求文档-&gt;理解-&gt;代码</strong></p>
<h1 id="第十二章-异常-Exception"><a href="#第十二章-异常-Exception" class="headerlink" title="第十二章 异常(Exception)"></a>第十二章 异常(Exception)</h1><blockquote>
<p>Java中的异常机制是一种处理程序中的错误或异常情况的方式。当程序中出现异常时，Java运行时系统会抛出一个异常对象，程序会停止正常的执行流程，转向处理异常的代码。</p>
<hr>
</blockquote>
<blockquote>
<p>异常是指中断程序正常执行的一个不确定的事件。当异常发生时，程序的正常执行流程就会被打断。一般情况下，程序都会有很多条语句，如果没有异常处理机制，前面的语句一旦出现了异常，后面的语句就没办法继续执行了。”</p>
<p>“有了异常处理机制后，程序在发生异常的时候就不会中断，我们可以对异常进行捕获，然后改变程序执行的流程。”</p>
<p>“除此之外，异常处理机制可以保证我们向用户提供友好的提示信息，而不是程序原生的异常信息——用户根本理解不了。”</p>
</blockquote>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\Documents\MarkDown\Code\assets\image-20240116211406473.png" alt="image-20240116211406473" style="zoom: 67%;" />

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739216.png" alt="image-20240116211332249"></p>
<p>Java中的异常可以分为两类：</p>
<ol>
<li>编译型异常（Checked Exceptions)<ol>
<li>这类异常在编译时被检查，必须在方法或构造函数上使用<code>throws</code>关键字进行声明。检查型异常通常表示程序可以预料到的情况，例如文件找不到、网络连接失败等。</li>
</ol>
</li>
<li>运行时异常（Unchecked Exceptions）。<ol>
<li>这类异常是运行时异常，不需要在方法或构造函数上使用<code>throws</code>关键字进行声明。非检查型异常通常表示程序无法预料到的情况，例如除以零、数组越界等逻辑错误,  是程序员应该避免的。</li>
</ol>
</li>
<li>错误<ol>
<li>错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的</li>
</ol>
</li>
</ol>
<h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><p>常见的运行时异常包括 </p>
<ol>
<li>NullPointerException 空指针异常</li>
<li>ArithmeticException 数学运算异常 </li>
<li>ArrayIndexOutOfBoundsException 数组下标越界异常 </li>
<li>ClassCastException 类型转换异常</li>
<li>NumberFormatException 数字格式不正确异常[]</li>
</ol>
<p>常见的编译异常</p>
<ol>
<li>SQLException&#x2F;&#x2F;操作数据库时,查询表可能发生异常</li>
<li>IOException&#x2F;&#x2F;操作文件时,发生的异常</li>
<li>FileNotFoundException&#x2F;&#x2F;当操作一个不存在的文件时,发生异常</li>
<li>ClassNotFoundException&#x2F;&#x2F;加载类,而该类不存在时,异常</li>
<li>EOFException&#x2F;&#x2F;操作文件,到文件末尾,发生异常</li>
<li>IllegalArguementException&#x2F;&#x2F;参数异常</li>
</ol>
<h3 id="处理异常的方式"><a href="#处理异常的方式" class="headerlink" title="处理异常的方式"></a>处理异常的方式</h3><h4 id="捕获异常（Catch"><a href="#捕获异常（Catch" class="headerlink" title="捕获异常（Catch)"></a>捕获异常（Catch)</h4><p>程序员在代码中捕获发生的异常, 自行处理</p>
<ol>
<li>捕获异常：在方法或构造函数中，可以使用<code>try-catch</code>语句来捕获并处理异常。当<code>try</code>块中的代码发生异常时，程序会跳转到对应的<code>catch</code>块中执行处理逻辑。</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739701.png" alt="image-20240116212556922"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// try监控异常</span></span><br><span class="line">    System.out.println(a/b);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticExection e) &#123;</span><br><span class="line">    <span class="comment">//cactch捕获异常, 内部参数为捕获的异常类型</span></span><br><span class="line">    System.out.println(<span class="string">&quot;出现异常&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多重捕获块</span></span><br><span class="line"><span class="comment">//异常类型从小到大</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 异常的变量名<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739029.png" alt="image-20240116214522991"></p>
<p>数组空指针异常(NullPointer), return ++i&#x2F;&#x2F; 3, 先执行final ,i&#x3D;4, 在return i&#x3D;3;</p>
<h4 id="抛出异常（Throws）。"><a href="#抛出异常（Throws）。" class="headerlink" title="抛出异常（Throws）。"></a>抛出异常（Throws）。</h4><p>将发生的异常抛出, 交给调用者(方法)来处理, 最顶级的处理者是JVM</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041739438.png" alt="image-20240116212715144"></p>
<ol>
<li>抛出异常：当方法或构造函数无法处理异常时，可以使用<code>throw</code>语句抛出异常。这个异常对象会被传递给调用者，直到找到能够处理该异常的<code>catch</code>块或者被最终抛出到应用程序的顶层。</li>
</ol>
<p>Java中的异常处理机制可以帮助程序员更好地控制程序的执行流程，避免程序出现意外终止或无法控制的行为。通过合理地使用异常处理，可以提高程序的健壮性和可靠性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">// Exception统称</span></span><br><span class="line">    <span class="comment">//1. 这里的异常是编译异常</span></span><br><span class="line">    <span class="comment">//2. 使用throws, 让f方法的调用者(方法)处理异常</span></span><br><span class="line">    <span class="comment">//3. throws后面的异常类型可以是方法中产生的异常类型, 也可以是他的父类</span></span><br><span class="line">    <span class="comment">//4. throws关键字后面也可以是异常列表, 即可以抛出多个异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细节</strong></p>
<ol>
<li>子类重写父类的方法时, 对抛出异常的规定: 子类所抛出的异常要和父类一致, 或者为父类抛出异常类型的子类型</li>
<li>在throws过程中, 如果有try - catch处理, 就停止throws</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><blockquote>
<p>当程序中出现了某些“错误”, 但该错误信息并没有在Throw able子类中描述处理, 这个时侯后可以自己设计异常类, 用于描述错误信息</p>
</blockquote>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>定义类: 自定义异常类名,<strong>继承Exception或RuntimeException</strong></li>
<li>如果继承Exception, 属于编译异常, Runtime属于运行异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的一个异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AgeException</span> <span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">138</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span> (<span class="string">&quot;年龄异常&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">//不符合取反就进入异常处理,  符合就退出</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="throw和throws区别"><a href="#throw和throws区别" class="headerlink" title="throw和throws区别"></a>throw和throws区别</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740526.png" alt="image-20240117114800670"></p>
<p> <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740452.png" alt="image-20240117122651819"></p>
<p>执行showExce时, 抛出异常, 不再执行接下来的语句, 到catch输出B, 再到final. </p>
<p><strong>有final一定会执行, 但只有catch没有return则按顺序执行</strong></p>
<h1 id="十三章-常用类"><a href="#十三章-常用类" class="headerlink" title="十三章 常用类"></a>十三章 常用类</h1><h2 id="包装类-Wrapper"><a href="#包装类-Wrapper" class="headerlink" title="包装类(Wrapper)"></a>包装类(Wrapper)</h2><ol>
<li><p>针对八种基本数据类型相应的引用类型—包装类</p>
</li>
<li><p>有了类的特点，就可以调用类中的方法</p>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740467.png" alt="image-20240117123518143"></p>
<h3 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h3><ol>
<li>手动装箱</li>
</ol>
<p><code>int n1 = 100;</code></p>
<p><code>Integer integer = new Integer(n1);</code></p>
<p><code>Integer integer = Integer.valueOf(n1);</code></p>
<p>两种方式</p>
<ol start="2">
<li>手动拆箱</li>
</ol>
<p>int i &#x3D; integer.intValue();</p>
<ol start="3">
<li>自动装箱</li>
</ol>
<p><code>Integer integer2 = n2;</code></p>
<ol start="4">
<li>自动拆箱</li>
</ol>
<p><code>int n3 = integer3;</code>	</p>
<p><strong>包装类和String类转换</strong></p>
<ul>
<li>包装类转String</li>
</ul>
<p><code>Integer i = 100;</code></p>
<p><code>String str1 = i + “ ”;</code>&#x2F;&#x2F;将Integer 100 转为String</p>
<p><code>String str1 = i.toString()</code></p>
<ul>
<li>String转包装类</li>
</ul>
<p><code>String str4 = “12345”;</code></p>
<p><code>Integer i = Integer.parseInt(str4);</code></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740723.png" alt="image-20240117181137178"></p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ol>
<li><p>String对象用于保存字符串</p>
</li>
<li><p>字符串常量对象使用双引号</p>
</li>
<li></li>
<li><p>字符串的字符使用Unicode, 一个字符(汉英)占两个字节</p>
</li>
<li><p>String类有很多构造器, 构造器的重载</p>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041740635.png" alt="image-20240117181825057"></p>
<ol start="5">
<li>String类实现了接口Serializable(String可以串行化: 可以再网络传输), 接口Comparable(比较大小)</li>
<li>String是final类, 不能继承</li>
<li>String有属性private, final, char, value[]; 用于存放字符串内容</li>
<li>value[]是一个final类型, 即不可以指向新的地址, 但是里面的字符是可以变化的. 本身的值和地址不在一个地方</li>
</ol>
<h3 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h3><ol>
<li>直接赋值 String S &#x3D; xxx</li>
<li>调用构造器 String S2 &#x3D; new String(“ ”);</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041737832.png" alt="image-20240117210625513"></p>
<h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736855.png" alt="image-20240117215811359"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736682.png" alt="image-20240117215851580"></p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><ul>
<li><p>可变的字符序列, 可以对字符内容进行增删</p>
</li>
<li><p>StringBuffer是一个容器</p>
</li>
<li><p>很多方法与String相同, 但StringBuffer是可变长度的</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736122.png" alt="image-20240117220422990"></p>
<h4 id="对比String"><a href="#对比String" class="headerlink" title="对比String"></a>对比String</h4><ol>
<li>String保存的是字符串常量, 不能更改, 每次的更新是更改地址, 效率低</li>
<li>Buffer保存变量, 不用更新地址, char[] value放在堆中</li>
</ol>
<h4 id="构造器和转换"><a href="#构造器和转换" class="headerlink" title="构造器和转换"></a>构造器和转换</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736863.png" alt="image-20240117221554340"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);<span class="comment">//返回了str值给stringBufeer</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>两者中间转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer -&gt; String </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello tom&quot;</span>;</span><br><span class="line"><span class="comment">//方式 1 使用构造器</span></span><br><span class="line"><span class="comment">//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式 2 使用的是 append 方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer1 = stringBuffer1.append(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer -&gt;String</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;韩顺平教育&quot;</span>);</span><br><span class="line"><span class="comment">//方式 1 使用 StringBuffer 提供的 toString 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer3.toString();</span><br><span class="line"><span class="comment">//方式 2: 使用构造器来搞定</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer3);</span><br></pre></td></tr></table></figure>

<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">s.append(<span class="string">&#x27;,&#x27;</span>);<span class="comment">// &quot;hello,&quot;</span></span><br><span class="line">s.append(<span class="string">&quot;张三丰&quot;</span>);<span class="comment">//&quot;hello,张三丰&quot;</span></span><br><span class="line">s.append(<span class="string">&quot;赵敏&quot;</span>).append(<span class="number">100</span>).append(<span class="literal">true</span>).append(<span class="number">10.5</span>);<span class="comment">//&quot;hello,张三丰赵敏 100true10.5&quot; </span></span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏100true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class="line"><span class="comment">* 解读: 删除 11~14 的字符 [11, 14) </span></span><br><span class="line"><span class="comment">* 从零开始, 包含11不包含14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.delete(<span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏true10.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)</span></span><br><span class="line">s.replace(<span class="number">9</span>, <span class="number">11</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰周芷若 true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">indexOf</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">System.out.println(indexOf);<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移</span></span><br><span class="line">s.insert(<span class="number">9</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏周芷若 true10.5&quot;</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">System.out.println(s.length());<span class="comment">//22</span></span><br><span class="line">System.out.println(s)</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736616.png" alt="image-20240117223558110"></p>
<ol>
<li>StringBuilder 继承 AbstractStringBuilder 类 </li>
<li>实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件) </li>
<li>StringBuilder 是 final 类, 不能被继承</li>
<li>StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value; &#x2F;&#x2F; 因此，字符序列是堆中</li>
<li>StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用</li>
</ol>
<h3 id="比较和选择"><a href="#比较和选择" class="headerlink" title="比较和选择"></a>比较和选择</h3><ul>
<li>三个的比较</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736770.png" alt="image-20240118134539842"></p>
<ul>
<li>选择</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736495.png" alt="image-20240118134634518"></p>
<h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><ol>
<li><p>Date: 精确到毫秒, 代表特定的时间</p>
</li>
<li><p>SimpleDateFomat: 格式和解析日期的类 </p>
<p>格式: 日期 &#x3D;&gt; 文本</p>
<p>解析: 文本 &#x3D;&gt; 规范化</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取当前系统时间</span></span><br><span class="line"><span class="comment">//2. 这里的 Date 类是在 java.util 包</span></span><br><span class="line"><span class="comment">//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + d1);</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">9234567</span>); <span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;d2=&quot;</span> + d2); <span class="comment">//获取某个时间对应的毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式</span></span><br><span class="line"><span class="comment">//2. 这里的格式使用的字母是规定好，不能乱写</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sDF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sDF.format(d1); <span class="comment">// format:将日期转换成指定格式的字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + format);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 可以把一个格式化的 String 转成对应的 Date</span></span><br><span class="line"><span class="comment">//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</span></span><br><span class="line"><span class="comment">//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sDF.parse(s);</span><br><span class="line">System.out.println(<span class="string">&quot;parse=&quot;</span> + sDF.format(parse));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736689.png" alt="image-20240118135233647"></p>
<h3 id="第二代日期类Calendar"><a href="#第二代日期类Calendar" class="headerlink" title="第二代日期类Calendar"></a>第二代日期类Calendar</h3><ol>
<li><p>Calendar 是一个抽象类， 并且构造器是 private </p>
</li>
<li><p>可以通过 getInstance() 来获取实例</p>
<p><code>Calendar c = Calendar.getInstance();</code></p>
<p><code>System.out.println(&quot;C&quot; + c);</code></p>
</li>
<li><p>提供大量的方法和字段提供给程序员</p>
</li>
<li><p>Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</p>
</li>
<li><p>如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR &#x3D;&#x3D;改成&#x3D;&gt; Calendar.HOUR_OF_DAY Calendar c &#x3D; Calendar.getInstance(); &#x2F;&#x2F;创建日历类对象&#x2F;&#x2F;比较简单，自由</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.获取日历对象的某个日历字段</span></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line"><span class="comment">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class="line">System.out.println(<span class="string">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示</span></span><br><span class="line">System.out.println(c.get(Calendar.YEAR) + <span class="string">&quot;-&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>) + <span class="string">&quot;-&quot;</span> +</span><br><span class="line">c.get(Calendar.DAY_OF_MONTH) +  <span class="string">&quot; &quot;</span> + c.get(Calendar.HOUR_OF_DAY) + <span class="string">&quot;:&quot;</span> + c.get(Calendar.MINUTE) + <span class="string">&quot;:&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>

<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736464.png" alt="image-20240118140733947"></p>
<ol>
<li>LocalDate(年月日)</li>
<li>LocalTime(时分秒)</li>
<li>LocalDateTime(日期 + 时间)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">//LocalDate.now();//LocalTime.now()</span></span><br><span class="line">System.out.println(ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class="line"><span class="comment">// 创建 DateTimeFormatter 对象</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dateTimeFormatter.format(ldt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期=&quot;</span> + format);</span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">//可以获取年月日</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//获取到时分秒</span></span><br><span class="line"><span class="comment">//提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class="line"><span class="comment">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> ldt.plusDays(<span class="number">890</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(localDateTime));</span><br><span class="line"><span class="comment">//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3456</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(localDateTime2))</span><br></pre></td></tr></table></figure>

<h4 id="Instant时间戳"><a href="#Instant时间戳" class="headerlink" title="Instant时间戳"></a>Instant时间戳</h4><p>类似Date提供了一系列和Date类转换的方法</p>
<p>Instant -&gt; Date</p>
<p><code>Date date = Date.from(instant);</code></p>
<p>Date -&gt; Instant</p>
<p><code>Instant instant = date.toInstant();</code></p>
<h4 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041736729.png" alt="image-20240118141512981"></p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。</p>
<p>很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p>
<ul>
<li>可以动态保存任意多个对象</li>
<li>提供了一系列方便的操作对象</li>
<li>使用集合添加, 删除新元素的示意代码</li>
</ul>
<h2 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h2><p>早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。</p>
<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p>
<p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： <strong>LinkedList</strong>, <strong>HashSet</strong>, 和 <strong>TreeSet</strong> 等,除此之外你也可以通过这些接口实现自己的集合</p>
<p>集合类分为两大类:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735578.png" alt="image-20240118142759268"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735818.png" alt="image-20240118142806772"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735556.png" alt="image-20240119142505891"></p>
<ol>
<li>集合主要是两组(单列集合 , 双列集合)</li>
<li>Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合 </li>
<li>Map 接口的实现子类 是双列集合，存放的 Key-Value对(K-V)</li>
</ol>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<ul>
<li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>
<li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>
<li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序，这些算法实现了多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735544.png" alt="image-20240118231352999"></p>
<h3 id="Set和List的区别"><a href="#Set和List的区别" class="headerlink" title="Set和List的区别"></a>Set和List的区别</h3><ul>
<li><ol>
<li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li>
</ol>
</li>
<li><ol start="2">
<li>Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。</li>
</ol>
</li>
<li><ol start="3">
<li>List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> 。</li>
</ol>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。</p>
<p>集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。</p>
<p>集合框架的类和接口均在java.util包中。</p>
<p>任何对象加入集合类后，自动转变为Object类型，所以在<strong>取出的时候，需要进行强制类型转换。</strong></p>
<h2 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h2><blockquote>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表</p>
</blockquote>
<h3 id="Collection-方法"><a href="#Collection-方法" class="headerlink" title="Collection 方法"></a>Collection 方法</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735317.png" alt="image-20240118144855886"></p>
<p>Collection接口常用方法用实现子类ArrayList来演示 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arraylist</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//add</span></span><br><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);<span class="comment">//相当于list.add(new Integer(10));</span></span><br><span class="line">list.add(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove</span></span><br><span class="line"><span class="comment">//list.remove(0);//删除第一个元素</span></span><br><span class="line">list.remove(<span class="literal">true</span>);<span class="comment">//指定删除某个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//contains: 查找元素</span></span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//size:获取元素个数</span></span><br><span class="line">System.out.println(list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// isEmpty:判断是否为空</span></span><br><span class="line">System.out.println(list.isEmpty());<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear:清空</span></span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// addAll:添加多个元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// containsAll:查找多个元素是否都存在</span></span><br><span class="line">System.out.println(list.containsAll(list2));<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// removeAll：删除多个元素</span></span><br><span class="line">list.add(<span class="string">&quot;聊斋&quot;</span>);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);<span class="comment">//[聊斋]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li>Iterator对象称为迭代器, 主要用于遍历Collection集合中的元素</li>
<li>所有实现了Collection接口的集合类都有一个iterator()方法, 用于返回一个实现了Iterator接口的对象, 即可以返回一个迭代器</li>
<li>Iterator结构</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735177.png" alt="image-20240118150422223"></p>
<ol start="4">
<li>Iterator仅用于遍历集合, 不存放对象, 将得到的返回</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735255.png" alt="image-20240118150620801"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"><span class="comment">//System.out.println(&quot;col=&quot; + col);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//现在希望能够遍历 col 集合</span></span><br><span class="line"><span class="comment">//1. 先得到 col 对应的 迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2. 使用 while 循环遍历</span></span><br><span class="line"><span class="comment">//ctrl + j, 快速生成 while =&gt; itit</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;<span class="comment">//判断是否还有数据</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素</span></span><br><span class="line"><span class="comment">// iterator.next();//NoSuchElementException</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">iterator = col.iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;===第二次遍历===&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h4><p>增强for就是简化版的iterator, 只能用于遍历集合或数组</p>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型  元素名: 集合名或数组名) &#123;</span><br><span class="line">    访问元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黑&quot;</span>, <span class="number">3</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;大黄&quot;</span>, <span class="number">100</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;大壮&quot;</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//先使用 for 增强</span></span><br><span class="line"><span class="keyword">for</span> (Object dog : list) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;dog=&quot;</span> + dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;===使用迭代器来遍历===&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">dog</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">System.out.println(<span class="string">&quot;dog=&quot;</span> + dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h2><blockquote>
<p>List接口时Collection的子接口</p>
</blockquote>
<ol>
<li><p>List集合类中元素类有序(即添加顺序和取出顺序一致), 且可以重复</p>
</li>
<li><p>List集合中的每个元素都有对应的顺序索引, 即支持索引</p>
</li>
</ol>
<p><code>list.get(2)</code></p>
<p>取出第二个元素</p>
<ol start="3">
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置, 可以根据序号取出元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int indexOf(Object obj):返回 obj 在集合中首次出现的位置</span></span><br><span class="line">System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置</span></span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">System.out.println(list.lastIndexOf(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object remove(int index):移除指定 index 位置的元素，并返回此元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换.</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">&quot;marri&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合</span></span><br><span class="line"><span class="comment">// 注意返回的子集合 fromIndex &lt;=subList &lt; toIndex</span></span><br><span class="line"><span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>对list排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先将list中对象取出</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> (Book)list.get(j); <span class="comment">//list中存的都是Object, 先转为Book </span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> (Book)list.get(j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (boo1.getPrice() &gt; book2.getPrice()) &#123;</span><br><span class="line">                list.set(j, book2);</span><br><span class="line">                list.set(j + <span class="number">1</span>, book1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="细节-6"><a href="#细节-6" class="headerlink" title="细节"></a>细节</h4><ul>
<li>ArrayList 是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；</li>
</ul>
<ol>
<li>ArrayList可以加入null</li>
<li>ArrayList是由数组实现数据存储的</li>
<li>ArrayList基本等于Vector, 除了ArrayList线程不安全</li>
</ol>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>结论:</p>
<ol>
<li><p>ArrayList中维护了一个Object类型的数组elementData.[debug看源码]<br><code>transient Object[] elementData;  </code></p>
<p>&#x2F;&#x2F;transient 表示瞬间,短暂的,表示该属性不会被序列</p>
</li>
<li><p>当创建ArrayList对象时, 如果使用的是无参构造器, 则初始elementData容量为0, 第1次添加元素, 则扩容elementData为10, 如需要再次扩容,则扩容elementData为1.5倍.(JDK1.8)</p>
</li>
<li><p>如果使用的是指定大小的构造器, 则初始elementData容量为指定大小, 超过指定大小时,  如果需要扩容, 则直接扩容elementData为1.5倍。</p>
</li>
</ol>
<p><strong>自己Debug</strong></p>
<p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。</p>
<p>数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735449.png" alt="image-20240118222322467"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041735487.png" alt="image-20240118222334310"></p>
<h3 id="vector底层结构和源码剖析"><a href="#vector底层结构和源码剖析" class="headerlink" title="vector底层结构和源码剖析"></a>vector底层结构和源码剖析</h3><p> List的实现类还有一个 Vector，是一个元老级的类，比 ArrayList 出现得更早。ArrayList 和 Vector 非常相似，只不过 Vector 是线程安全的，像 get、set、add 这些方法都加了 <code>synchronized</code> 关键字，就导致执行效率会比较低，所以现在已经很少用了。</p>
<p>加了同步方法的类，注定会被淘汰掉，就像<a target="_blank" rel="noopener" href="https://javabetter.cn/string/builder-buffer.html">StringBuilder取代StringBufferopen in new window</a>那样。JDK 源码也说了：</p>
<blockquote>
<p>如果不需要线程安全，建议使用ArrayList代替Vector。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734901.png" alt="image-20240118222454055"></p>
<h4 id="与ArrayList对比"><a href="#与ArrayList对比" class="headerlink" title="与ArrayList对比"></a>与ArrayList对比</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734601.png" alt="image-20240118222727019"></p>
<h3 id="LinkedList-底层剖析"><a href="#LinkedList-底层剖析" class="headerlink" title="LinkedList 底层剖析"></a>LinkedList 底层剖析</h3><h4 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734000.png" alt="image-20240118230339184"></p>
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>
<p>链表可分为单向链表和双向链表。</p>
<p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734615.png" alt="image-20240118225640190"></p>
<p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="C:\Users\Qyingli\Documents\MarkDown\Code\assets\image-20240118225704075.png" alt="image-20240118225704075" style="zoom:100%;" />

<p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p>
<p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。</p>
<h4 id="操作使用"><a href="#操作使用" class="headerlink" title="操作使用"></a>操作使用</h4><p><strong>以下情况使用 ArrayList :</strong></p>
<ul>
<li>频繁访问列表中的某一个元素。</li>
<li>只需要在列表末尾进行添加和删除元素操作。</li>
</ul>
<p><strong>以下情况使用 LinkedList :</strong></p>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul>
<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<p>LinkedList 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList; </span><br><span class="line"></span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;E&gt;();   <span class="comment">// 普通创建方法</span></span><br><span class="line">或者</span><br><span class="line">LinkedList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c); <span class="comment">// 使用集合创建链表</span></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041734830.png" alt="image-20240118225838888">**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问结尾元素, 或者增删首位元素时, 链表效率更高</p>
<h4 id="迭代元素"><a href="#迭代元素" class="headerlink" title="迭代元素"></a>迭代元素</h4><p>使用for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sites.size(), i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(sites.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 LinkedList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String i : sites) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h2><ol>
<li>无序, 添加和取出顺序不一致, 没有索引</li>
<li>不允许重复元素, 虽多包含一个null</li>
<li>JDK API中Set接口实现类有:</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733805.png" alt="image-20240119113715425"></p>
<p>常用方法和Collection一样</p>
<h3 id="Set接口实现类-HashSet"><a href="#Set接口实现类-HashSet" class="headerlink" title="Set接口实现类: HashSet"></a>Set接口实现类: HashSet</h3><ol>
<li><p>HashSet实现了Set接口</p>
</li>
<li><p>HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。</p>
<p><code>public HashSet() &#123; map = new HashMap&lt;&gt; () &#125;</code></p>
</li>
<li><p>Hash Map底层是(数组 + 链表 + 红黑树)</p>
</li>
<li><p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么ArrayList和LinkedList可能更适合；如果我们需要存储键值对并根据键进行查找，那么HashMap可能更适合。</p>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733488.png" alt="image-20240119114528496"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 HashSet 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);  <span class="comment">// 重复的元素不会被添加</span></span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 HashSet 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);     <span class="comment">// 重复的元素不会被添加</span></span><br><span class="line">        <span class="keyword">for</span> (String i : sites) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用迭代器</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ol>
<li>LinkedHashSet是HashSet的子类</li>
<li>底层是LindedHashMap, 底层维护了一个数组 + 双向链表</li>
<li>LindedHashSet根据元素的hashCode值来决定元素的存储位置, 同时使用链表维护元素的次序, 这使得元素看起来是以插入顺序保存的</li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><blockquote>
<p> <code>TreeSet</code> 是 Java 集合框架的一部分，它是一个基于树结构的实现，用于存储唯一元素。由于其内部实现，<code>TreeSet</code> 提供了对元素的自然排序（基于元素的 <code>Comparable</code> 接口）或根据提供的 <code>Comparator</code> 进行排序。</p>
</blockquote>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ol>
<li><strong>唯一性</strong>：<code>TreeSet</code> 只允许存储唯一的元素。如果你尝试添加一个已经存在的元素，那么该操作不会有任何效果，即该元素不会被添加到集合中。</li>
<li><strong>排序</strong>：<code>TreeSet</code> 默认按照元素的自然顺序进行排序。如果你想按照自定义的顺序进行排序，可以提供一个 <code>Comparator</code> 对象。</li>
<li><strong>查询操作</strong>：由于 <code>TreeSet</code> 是基于树结构的，所以在对集合进行查询时（例如，查找元素是否存在或获取元素的大小），这些操作通常比在 <code>ArrayList</code> 或 <code>LinkedList</code> 等基于数组的数据结构上执行得更快。</li>
<li><strong>不允许 null 值</strong>：与 <code>HashSet</code> 不同，<code>TreeSet</code> 不允许存储 null 值。</li>
</ol>
<p><strong>试分析HashSet和TreeSet分别如何实现去重的</strong></p>
<ol>
<li><p>HashSet的去重机制: hashCode()+equals(), 底层先通过存入对象,进行运算得到一个hash值, 通过hash值得到对应的索引, 如果发现table索引所在的位置,没有数据, 就直接存放,<br>如果有数据, 就进行equals比较[遍历比较], 如果比较后, 不相同加入, 否则就不加入.</p>
</li>
<li><p>TreeSet的去重机制: 如果你传入了一个Comparator匿名对象, 就使用实现的compare去重, 如果方法返回0, 就认为是相同的元素&#x2F;数据, 就不添加</p>
<p>如果你没有传入一个Comparator<br>匿名对象,则以你添加的对象实现的Compareable接口的compareTo去重.</p>
</li>
</ol>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a><strong>常用方法</strong>：</h3><ul>
<li><code>add(E e)</code>: 添加元素到集合中。</li>
<li><code>remove(Object o)</code>: 从集合中移除指定的元素（如果存在）。</li>
<li><code>contains(Ob ject o)</code>: 检查集合是否包含指定的元素。</li>
<li><code>size()</code>: 返回集合中的元素数量。</li>
<li><code>first()</code>, <code>last()</code>: 返回集合中的最小和最大元素（如果存在）。</li>
</ul>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h2><ol>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value<ol>
<li>Key是输入的具体对象, Value也是输入, Set中是常量</li>
</ol>
</li>
</ol>
<ol start="2">
<li>Map 中的key 和 value可以是任何引用类型的数据,会封装到HashMap$Node对象中</li>
<li>Map中的key 不允许重复, Map 中的value 可以重复</li>
<li>Map的key 可以为null, 但只能有一个, value可以为null, 可以多个.</li>
<li>常用String类作为Map的key</li>
<li>key 和value之间存在单向一对一关系,即通过指定的key总能找到对应的value</li>
</ol>
<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733652.png" alt="image-20240119120827140"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。</li>
<li>可以使用迭代器或者 for-Each 方法遍历 HashMap 中的键值对。</li>
<li>HashMap 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，<strong>负载因子是指哈希表在扩容之前可以存储的 (键值对数量 &#x2F; 哈希表大小) 的比率</strong>。默认的初始容量是 16，负载因子是 0.75。</li>
</ul>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        System.out.println(Sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        System.out.println(Sites.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li><p>remove(key);</p>
</li>
<li><p>删除所有用clear();</p>
</li>
</ul>
<h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>可以使用 for-each 来迭代 HashMap 中的元素。</p>
<p>如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 key 和 value</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : Sites.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + i + <span class="string">&quot; value: &quot;</span> + Sites.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回所有 value 值</span></span><br><span class="line">        <span class="keyword">for</span>(String value: Sites.values()) &#123;</span><br><span class="line">          <span class="comment">// 输出每一个value</span></span><br><span class="line">          System.out.print(value + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> Sites.keyset.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">			System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		System.out.println(<span class="string">&quot;---取出所有的 value 迭代器----&quot;</span>);</span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> Sites.values.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;value&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hash-Map小结"><a href="#Hash-Map小结" class="headerlink" title="Hash Map小结"></a>Hash Map小结</h3><ol>
<li>Map接口的常用实现类: Hash Map, Hashtable和Properties</li>
<li>HashMap是Map接口使用频率最高的实现类</li>
<li>key不能重复, value可以.  允许使用null键和值</li>
<li>与HashSet一样, 不保证映射顺序</li>
<li>HashMap没有实现同步, 线程不安全</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733429.png" alt="image-20240119132409539"></p>
<p>一个table数组, 每个数组元素是一个链表, 链表存储键值对</p>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><blockquote>
<p>扩容机制[和HashSet相同]</p>
</blockquote>
<ol>
<li><p>HashMap底层维护了Node类型的数组table,默认为null</p>
</li>
<li><p>当创建对象时,将加载因子(loadfactor)初始化为0.75.</p>
</li>
<li><p>当添加key-val时, 通过key的哈希值得到在table的索引。然后判断该索引处是否有元素.<br>如果没有元素直接添加。如果该索引处有元素, 继续判断该元素的key是否和准备加入的key相等, 如果相等, 则直接替换val; 如果不相等需要判断是树结构还是链表结构, 做出相应处理。</p>
<p>如果添加时发现容量不够,则需要扩容。</p>
</li>
<li><p>第1次添加, 则需要扩容table容量为16, 临界值(threshold)为12</p>
</li>
<li><p>以后再扩容, 则需要扩容table容量为原来的2倍(16*2),  临界值为原来的2倍, 即24(12*2),  依次类推.</p>
</li>
<li><p>在Java8中, 如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8), 并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64), 就会进行树化(红黑树)</p>
</li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap 是 HashMap 的子类，它使用链表来记录插入&#x2F;访问元素的顺序。</p>
<p>LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 LinkedHashMap，插入的键值对为 沉默 王二 陈清扬</span></span><br><span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;沉默&quot;</span>, <span class="string">&quot;cenzhong&quot;</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;王二&quot;</span>, <span class="string">&quot;wanger&quot;</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;陈清扬&quot;</span>, <span class="string">&quot;chenqingyang&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 LinkedHashMap</span></span><br><span class="line"><span class="keyword">for</span> (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> linkedHashMap.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; 对应的值为：&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">沉默 对应的值为：cenzhong</span></span><br><span class="line"><span class="comment">王二 对应的值为：wanger</span></span><br><span class="line"><span class="comment">陈清扬 对应的值为：chenqingyang</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现了 SortedMap 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 TreeMap 对象</span></span><br><span class="line">Map&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 TreeMap 中添加键值对</span></span><br><span class="line">treeMap.put(<span class="string">&quot;沉默&quot;</span>, <span class="string">&quot;cenzhong&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;王二&quot;</span>, <span class="string">&quot;wanger&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;陈清扬&quot;</span>, <span class="string">&quot;chenqingyang&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找键值对</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;沉默&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;找到了 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到 &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改键值对</span></span><br><span class="line">name = <span class="string">&quot;王二&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">    treeMap.put(name, <span class="string">&quot;newWanger&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到 &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">name = <span class="string">&quot;陈清扬&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除前的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">    treeMap.remove(name);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除后的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到 &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 TreeMap</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与HashMap 不同的是，TreeMap 会按照键的顺序来进行排序。</span></span><br><span class="line"><span class="comment">// 创建一个 TreeMap 对象</span></span><br><span class="line">Map&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 TreeMap 中添加键值对</span></span><br><span class="line">treeMap.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 TreeMap</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a: apple</span></span><br><span class="line"><span class="comment">b: banana</span></span><br><span class="line"><span class="comment">c: cat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ol>
<li>存放的元素是键值对:即K-V</li>
</ol>
<ol start="2">
<li>hashtable的键和值都不能为null</li>
<li>hashTable 使用方法基本上和HashMap一样</li>
<li>hashTable 是线程安全的,hashMap是线程不安全的</li>
</ol>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ol>
<li>Properties类继承自Hashtable类并且实现了Map接口, 也是使用一种键值对的形式来保存数据。</li>
<li><strong>他的使用特点和Hashtable类似</strong></li>
<li>Properties 还可以用于 从 xxx.properties 文件中, 加载数据到Properties类对象, 并进行读取 和修改</li>
</ol>
<h2 id="开发中选择集合实现类"><a href="#开发中选择集合实现类" class="headerlink" title="开发中选择集合实现类"></a>开发中选择集合实现类</h2><ol>
<li>先判断存储的类型(一组对象或一组键值对)</li>
<li>一组对象:Collection接口<ol>
<li>允许重复:List<br>增删多: LinkedList[底层维护了一个双向链表]<br>改查多: ArrayList[底层维护Object类型的可变数组]</li>
<li>不允许重复:Set<br>无序: HashSet [底层是HashMap,维护了一个哈希表 即(数组+链表+红黑树)]<br>排序: TreeSet<br>插入和取出顺序一致: LinkedHashSet,维护数组+双向链表</li>
</ol>
</li>
<li>一组键值对:Map<ol>
<li>键无序: HashMap[底层是:哈希表 jdk7:数组+链表,jdk8:数组+链表+红黑树]</li>
<li>键排序: TreeMap</li>
<li>键插入和取出顺序一致: LinkedHashMap</li>
<li>读取文件 Properties</li>
</ol>
</li>
</ol>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><blockquote>
<p> Java中的<code>java.util.Collections</code>类是一个工具类，提供了用于操作集合（如List、Set等）的各种静态方法。这些方法允许执行各种操作，例如排序、替换元素、检查是否包含某个元素等</p>
</blockquote>
<h3 id="常用工具类方法"><a href="#常用工具类方法" class="headerlink" title="常用工具类方法"></a>常用工具类方法</h3><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><ul>
<li><code>reverse(List list)</code>：反转顺序</li>
<li><code>shuffle(List list)</code>：洗牌，将顺序打乱</li>
<li><code>sort(List list)</code>：自然升序</li>
<li><code>sort(List list, Comparator c)</code>：按照自定义的比较器排序</li>
<li><code>swap(List list, int i, int j)</code>：将 i 和 j 位置的元素交换位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;沉默王三&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;沉默王四&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;沉默王五&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;沉默王六&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;原始顺序：&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(<span class="string">&quot;反转后：&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 洗牌</span></span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">System.out.println(<span class="string">&quot;洗牌后：&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自然升序</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(<span class="string">&quot;自然升序后：&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line">Collections.swap(list, <span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;交换后：&quot;</span> + list);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><ul>
<li><code>binarySearch(List list, Object key)</code>：二分查找法，前提是 List 已经排序过了</li>
<li><code>max(Collection coll)</code>：返回最大元素</li>
<li><code>max(Collection coll, Comparator comp)</code>：根据自定义比较器，返回最大元素</li>
<li><code>min(Collection coll)</code>：返回最小元素</li>
<li><code>min(Collection coll, Comparator comp)</code>：根据自定义比较器，返回最小元素</li>
<li><code>fill(List list, Object obj)</code>：使用指定对象填充</li>
<li><code>frequency(Collection c, Object o)</code>：返回指定对象出现的次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;最大元素：&quot;</span> + Collections.max(list));</span><br><span class="line">System.out.println(<span class="string">&quot;最小元素：&quot;</span> + Collections.min(list));</span><br><span class="line">System.out.println(<span class="string">&quot;出现的次数：&quot;</span> + Collections.frequency(list, <span class="string">&quot;沉默王二&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有排序直接调用二分查找，结果是不确定的</span></span><br><span class="line">System.out.println(<span class="string">&quot;排序前的二分查找结果：&quot;</span> + Collections.binarySearch(list, <span class="string">&quot;沉默王二&quot;</span>));</span><br><span class="line">Collections.sort(list);</span><br><span class="line"><span class="comment">// 排序后，查找结果和预期一致</span></span><br><span class="line">System.out.println(<span class="string">&quot;排序后的二分查找结果：&quot;</span> + Collections.binarySearch(list, <span class="string">&quot;沉默王二&quot;</span>));</span><br><span class="line"></span><br><span class="line">Collections.fill(list, <span class="string">&quot;沉默王八&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;填充后的结果：&quot;</span> + list);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>恐怕 JDK 的设计者是这个世界上最好的老师了，文档写得不能再详细了，代码写得不能再优雅了，基本上都达到了性能上的极致。</p>
<h1 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h1><p>一段引入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有泛型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有泛型, 用Object数组设计Arraylist类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] objs;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        objs[i++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在Arraylist中存放数据</span></span><br><span class="line"><span class="type">Arraylist</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arraylist</span>();</span><br><span class="line">list.add(<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)list.get(<span class="number">0</span>);<span class="comment">// 原来返回的是Object, 取出时必须转型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>类型参数</strong>解决了元素的不确定性——<strong>参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换</strong>了。</p>
<p>使用形式:</p>
<p><code>List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();</code></p>
<p><code>List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</code></p>
<h2 id="手动设计一个泛型"><a href="#手动设计一个泛型" class="headerlink" title="手动设计一个泛型"></a>手动设计一个泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Arraylist</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="comment">// 使用了泛型</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//定义了泛型, 为泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>个泛型类就是具有一个或多个类型变量的类。</p>
<p>Arraylist 类引入的类型变量为 E（Element，元素的首字母），使用尖括号 <code>&lt;&gt;</code> 括起来，放在类名的后面。代表我们可以用具体的类型(比如字符串)替换类型变量E来实例化泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arraylist&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;沉默王三&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在一个非泛型的类（或者泛型类）中定义泛型方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041733140.png" alt="image-20240119193914888"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arraylist&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="string">&quot;沉&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;默&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;王&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;二&quot;</span>);</span><br><span class="line"></span><br><span class="line">String [] strs = <span class="keyword">new</span> <span class="title class_">String</span> [<span class="number">4</span>]; </span><br><span class="line">strs = list.toArray(strs);<span class="comment">// 可以直接接收了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str : strs) &#123; <span class="comment">//遍历时可以直接用String</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="泛型限定符"><a href="#泛型限定符" class="headerlink" title="泛型限定符"></a>泛型限定符</h2><p>一个例子, </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义三个类, 之间继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wanglaoer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;王老二&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wanger</span> <span class="keyword">extends</span> <span class="title class_">Wanglaoer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;王二&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> <span class="keyword">extends</span> <span class="title class_">Wanger</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;王小二&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用extends重新设计下Arraylist</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Wanger</span>&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>向 <code>Arraylist</code> 中添加 <code>Wanglaoer</code> 元素的时候，编译器会提示错误：<code>Arraylist</code> 只允许添加 <code>Wanger</code> 及其子类 <code>Wangxiaoer</code> 对象，不允许添加其父类 <code>Wanglaoer</code>。</p>
<p><strong>也就是限定符 <code>extends</code> 可以缩小泛型的类型范围。</strong></p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承了wanger这个类, 即限定类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist2</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Wanger</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Arraylist2</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反编译后: (<strong>将Java字节码（.class文件）转换回其原始的Java源代码的过程。</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) </span></span><br><span class="line"><span class="comment">// Source File Name:   Arraylist2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.cmower.java_demo.fanxing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Referenced classes of package com.cmower.java_demo.fanxing:</span></span><br><span class="line"><span class="comment">//            Wanger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Arraylist2</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Wanger e)</span> <span class="comment">// E变成wanger</span></span><br><span class="line">    &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Wanger <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Wanger)elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object elementData[];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类型变量 <code>&lt;E extends Wanger&gt;</code> 不见了，E 被替换成了 <code>Wanger</code></p>
<p>Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 <code>Object</code>）</p>
<h3 id="类型擦除的问题"><a href="#类型擦除的问题" class="headerlink" title="类型擦除的问题"></a>类型擦除的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cmower</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Arraylist&lt;String&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Arraylist&lt;String&gt; list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Arraylist&lt;Date&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Arraylist&lt;Date&gt; list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但由于擦除后都是Arraylist, 编译器会报错</p>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>使用英文的问号<code>（?）</code>来表示。</p>
<p>在我们创建一个泛型对象时，可以使用关键字 <code>extends</code> 限定子类，也可以使用关键字 <code>super</code> 限定父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型类 Arraylist&lt;E&gt;，E 表示元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arraylist</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 私有成员变量，存储元素数组和元素数量</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，传入初始容量 initialCapacity，创建一个指定容量的 Object 数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Arraylist</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到数组末尾，返回添加成功与否</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定下标的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找指定元素第一次出现的下标，如果找不到则返回 -1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断指定元素是否在数组中出现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组中的元素转化成字符串输出</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Object o : elementData) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E)o;</span><br><span class="line">                sb.append(e.toString());</span><br><span class="line">                sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数组中元素的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改指定下标的元素，返回修改前的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型擦除的原因，<code>Arraylist&lt;Wanger&gt; list = new Arraylist&lt;Wangxiaoer&gt;();</code> 这样的语句是无法通过编译的，尽管 Wangxiaoer 是 Wanger 的子类。</p>
<p>但如果我们确实需要这种 “向上转型” 的关系，该怎么办呢？这时候就需要通配符来发挥作用了。</p>
<p>利用<code>&lt;? extends Wanger&gt;</code> 形式的通配符，可以实现泛型的向上转型，来看例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arraylist&lt;? <span class="keyword">extends</span> <span class="title class_">Wanger</span>&gt; list2 = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;&gt;(<span class="number">4</span>); <span class="comment">//list2 是一个 Arraylist，其类型是 Wanger 及其子类。</span></span><br><span class="line">list2.add(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// list2.add(new Wanger());</span></span><br><span class="line"><span class="comment">// list2.add(new Wangxiaoer());</span></span><br><span class="line"></span><br><span class="line"><span class="type">Wanger</span> <span class="variable">w2</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Wangxiaoer w3 = list2.get(1);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>list2 并不允许通过 <code>add(E e)</code> 方法向其添加 <code>Wanger</code> 或者 <code>Wangxiaoer</code> 的对象，唯一例外的是 <code>null</code>。</p>
<p>虽然不能通过 <code>add(E e)</code> 方法往 list2 中添加元素，但可以给它赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arraylist&lt;Wanger&gt; list = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Wanger</span> <span class="variable">wanger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wanger</span>();</span><br><span class="line">list.add(wanger);</span><br><span class="line"></span><br><span class="line"><span class="type">Wangxiaoer</span> <span class="variable">wangxiaoer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>();</span><br><span class="line">list.add(wangxiaoer);</span><br><span class="line"></span><br><span class="line">Arraylist&lt;? <span class="keyword">extends</span> <span class="title class_">Wanger</span>&gt; list2 = list; <span class="comment">//把 list 的值赋予了 list2，此时 list2 == list。由于 list2 不允许往其添加其他元素，所以此时它是安全的——我们可以从容地对 list2 进行 get()、indexOf() 和 contains()。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Wanger</span> <span class="variable">w2</span> <span class="operator">=</span> list2.get(<span class="number">1</span>);</span><br><span class="line">System.out.println(w2);</span><br><span class="line"></span><br><span class="line">System.out.println(list2.indexOf(wanger));</span><br><span class="line">System.out.println(list2.contains(<span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;? super Wanger&gt;</code> 形式的通配符，可以向 Arraylist 中存入父类是 <code>Wanger</code> 的元素，来看例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arraylist&lt;? <span class="built_in">super</span> Wanger&gt; list3 = <span class="keyword">new</span> <span class="title class_">Arraylist</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">list3.add(<span class="keyword">new</span> <span class="title class_">Wanger</span>());</span><br><span class="line">list3.add(<span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wanger w3 = list3.get(0);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要注意的是，无法从 <code>Arraylist&lt;? super Wanger&gt;</code> 这样类型的 list3 中取出数据。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> Java 中，泛型是一种强类型约束机制，可以在编译期间检查类型安全性，并且可以提高代码的复用性和可读性</p>
<p>定义一个泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以在类中任何<strong>需要使用类型的地方使用 T 代替具体的类型。</strong>通过使用泛型，我们可以创建一个可以存储任何类型对象的盒子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">Box&lt;String&gt; strBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型擦除-1"><a href="#类型擦除-1" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>编译时会将泛型类型擦除，将泛型类型替换成 Object 类型。这是为了向后兼容，避免对原有的 Java 代码造成影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">intList.add(<span class="number">123</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> intList.get(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java 编译器会将泛型类型 <code>List&lt;Integer&gt;</code> 替换成 <code>List&lt;Object&gt;</code>，将 get 方法的返回值类型 Integer 替换成 Object，生成的字节码与下面的代码等价：</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>用于表示某种未知的类型，例如 <code>List&lt;?&gt;</code> 表示一个可以存储任何类型对象的 List，但是不能对其中的元素进行添加操作。</p>
<p>通配符可以用来解决类型不确定的情况，例如在方法参数或返回值中</p>
<p>通配符可以使方法更加通用，同时保证类型安全。</p>
<h4 id="下限通配符"><a href="#下限通配符" class="headerlink" title="下限通配符"></a>下限通配符</h4><p>下限通配符（Lower Bounded Wildcards）用 super 关键字来声明，其语法形式为 <code>&lt;? super T&gt;</code>，其中 T 表示类型参数。它表示的是该类型参数必须是某个指定类的超类（包括该类本身）。</p>
<p>可以将指定类型的子类型添加到集合中，保证了元素的完整性。</p>
<p>假设有一个类 Animal，以及两个子类 Dog 和 Cat。现在我们有一个 <code>List&lt;? super Dog&gt;</code> 集合，它的类型参数必须是 Dog 或其父类类型。我们可以向该集合中添加 Dog 类型的元素，也可以添加它的子类。但是，不能向其中添加 Cat 类型的元素，因为 Cat 不是 Dog 的子类。</p>
<p>虽然使用下限通配符可以添加某些子类型元素，但是在读取元素时，我们只能确保其是 Object 类型的，<strong>无法确保其是指定类型或其父类型</strong>。因此，在读取元素时需要进行类型转换，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Dog&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">animals.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取元素时需要进行类型转换</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">animal</span> <span class="operator">=</span> animals.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="上限通配符"><a href="#上限通配符" class="headerlink" title="上限通配符"></a>上限通配符</h4><p>上限通配符 <code>&lt;? extends T&gt;</code>，表示通配符只能接受 T 或 T 的子类。使用上限通配符可以提高程序的类型安全性。</p>
<hr>
<p>Java 的泛型机制是一种非常强大的类型约束机制，可以在编译时检查类型安全性，并提高代码的复用性和可读性。但是，在使用泛型时也需要注意类型擦除和通配符等问题，以确保代码的正确性。</p>
<h1 id="第十六章-多线程"><a href="#第十六章-多线程" class="headerlink" title="第十六章 多线程"></a>第十六章 多线程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>同一时刻, 只允许执行一个</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程:"></a>多线程:</h3><p>同一个时刻, 可以执行多个线程, 比如一个QQ可以同时打开多个窗口</p>
<p>普通方法调用和多线程 </p>
<ul>
<li><p>并发</p>
<p>同一时刻, 多个任务交替执行, 造成一种同时发生的错觉. 单核CPU实现的多任务就是并发</p>
</li>
<li><p>并行</p>
<p>同一时刻, 多个任务同时执行, 多核CPU</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202406041732911.png" alt=" "></p>
<h3 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序, 进程, 线程"></a>程序, 进程, 线程</h3><ul>
<li>操作系统中运行的程序就是进制</li>
<li>一个进程可以有多个线程, 如播放器的声音, 图像, 字幕</li>
</ul>
<h3 id="Process与Thread"><a href="#Process与Thread" class="headerlink" title="Process与Thread"></a>Process与Thread</h3><ul>
<li>说起进程,就不得不说下程序。<strong>程序</strong>是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。</li>
<li>而<strong>进程</strong>则是执行程序的依次执行过程，它是一个动态的概念。是系统资源分配的单位。</li>
<li>通常在一个进程中可以包含若干个<strong>线程</strong>，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li>线程就是独立的执行路径。</li>
<li>在程序运行时,即使没有自己创建线程,后台也会有多个线程,比如主线程,GC线程。</li>
<li>main()称之为主线程,为系统的入口,用于执行整个程序。</li>
<li>在一个进程中,如果开辟了多个线程,线程的运行是由调度器（cpu）安排调度的,调度器是与操作系统紧密相关的,先后顺序是不能人为干预的。</li>
<li>对同一份资源操作时mm会存在资源抢夺的问题,需要加入并发控制。</li>
<li>线程会带来额外的开销,如CPU调度时间,并发控制开销。</li>
<li>每个线程在自己的工作内存交互,内存控制不当会造成数据不一致。</li>
</ul>
<h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><h3 id="继承Thread类（重要）"><a href="#继承Thread类（重要）" class="headerlink" title="继承Thread类（重要）"></a>继承Thread类<strong>（重要）</strong></h3><ul>
<li>自定义线程类继承<code>Thread</code>类；</li>
</ul>
<ul>
<li>重写<code>run()</code>方法，编写线程执行体；</li>
<li>创建线程对象，调用<code>start()</code>方法启动线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.threaduse;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Cat对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            (1)</span></span><br><span class="line"><span class="comment">            public synchronized void start() &#123;</span></span><br><span class="line"><span class="comment">                start0();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            (2)</span></span><br><span class="line"><span class="comment">            //start0() 是本地方法，是JVM调用, 底层是c/c++实现</span></span><br><span class="line"><span class="comment">            //真正实现多线程的效果， 是start0(), 而不是 run</span></span><br><span class="line"><span class="comment">            private native void start0();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        cat.start();<span class="comment">//启动线程-&gt; 最终会执行cat的run方法</span></span><br><span class="line">        <span class="comment">//cat.run();//run方法就是一个普通的方法, 没有真正的启动一个线程(启动的是main)，就会把run方法执行完毕，才向下执行</span></span><br><span class="line">        <span class="comment">//说明: 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</span></span><br><span class="line">        <span class="comment">//这时 主线程和子线程是交替执行..</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行&quot;</span> + Thread.currentThread().getName());<span class="comment">//名字main</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程 i=&quot;</span> + i);</span><br><span class="line">            <span class="comment">//让主线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span></span><br><span class="line"><span class="comment">//2. 我们会重写 run方法，写上自己的业务代码</span></span><br><span class="line"><span class="comment">//3. run Thread 类 实现了 Runnable 接口的run方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//重写run方法，写上自己的业务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//该线程每隔1秒。在控制台输出 “喵喵, 我是小猫咪”</span></span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵, 我是小猫咪&quot;</span> + (++times) + <span class="string">&quot; 线程名=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//让该线程休眠1秒 ctrl+alt+t</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(times == <span class="number">80</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//当times 到80, 退出while, 这时线程也就退出..</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120145152801.png" alt="image-20240120145152801"></p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ol>
<li>Java是单继承, 如果一个类已经继承了一个父类, 这时就不能再继承Thread了</li>
<li>Java设计者提供了另外一个创建线程, Runnable</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//dog.start(); 不能使用</span></span><br><span class="line">        <span class="comment">//创建Thread对象, 将dog放入调用</span></span><br><span class="line">        <span class="type">Threadalbe</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Threadalbe</span>(dog);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hahah&quot;</span> + (++count) + <span class="string">&quot; 线程名=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">             <span class="comment">//休眠</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thead.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>&#x2F;多个线程操作同一个资源的情况下,线程不安全,数据紊乱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.smt.demo01;</span><br><span class="line"><span class="comment">//多个线程同时操作同一个对象  买火车票案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread04</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestThread04</span> <span class="variable">thread04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread04</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread04,<span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread04,<span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread04,<span class="string">&quot;王五&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread04,<span class="string">&quot;赵六&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticketNums &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 捕获异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---》拿到了第&quot;</span> + ticketNums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>并发 龟兔赛跑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java_2.Thread.threaduse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Race</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner; <span class="comment">//static只有一个赢家</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Race</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Race</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread, <span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">            <span class="comment">//模拟兔子睡觉</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>) &amp;&amp; i &gt; <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//判断是否有赢家</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flags</span> <span class="operator">=</span> winner(i);</span><br><span class="line">            <span class="keyword">if</span> ( flags == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;running:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">winner</span> <span class="params">(<span class="type">int</span> step)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (step &gt;= <span class="number">99</span>) &#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;win&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul>
<li>实现Callable接口，需要返回值类型；</li>
<li>重写call方法，需要抛出异常；</li>
<li>创建目标对象；</li>
<li>创建执行服务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</li>
<li>提交执行：Future result1 &#x3D; ser.submit(11);</li>
<li>获取结果：boolean r1 &#x3D; result1.get();</li>
<li>关闭服务：ser.shutdownNow();</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li><p>继承Thread类:</p>
<ul>
<li>子类继承Thread类具备多线程能力；</li>
<li>启动线程:子类对象.start()；</li>
<li>不建议使用:避免OOP单继承局限性。</li>
</ul>
</li>
<li><p>实现Runnable接口</p>
<ul>
<li><p>实现接口Runnable具有多线程能力；</p>
</li>
<li><p>启动线程:传入目标对象+Thread对象.start()；</p>
<pre><code>    Race thread = new Race(); //目标对象
    new Thread(thread, &quot;兔子&quot;).start();//Thread对象.start();
    new Thread(thread, &quot;乌龟&quot;).start();
</code></pre>
</li>
<li><p>推荐使用:避免单继承局限性,灵活方便,方便同一个对象被多个线程使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>Java 静态代理是一种实现代理设计模式的方法，其中代理类和目标类实现相同的接口。静态代理中，代理类和目标类在编译时就已经确定，代理类将客户端的请求转发给-&gt;目标类，并将结果返回给客户端。</p>
<p>具体类实现方法, 代理类调用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实现接口的具体类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCalculator</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> a + b;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> a - b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 定义代理类，实现相同的接口，转发请求到目标类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorProxy</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalculatorProxy</span><span class="params">(Calculator calculator)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.calculator = calculator;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before add&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.add(a, b);  </span><br><span class="line">        System.out.println(<span class="string">&quot;After add&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before subtract&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.subtract(a, b);  </span><br><span class="line">        System.out.println(<span class="string">&quot;After subtract&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建目标类的实例  </p>
</li>
<li><p>创建代理类的实例，将目标类的实例传入代理类构造函数中，实现代理关系</p>
</li>
<li><p>调用代理类的方法，实际上是转发请求到目标类的方法，**并在前后添加日志输出等操作 **</p>
</li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 创建目标类的实例  </span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCalculator</span>();  </span><br><span class="line">        <span class="comment">// 创建代理类的实例，将目标类的实例传入代理类构造函数中，实现代理关系  </span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorProxy</span>(calculator);  </span><br><span class="line">        / </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> proxy.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 输出 &quot;Before add&quot; 和 &quot;After add&quot;，结果为 3  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result); <span class="comment">// 输出结果为 3  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式是 Java 8 引入的一项重要特性，它允许以更简洁和灵活的方式编写匿名函数，从而实现函数式编程的特性。</p>
<p>Lambda 表达式的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>(parameters)</code> 指定了 Lambda 表达式的参数列表。</li>
<li><code>-&gt;</code> 是 Lambda 操作符，将参数列表与 Lambda 表达式的主体分隔开。</li>
<li><code>expression</code> 或 <code>&#123; statements; &#125;</code> 是 Lambda 表达式的主体，可以是单个表达式或一个代码块。</li>
</ul>
<p>Lambda 表达式可以替代匿名内部类的语法，通常用于简化函数式接口的实现，这是因为 Lambda 表达式只能用于函数式接口，即只有一个抽象方法的接口。</p>
<p>例如，对于一个函数式接口 <code>Runnable</code>，可以使用 Lambda 表达式来实现它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式的主要优点包括：</p>
<ul>
<li>更简洁：可以减少冗余的代码，提高代码的可读性和可维护性。</li>
<li>支持函数式编程：使 Java 更接近于函数式编程语言，支持函数作为一等公民。</li>
</ul>
<p>Lambda 表达式在 Java 中的广泛应用使得编写函数式风格的代码变得更加方便和简单。</p>
<ul>
<li>理解Functional Interface (函数式接口) 是学习Java 8 lambda表达式的关键</li>
</ul>
<p>任何接口，如果<strong>只包含唯一一个抽象方法</strong>，那么它就是一个函数s式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">对于函数式接口，我们可以通过Lambda表达式来创建该接口的对象</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120171759949.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120172506884.png" alt="image-20240120172506884"></p>
<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120172723779.png" alt="image-20240120172723779"></p>
<h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/QyingliBoost/Photo/main/image-20240120173044314.png" alt="image-20240120173044314"></p>
<h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240120174324044.png" alt="image-20240120174324044"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><ul>
<li>礼让线程, 让当前线程正在执行的线程暂停, 但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li>让CPU重新调度, 不一定成功, 看CPU状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java_2.Thread.threaduse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMyYeild</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyYelid</span> <span class="variable">myyeild1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyYelid</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(myyeild1, <span class="string">&quot;1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(myyeild1, <span class="string">&quot;2&quot;</span>).start();</span><br><span class="line">        <span class="comment">//没有yelid 应该是12开始然后结束</span></span><br><span class="line">        <span class="comment">//有yelid后, 可能会出现1开始,1结束,再开始2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyYelid</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h4><ul>
<li>join合并线程, 等待此线程执行完成后, 再执行其他线程, 其他线程阻塞</li>
<li>类似插队</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试join</span></span><br><span class="line"><span class="comment"> * 插队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo20_JoinThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程vip&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//启动我们的线程</span></span><br><span class="line">        <span class="type">Demo20_JoinThread</span> <span class="variable">joinThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo20_JoinThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(joinThread);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="comment">//主线程到500是必须等thread执行完才能继续</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">200</span>) &#123;</span><br><span class="line">                thread.join();<span class="comment">//插队</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240120182125097.png" alt="image-20240120182125097"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察测试线程状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo21_ThreadState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;//&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//观察状态</span></span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">        <span class="comment">//观察启动后</span></span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//Run</span></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED) &#123;<span class="comment">//只要现成不终止,就一直输出状态</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            state = thread.getState();<span class="comment">//更新线程状态</span></span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//死亡后的线程不能再启动了,启动会报异常</span></span><br><span class="line">        <span class="comment">//thread.start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程, 线程调度器按照优先级决定应该调度哪个线程来执行。</p>
</li>
<li><p>线程的优先级用数字表示,范围从1~10.</p>
<ul>
<li>Thread.MIN_PRIORITY &#x3D; 1;</li>
<li>Thread.MAX_PRIORITY &#x3D; 10;</li>
<li>Thread.NORM_PRIORITY &#x3D; 5;</li>
</ul>
</li>
<li><p>使用以下方式改变或获取优先级</p>
<ul>
<li>getPriority() . setPriority(int xxx)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPriority</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 主线程默认优先级</span></span><br><span class="line">  System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;--&gt;&quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        <span class="type">MyPriority</span> <span class="variable">myPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyPriority</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myPriority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myPriority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myPriority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myPriority);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myPriority);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先设置优先级，再启动</span></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread2.setPriority(<span class="number">1</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread3.setPriority(<span class="number">4</span>);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MAX_PRIORITY=10</span></span><br><span class="line">        thread4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread4.start();</span><br><span class="line"></span><br><span class="line">        thread5.setPriority(<span class="number">8</span>);</span><br><span class="line">        thread5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPriority</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;--&gt;&quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优先级越高, 先执行的概率越高</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul>
<li><p>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></p>
</li>
<li><p>虚拟机必须确保用户线程执行完毕</p>
</li>
<li><p>虚拟机不用等待守护线程执行完毕</p>
</li>
<li><p>作用如: 后台记录操作日志,监控内存,垃圾回收等待 ..</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemoThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">God</span> <span class="variable">god</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">God</span>();</span><br><span class="line">        <span class="type">You</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">You</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(god);</span><br><span class="line">        <span class="comment">// 默认false表示是用户线程，正常线程都是用户线程</span></span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);<span class="comment">//该为守护线程</span></span><br><span class="line">        <span class="comment">// 耶稣守护线程启动</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 你 用户线程启动</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(you).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">God</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;耶稣都救不了你！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">You</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------你好，世界！------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;每天都很开心！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------再见，世界！------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用户线程结束后, 守护线程不一定结束, 等待程序停止后结束</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><blockquote>
<p>主要用于确保多个线程在访问共享资源时能够正确地协调它们的行为，以避免出现数据不一致或数据损坏的情况。</p>
</blockquote>
<p>线程同步的形成条件: 队列 + 锁</p>
<p>由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问</p>
<p>冲突问题,为了保证数据在方法中被访问时的正确性, 在访问时加入 <strong>锁机制synchronized</strong>, 当一个线程获得对象的排它锁, 独占资源, 其他线程必须等待,</p>
<p>使用后释放锁即可.存在以下问题:</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li>
<li>在多线程竞争下, 加锁, 释放锁会导致比较多的上下文切换 和 调度延时, 引起性能问题;</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置, 引起性能问题.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUnsafeBuyTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">buyTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket,<span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket,<span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket,<span class="string">&quot;王五&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 买票</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 买票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>&#123;    <span class="comment">//如果加入synchronized会线程同步</span></span><br><span class="line">        <span class="comment">// 判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span>(ticketNums &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延迟</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 买票</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">            + <span class="string">&quot;拿到&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个线程在自己的工作内存交互,内存控制不当会造成数据不一致。</p>
<p>比如票数只有1的时候, 三个线程看到都可以抢票, 最终会导致负数票数</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121125016223.png" alt="image-20240121125016223"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121125128578.png" alt="image-20240121125128578"></p>
<ol>
<li>同步代码块</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Object) &#123;</span><br><span class="line">    <span class="comment">//得到对象的锁, 才能操作同步代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//static方法</span></span><br><span class="line"><span class="keyword">synchronized</span> (当前类.class) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>放在方法声明中, 表示整个方法为同步方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><p>每个进程进入run方法时, 会先拿到锁, 使用完成后, 释放锁</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121130408910.png" alt="image-20240121130408910"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ol>
<li><p>Java语言中, 引入了对象互斥锁的概念, 来保证共享数据操作的完整性。</p>
</li>
<li><p>每个对象都对应于一个可称为“互斥锁”的标记, 这个标记用来保证在任一时刻, 只能有一个线程访问该对象。</p>
</li>
<li><p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时, 表明该对象在任一时刻只能由一个线程访问</p>
</li>
<li><p>同步的局限性: 导致程序的执行效率要降低</p>
</li>
<li><p>同步方法(非静态的)的锁可以是this, 也可以是其他对象(要求是同一个对象)</p>
</li>
<li><p>同步方法(静态的)的锁为当前类本身。</p>
</li>
</ol>
<h4 id="细节-7"><a href="#细节-7" class="headerlink" title="细节"></a>细节</h4><ol>
<li>同步方法如果没有使用static修饰:默认锁对象为thi</li>
<li>如果方法使用static修饰,默认锁对象:当前类.class</li>
</ol>
<p>实现的落地步骤:</p>
<ul>
<li>需要先分析上锁的代码</li>
<li>选择同步代码块或同步方法</li>
<li>要求多个线程的锁对象为同一个即可!</li>
</ul>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p> 多个线程都占用了对方的锁资源, 但不肯想让, 导致了死锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.java_2.Thread.threaduse;</span><br><span class="line"></span><br><span class="line">public class DeadLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试死锁</span><br><span class="line">        Dead dead = new Dead(true);</span><br><span class="line">        Dead dead2 = new Dead(false);</span><br><span class="line">        new Thread(dead, &quot;张三&quot;).start();</span><br><span class="line">        new Thread(dead2, &quot;李四&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dead implements Runnable &#123;</span><br><span class="line">    //static保证只有一个对象</span><br><span class="line">    static Object lock1 = new Object();</span><br><span class="line">    static Object lock2 = new Object();</span><br><span class="line">    boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public Dead(boolean flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    //如果flag为真, 进入1, 如果为假进入2,</span><br><span class="line">    //如果同时两个线程, 一真一假, 则会进入死锁</span><br><span class="line">    public void run( ) &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            synchronized (lock1) &#123;//对象互斥锁, 下面时同步代码</span><br><span class="line">                System.out.println(&quot;进入1&quot;);</span><br><span class="line">                synchronized (lock2) &#123;// 获得对象监视权</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;进入2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(&quot;进入2&quot;);</span><br><span class="line">                synchronized (lock1) &#123; //获得监视权</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;进入1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><ol>
<li><p>当前线程的同步方法、同步代码块执行结束<br>案例:上厕所,完事出来</p>
</li>
<li><p>当前线程在同步代码块、同步方法中遇到break、return。<br>案例:没有正常的完事,经理叫他修改bug,不得已出来</p>
</li>
<li><p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束<br>案例:没有正常的完事,发现忘带纸,不得已出来</p>
</li>
<li><p>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法,当前线程暂停,并释放锁。<br>案例:没有正常完事,觉得需要酝酿下,所以出来等会再进去</p>
</li>
</ol>
<h1 id="十七章-IO流"><a href="#十七章-IO流" class="headerlink" title="十七章 IO流"></a>十七章 IO流</h1><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240123140231722.png" alt="image-20240123140231722"></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件就是保存数据的地方</p>
<h3 id="流的特点"><a href="#流的特点" class="headerlink" title="流的特点"></a>流的特点</h3><ul>
<li>先进先出：最先写入输出流的数据最先被输入流读取到。</li>
<li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile除外）</li>
<li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流</li>
</ul>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>文件再程序中是以流的形式来操作的</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121144354877.png" alt="image-20240121144354877"></p>
<p>流:</p>
<p>数据在数据源(文件)和程序(内存)之间经历的路径</p>
<h2 id="IO流原理及分类"><a href="#IO流原理及分类" class="headerlink" title="IO流原理及分类"></a>IO流原理及分类</h2><ul>
<li><p>I&#x2F;O是Input&#x2F;Output的缩写, I&#x2F;O技术是非常实用的技术, 用于处理数据传输。如读&#x2F;写文件,网络通讯等。</p>
</li>
<li><p>Java程序中, 对于数据的输入&#x2F;输出操作以”流(stream)”的方式进行。</p>
</li>
<li><p>java.io包下提供了各种“流”类和接口, 用以获取不同种类的数据, 并通过方法输入或输出数据</p>
</li>
</ul>
<h3 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h3><p><strong>输入input:</strong> 读取外部数据</p>
<p><strong>输出output:</strong> 将(程序)内存数据输出到硬盘</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121152400181.png" alt="image-20240121152400181"></p>
<h3 id="根据传输方式划分"><a href="#根据传输方式划分" class="headerlink" title="根据传输方式划分"></a>根据传输方式划分</h3><ul>
<li><p>字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。</p>
</li>
<li><p>字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。</p>
</li>
<li><p>虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121152517912.png" alt="image-20240121152517912"></p>
<p><strong>InputStream 类</strong></p>
<ul>
<li><code>int read()</code>：读取数据</li>
<li><code>int read(byte b[], int off, int len)</code>：从第 off 位置开始读，读取 len 长度的字节，然后放入数组 b 中</li>
<li><code>long skip(long n)</code>：跳过指定个数的字节</li>
<li><code>int available()</code>：返回可读的字节数</li>
<li><code>void close()</code>：关闭流，释放资源</li>
</ul>
<p><strong>OutputStream 类</strong></p>
<ul>
<li><code>void write(int b)</code>： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃（这块后面再讲）</li>
<li><code>void write(byte b[], int off, int len)</code>： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入</li>
<li><code>void flush()</code>： 强制刷新，将缓冲区的数据写入</li>
<li><code>void close()</code>：关闭流</li>
</ul>
<p><strong>Reader 类</strong></p>
<ul>
<li><code>int read()</code>：读取单个字符</li>
<li><code>int read(char cbuf[], int off, int len)</code>：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中</li>
<li><code>long skip(long n)</code>：跳过指定个数的字符</li>
<li><code>int ready()</code>：是否可以读了</li>
<li><code>void close()</code>：关闭流，释放资源</li>
</ul>
<p><strong>Writer 类</strong></p>
<ul>
<li><code>void write(int c)</code>： 写入一个字符</li>
<li><code>void write( char cbuf[], int off, int len)</code>： 将数组 cbuf 中的从 off 位置开始，长度为 len 的字符写入</li>
<li><code>void flush()</code>： 强制刷新，将缓冲区的数据写入</li>
<li><code>void close()</code>：关闭流</li>
</ul>
<h4 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h4><ul>
<li>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</li>
</ul>
<p>字符流源码 , 利用到了缓冲区</p>
<h3 id="操作对象划分"><a href="#操作对象划分" class="headerlink" title="操作对象划分"></a>操作对象划分</h3><p>文件操作算是 IO 中最典型的操作了，也是最频繁的操作。</p>
<p>那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为：</p>
<ul>
<li>文件、数组、管道、基本数据类型、缓冲、打印、对象序列化&#x2F;反序列化，以及转换等。</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240123143424196.png" alt="image-20240123143424196" style="zoom:67%;" />

<h2 id="文件流-IO流的起点与终点"><a href="#文件流-IO流的起点与终点" class="headerlink" title="文件流: IO流的起点与终点"></a>文件流: IO流的起点与终点</h2><p> IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。</p>
<p><code>java.io.File</code> 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。</p>
<p><code>File</code> 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！</p>
<p>第二句是说 File 可以表示<code>D:\\文件目录1</code>与<code>D:\\文件目录1\\文件.txt</code>，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的。</p>
<h3 id="创建文件对象相关构造器和方法"><a href="#创建文件对象相关构造器和方法" class="headerlink" title="创建文件对象相关构造器和方法"></a>创建文件对象相关构造器和方法</h3><p>创建文件和目录</p>
<p>比较常用的构造方法有三个：</p>
<p>1、 <code>File(String pathname)</code> ：通过给定的<strong>路径</strong>来创建新的 File 实例。</p>
<p>2、 <code>File(String parent, String child)</code> ：从<strong>父路径（字符串）和子路径</strong>创建新的 File 实例。</p>
<p>3、 <code>File(File parent, String child)</code> ：从<strong>父路径（File）和子路径名字符串</strong>创建新的 File 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;e:\\new.txt&quot;</span>;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">createNewFile 创建新文件</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname);    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="comment">//e:\\news2.txt</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create02</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line"><span class="comment">//这里的 file 对象，在 java 程序中，只是一个对象</span></span><br><span class="line"><span class="comment">//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">    	System.out.println(<span class="string">&quot;创建成功~&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式 3 new File(String parent,String child) //根据父目录+子路径构建</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//String parentPath = &quot;e:\\&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news4.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath, fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	file.createNewFile();</span><br><span class="line">    	System.out.println(<span class="string">&quot;创建成功~&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><p><strong>获取功能的方法</strong></p>
<p>1、<code>getAbsolutePath()</code> ：返回此 File 的绝对路径。</p>
<p>2、<code>getPath()</code> ：结果和 getAbsolutePath 一致。</p>
<p>3、<code>getName()</code> ：返回文件名或目录名。</p>
<p>4、<code>length()</code> ：返回文件长度，以字节为单位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\news1.txt&quot;</span>);</span><br><span class="line"><span class="comment">//调用相应的方法，得到对应信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件名字=&quot;</span> + file.getName());</span><br><span class="line"><span class="comment">//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;文件父级目录=&quot;</span> + file.getParent());</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小(字节)=&quot;</span> + file.length());</span><br><span class="line">System.out.println(<span class="string">&quot;文件是否存在=&quot;</span> + file.exists());<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span> + file.isFile());<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());<span class="comment">//F</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><p>1、 <code>exists()</code> ：判断文件或目录是否存在。</p>
<p>2、 <code>isDirectory()</code> ：判断是否为目录。</p>
<p>3、<code>isFile()</code> ：判断是否为文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/username/example&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断文件或目录是否存在</span></span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件或目录存在&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件或目录不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是目录</span></span><br><span class="line"><span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;是目录&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不是目录&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是文件</span></span><br><span class="line"><span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;是文件&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不是文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="目录的操作和文件删除"><a href="#目录的操作和文件删除" class="headerlink" title="目录的操作和文件删除"></a>目录的操作和文件删除</h3><ul>
<li><code>createNewFile()</code> ：文件不存在，创建一个新的空文件并返回<code>true</code>，文件存在，不创建文件并返回<code>false</code>。</li>
<li><code>delete()</code> ：删除文件或目录。如果是目录，只有目录为空才能删除。</li>
<li><code>mkdir()</code> ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。</li>
<li><code>mkdirs()</code> ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path)</span><br><span class="line"><span class="comment">//删除 </span></span><br><span class="line"><span class="keyword">if</span>(file.exists()) &#123; </span><br><span class="line">    file.delete();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    file.mkdirs();</span><br><span class="line">    file.mkdisr();<span class="comment">//不能创建多级目录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java中, 目录也被当做文件</span></span><br></pre></td></tr></table></figure>

<h3 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h3><ul>
<li><code>String[] list()</code> ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li>
<li><code>File[] listFiles()</code> ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/itwanger/Documents/Github/paicoding&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录下的文件名</span></span><br><span class="line">String[] files = directory.list();</span><br><span class="line">System.out.println(<span class="string">&quot;目录下的文件名：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录下的文件和子目录</span></span><br><span class="line">File[] filesAndDirs = directory.listFiles();</span><br><span class="line">System.out.println(<span class="string">&quot;目录下的文件和子目录：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (File fileOrDir : filesAndDirs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fileOrDir.isFile()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件：&quot;</span> + fileOrDir.getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileOrDir.isDirectory()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目录：&quot;</span> + fileOrDir.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>listFiles</strong>在获取指定目录下的文件或者子目录时必须满足下面两个条件：</p>
<ul>
<li><ol>
<li><strong>指定的目录必须存在</strong></li>
</ol>
</li>
<li><ol>
<li><strong>指定的必须是目录。否则容易引发 NullPointerException 异常</strong></li>
</ol>
</li>
</ul>
<h2 id="字节流-Java-IO的基石"><a href="#字节流-Java-IO的基石" class="headerlink" title="字节流: Java IO的基石"></a>字节流: Java IO的基石</h2><p>必须得明确一点，一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。</p>
<h3 id="字节输出流（OutputStream）"><a href="#字节输出流（OutputStream）" class="headerlink" title="字节输出流（OutputStream）"></a>字节输出流（OutputStream）</h3><p><code>java.io.OutputStream</code> 是<strong>字节输出流</strong>的<strong>超类</strong>（父类），我们来看一下它定义的一些共性方法：</p>
<p>1、 <code>close()</code> ：关闭此输出流并释放与此流相关联的系统资源。</p>
<p>2、 <code>flush()</code> ：刷新此输出流并强制缓冲区的字节被写入到目的地。</p>
<p>3、 <code>write(byte[] b)</code>：将 b.length 个字节从指定的字节数组写入此输出流。</p>
<p>4、 <code>write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 <strong>也就是说从off个字节数开始一直到len个字节结束</strong></p>
<h4 id="FileInputStream和Output例子"><a href="#FileInputStream和Output例子" class="headerlink" title="FileInputStream和Output例子"></a>FileInputStream和Output例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个 int 类型的变量 b，用于存储读取到的字节</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="comment">// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fis.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件中的数据</span></span><br><span class="line"><span class="keyword">while</span> ((b = fis1.read()) != -<span class="number">1</span>) &#123;<span class="comment">// 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1。</span></span><br><span class="line">    <span class="comment">// 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台</span></span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 FileInputStream 对象，释放资源</span></span><br><span class="line">fis1.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////</span></span><br><span class="line"><span class="comment">// 声明一个 int 类型的变量 b，用于存储读取到的字节</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="comment">// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fis.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取文件中的数据</span></span><br><span class="line"><span class="keyword">while</span> ((b = fis1.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台</span></span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 FileInputStream 对象，释放资源</span></span><br><span class="line">fis1.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>写入字节数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line"><span class="comment">// 字符串转换为字节数组</span></span><br><span class="line"><span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes(); </span><br><span class="line"><span class="comment">// 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<h3 id="数据追加-换行"><a href="#数据追加-换行" class="headerlink" title="数据追加, 换行"></a>数据追加, 换行</h3><p>上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续<strong>追加新数据</strong>，该怎么办呢？以及如何实现<strong>换行</strong>呢？</p>
<p>使用<code>FileOutputStream</code>的另外两个构造方法</p>
<ol>
<li>使用文件名和追加标志创建FileOutputStream对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">append</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//附加的意思, false表示清除数据</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;examle.txt&quot;</span>, append);</span><br><span class="line"><span class="comment">//将数据追加到末尾</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>换行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;测试\r\n&quot;</span>; <span class="comment">//使用换行符</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;examle.txt&quot;</span>, append);</span><br><span class="line">fos.write(content.getBytes());</span><br></pre></td></tr></table></figure>



<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 <code>read()</code>、<code>read(byte[] b)</code>、<code>read(byte[] b, int off, int len)</code> 等。</p>
<p>OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 <code>write(int b)</code>、<code>write(byte[] b)</code>、<code>write(byte[] b, int off, int len)</code> 等。</p>
<p>这两个抽象类是字节流的基础。</p>
<p>FileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。</p>
<p>FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。</p>
<p>这两个类是字节流最常用的实现类之一。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字符符流 Reader 和 Writer 的故事要从它们的类关系图开始，来看图。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240121215209832.png" alt="image-20240121215209832"></p>
<p>用字节流直接读取中文，可能会遇到乱码问题</p>
<p>之所以出现乱码是因为在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。</p>
<p>用字节流处理中文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们拿 String 类进行了解码，查看<code>new String(byte bytes[], int offset, int length)</code>的源码就可以发现，该构造方法有解码功能</p>
<p>另一角度来说：<strong>字符流 &#x3D; 字节流 + 编码表</strong></p>
<h3 id="字符传入流Reader"><a href="#字符传入流Reader" class="headerlink" title="字符传入流Reader"></a>字符传入流Reader</h3><p><code>java.io.Reader</code>是<strong>字符输入流</strong>的<strong>超类</strong>（父类），它定义了字符输入流的一些共性方法：</p>
<ul>
<li>1、<code>close()</code>：关闭此流并释放与此流相关的系统资源。</li>
<li>2、<code>read()</code>：从输入流读取一个字符。</li>
<li>3、<code>read(char[] cbuf)</code>：从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</li>
</ul>
<p>FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：</p>
<ul>
<li>可以通过构造方法指定要读取的文件路径。</li>
<li>每次可以读取一个或多个字符。</li>
<li>可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>1、<code>FileReader(File file)</code>：创建一个新的 FileReader，参数为<strong>File对象</strong>。</li>
<li>2、<code>FileReader(String fileName)</code>：创建一个新的 FileReader，参数为文件名。</li>
</ul>
<h4 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h4><p><strong>1. 读取字符</strong>：<code>read</code>方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回<code>-1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;abc.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 定义变量，保存数据</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="comment">// 循环读取</span></span><br><span class="line"><span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">fr.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 读取指定长度的字符</strong>：<code>read(char[] cbuf, int off, int len)</code>，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数</p>
<p>例如: off &#x3D; 9, len &#x3D; 数组.length</p>
<p>FileReader 实现了 AutoCloseable 接口，因此可以使用 <code>try-with-resource</code>语句自动关闭资源，避免了手动关闭资源的繁琐操作。</p>
<h3 id="字符输出流-Writer"><a href="#字符输出流-Writer" class="headerlink" title="字符输出流 Writer"></a>字符输出流 Writer</h3><p><code>java.io.Writer</code> 是<strong>字符输出流</strong>类的<strong>超类</strong>（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：</p>
<ul>
<li>1、<code>write(int c)</code> 写入单个字符。</li>
<li>2、<code>write(char[] cbuf)</code> 写入字符数组。</li>
<li>3、<code>write(char[] cbuf, int off, int len)</code> 写入字符数组的一部分，off为开始索引，len为字符个数。</li>
<li>4、<code>write(String str)</code> 写入字符串。</li>
<li>5、<code>write(String str, int off, int len)</code> 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。</li>
<li>6、<code>flush()</code> 刷新该流的缓冲。</li>
<li>7、<code>close()</code> 关闭此流，但要先刷新它。</li>
</ul>
<p><code>java.io.FileWriter</code> 类是 Writer 的子类，用来将字符写入到文件。</p>
<h4 id="FileWriter-构造方法"><a href="#FileWriter-构造方法" class="headerlink" title="FileWriter 构造方法"></a>FileWriter 构造方法</h4><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，参数为要读取的File对象。</li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，参数为要读取的文件的名称。</li>
</ul>
<h4 id="FileWriter写入数据"><a href="#FileWriter写入数据" class="headerlink" title="FileWriter写入数据"></a>FileWriter写入数据</h4><p>写入指定字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line">fw.write(chars, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 将字符数组的前 5 个字符写入文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写入指定字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;沉默王二真的帅啊！&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    fw.write(str, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 将字符串的前 5 个字符写入文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关闭close和刷新flush"><a href="#关闭close和刷新flush" class="headerlink" title="关闭close和刷新flush"></a>关闭close和刷新flush</h4><p>FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中</p>
<p>但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 <code>flush</code> 方法了。</p>
<p><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</p>
<p><code>close</code> ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源   也就是输入流【读取流】 读取a.txt文件</span></span><br><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;abc.txt&quot;</span>);  <span class="comment">//必须要存在a.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line"><span class="comment">//目的地  也就是输出流</span></span><br><span class="line">FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>);  <span class="comment">//系统会自动创建b.txt，因为它是输出流！</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    fw.write(len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fr.close();<span class="comment">//关闭了缓冲区</span></span><br><span class="line">fw.flush();<span class="comment">//刷新缓冲区, 让其可以继续使用</span></span><br><span class="line">fw.close();<span class="comment">//最终关闭</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="FileWriter的续写和换行"><a href="#FileWriter的续写和换行" class="headerlink" title="FileWriter的续写和换行"></a>FileWriter的续写和换行</h4><p><strong>续写和换行</strong>：操作类似于<a target="_blank" rel="noopener" href="https://javabetter.cn/io/stream.html">FileOutputStream操作open in new window</a>，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用文件名称创建流对象，可以续写数据</span><br><span class="line">FileWriter fw = new FileWriter(&quot;fw.txt&quot;,true);     </span><br><span class="line">// 写出字符串</span><br><span class="line">fw.write(&quot;沉默王二&quot;);</span><br><span class="line">// 写出换行</span><br><span class="line">fw.write(&quot;\r\n&quot;);</span><br><span class="line">// 写出字符串</span><br><span class="line">fw.write(&quot;是傻 X&quot;);</span><br><span class="line">// 关闭资源</span><br><span class="line">fw.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Writer 和 Reader 是 Java I&#x2F;O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。</p>
<p>Writer 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。</p>
<p>在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I&#x2F;O 操作的效率。</p>
<p>Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。</p>
<p>缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的 I&#x2F;O 操作次数，提高系统的 I&#x2F;O 效率，从而提高程序的运行效率。</p>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>InputStream</strong>。</li>
<li><code>BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>OutputStream</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流，先声明字节流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(b.txt);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fps)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建字节缓冲输入流（一步到位）</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建字节缓冲输出流（一步到位）</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="缓冲流的高效"><a href="#缓冲流的高效" class="headerlink" title="缓冲流的高效"></a>缓冲流的高效</h4><p>我们通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;py.mp4&quot;</span>);<span class="comment">//exe文件够大</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copyPy.mp4&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再试试缓冲流 + 字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java_2.IOstream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIleCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        copyFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Qyingli\\Videos\\泸沽湖.mp4&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Qyingli\\Videos\\泸沽湖2.mp4&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用缓冲流起飞</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(newFilePath);</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line">            <span class="comment">//字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((readData = bis.read(buf, <span class="number">0</span>, <span class="number">4</span>)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buf, <span class="number">0</span>, readData); <span class="comment">//将数组 buf 中的从 0 位置开始，长度为 readData 的字节写入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传统的 Java IO 是阻塞模式的，它的工作状态就是“读&#x2F;写，等待，读&#x2F;写，等待。。。。。。”</p>
<p>字节缓冲流解决的就是这个问题：<strong>一次多读点多写点，减少读写的频率，用空间换时间</strong>。</p>
<ul>
<li>减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I&#x2F;O 操作的效率。</li>
<li>减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I&#x2F;O 操作的效率。</li>
<li>提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。</li>
</ul>
<h4 id="4）byte-0xFF"><a href="#4）byte-0xFF" class="headerlink" title="4）byte &amp; 0xFF"></a>4）<code>byte &amp; 0xFF</code></h4><p>byte 类型是有符号的，即其取值范围为 -128 到 127。如果我们希望得到的是一个无符号的 byte 值，就需要使用 <code>byte &amp; 0xFF</code> 来进行转换。</p>
<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 <code>readLine()</code> 方法可以一次读取一行数据，而不是一个字符一个字符地读取。</p>
<p>BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 <code>newLine()</code> 方法可以写入一个系统特定的行分隔符。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为<strong>Reader</strong>。</li>
<li><code>BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为<strong>Writer</strong>。</li>
</ul>
<h4 id="2）字符缓冲流特有方法"><a href="#2）字符缓冲流特有方法" class="headerlink" title="2）字符缓冲流特有方法"></a>2）字符缓冲流特有方法</h4><p>字符缓冲流的基本方法与<a target="_blank" rel="noopener" href="https://javabetter.cn/io/reader-writer.html">普通字符流open in new window</a>调用方式一致，这里不再赘述，我们来看字符缓冲流<strong>特有</strong>的方法。</p>
<ul>
<li>BufferedReader：<code>String readLine()</code>: <strong>读一行数据</strong>，读取到最后返回 null</li>
<li>BufferedWriter：<code>newLine()</code>: <strong>换行</strong>，由系统定义换行符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">line</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.print(line);</span><br><span class="line">    System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">br.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="type">BfferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">bw.write(<span class="string">&quot;沉&quot;</span>);</span><br><span class="line"><span class="comment">// 写出换行</span></span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(<span class="string">&quot;默&quot;</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(<span class="string">&quot;王&quot;</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">bw.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串分割</span></span><br><span class="line"><span class="type">String</span> <span class="variable">cmower</span> <span class="operator">=</span> <span class="string">&quot;沉默王二.一枚有趣的程序员&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (cmower.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">    String [] parts = cmower.split(Pattern.quote(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;第一部分：&quot;</span> + parts[<span class="number">0</span>] +<span class="string">&quot; 第二部分：&quot;</span> + parts[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>6.岑夫子，丹丘生，将进酒，杯莫停。</p>
<p>1.君不见黄河之水天上来，奔流到海不复回。</p>
<p>8.钟鼓馔玉不足贵，但愿长醉不愿醒。</p>
<p>3.人生得意须尽欢，莫使金樽空对月。</p>
<p>5.烹羊宰牛且为乐，会须一饮三百杯。</p>
<p>2.君不见高堂明镜悲白发，朝如青丝暮成雪。</p>
<p>7.与君歌一曲，请君为我倾耳听。</p>
<p>4.天生我材必有用，千金散尽还复来。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java_2.IOstream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffere</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        sortStirng();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortStirng</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Qyingli\\Documents\\MarkDown\\new.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Qyingli\\Documents\\MarkDown\\new22.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建流对象  源</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(newFilePath);</span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fos);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bis.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 解析文本</span></span><br><span class="line">                <span class="keyword">if</span> (line.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] split = line.split(Pattern.quote(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">                <span class="comment">// 保存到集合</span></span><br><span class="line">                lineMap.put(split[<span class="number">0</span>], split[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            for (int i = 1; i &lt;= lineMap.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//                String key = line.valueOf(i);</span></span><br><span class="line"><span class="comment">//                // 获取map中文本</span></span><br><span class="line"><span class="comment">//                String value = lineMap.get(key);</span></span><br><span class="line"><span class="comment">//                // 写出拼接文本</span></span><br><span class="line"><span class="comment">//                bos.write(key+&quot;.&quot;+value);</span></span><br><span class="line"><span class="comment">//                // 写出换行</span></span><br><span class="line"><span class="comment">//                bos.newLine();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="keyword">for</span> (String i : lineMap.keySet()) &#123;</span><br><span class="line">                bos.write(i + <span class="string">&quot;.&quot;</span> + lineMap.get(i));</span><br><span class="line">                <span class="comment">// 写出换行</span></span><br><span class="line">                bos.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String i : lineMap.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + i + <span class="string">&quot; value: &quot;</span> + lineMap.get(i));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>字节流和字符流之间的转换</p>
<p>转换流主要有两种类型：InputStreamReader 和 OutputStreamWriter。</p>
<p>InputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240122134827642.png" alt="image-20240122134827642"></p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。</p>
<p>常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240122135630180.png" alt="image-20240122135630180"></p>
<h4 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a><strong>ASCII 字符集</strong></h4><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。</p>
<p>ASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制。</p>
<h4 id="Unicode-字符集"><a href="#Unicode-字符集" class="headerlink" title="Unicode 字符集"></a>Unicode 字符集</h4><p>Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。</p>
<p>为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。它们的差别在于使用的字节长度不同。</p>
<ul>
<li>UTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 <code>0x00~0x7F</code>），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。</li>
<li>UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 <code>0x0000~0xFFFF</code>），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。</li>
<li>UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。</li>
</ul>
<h4 id="GBK-字符集"><a href="#GBK-字符集" class="headerlink" title="GBK 字符集"></a>GBK 字符集</h4><p>GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 <code>2^16=65536</code> 种可能的编码，其中大部分被用于表示汉字字符。</p>
<p>GBK 编码是一种变长的编码</p>
<p>GB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等</p>
<p><strong>乱码</strong></p>
<p>当使用不同的编码方式读取或者写入文件时，就会出现乱码问题</p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p><code>java.io.InputStreamReader</code> 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。</li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;沉默王二！&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串按GBK编码方式保存到文件中</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">outUtf8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;logs/test_utf8.txt&quot;</span>, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    outUtf8.write(s);</span><br><span class="line">    outUtf8.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节流转换为字符流，使用GBK编码方式</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;logs/test_utf8.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取字符流</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) c);</span><br><span class="line">    &#125;</span><br><span class="line">    isr.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p><code>java.io.OutputStreamWriter</code> 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。</p>
<ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。</li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>：创建一个指定字符集的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 从文件读取字节流，使用UTF-8编码方式</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 将字节流转换为字符流，使用UTF-8编码方式</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用缓冲流包装字符流，提高读取效率</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建输出流，使用UTF-8编码方式</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 将输出流包装为转换流，使用UTF-8编码方式</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用缓冲流包装转换流，提高写入效率</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取输入文件的每一行，写入到输出文件中</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        bw.write(line);</span><br><span class="line">        bw.newLine(); <span class="comment">// 每行结束后写入一个换行符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    br.close();</span><br><span class="line">    bw.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。</p>
<p>InputStreamReader 类的常用方法包括：</p>
<ul>
<li><code>read()</code>：从输入流中读取一个字符的数据。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。</li>
<li><code>ready()</code>：返回此流是否已准备好读取。</li>
<li><code>close()</code>：关闭输入流。</li>
</ul>
<p>OutputStreamWriter 类的常用方法包括：</p>
<ul>
<li><code>write(int c)</code>：向输出流中写入一个字符的数据。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。</li>
<li><code>flush()</code>：将缓冲区的数据写入输出流中。</li>
<li><code>close()</code>：关闭输出流。</li>
</ul>
<p>在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。</p>
<p>序列化是指将一个对象转换为一个字节序列（包含<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 <a target="_blank" rel="noopener" href="https://javabetter.cn/io/Serializbale.html">Serializable 接口open in new window</a>的对象才能被序列化。</p>
<p>反序列化是指将一个字节序列转换为一个对象，以便在程序中使用</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240123150922126.png" alt="image-20240123150922126"></p>
<h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p><code>java.io.ObjectOutputStream</code> 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。</p>
<p>来看 ObjectOutputStream 的构造方法：<br><code>ObjectOutputStream(OutputStream out)</code></p>
<p>该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br></pre></td></tr></table></figure>

<p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li>该类必须实现<a target="_blank" rel="noopener" href="https://javabetter.cn/io/Serializbale.html"><code>java.io.Serializable</code> 接口open in new window</a>，否则会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用<a target="_blank" rel="noopener" href="https://javabetter.cn/io/transient.html"><code>transient</code> 关键字open in new window</a>进行修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，来聊聊 <code>writeObject (Object obj)</code> 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;沉默王二&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;logs/person.dat&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化。</p>
<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息）。</p>
<p>序列化之前是什么, 序列化后就是什么</p>
<p><code>ObjectInputStream(InputStream in)</code> ： 创建一个指定 InputStream 的 ObjectInputStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;logs/person.dat&quot;</span>; <span class="comment">// 待反序列化的文件名</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">     <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn)) &#123;</span><br><span class="line">     <span class="comment">// 从指定的文件输入流中读取对象并反序列化</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">     <span class="comment">// 将反序列化后的对象强制转换为指定类型</span></span><br><span class="line">     <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">     <span class="comment">// 打印反序列化后的对象信息</span></span><br><span class="line">     System.out.println(<span class="string">&quot;Deserialized Object: &quot;</span> + p);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息。</p>
<h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><h2 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h2><p>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。</p>
<p>序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；<a target="_blank" rel="noopener" href="https://javabetter.cn/io/serialize.html">反序列化open in new window</a>的思想是“解冻”对象状态，重新获得可用的 Java 对象。</p>
<p>序列化有一条规则，就是要序列化的对象必须实现 <code>Serializbale</code> 接口，否则就会报 NotSerializableException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>ObjectOutputStream</code> 将“18 岁的王二”写入到文件当中，实际上就是一种序列化的过程；再通过 <code>ObjectInputStream</code> 将“18 岁的王二”从文件中读出来，实际上就是一种反序列化的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">Wanger</span> <span class="variable">wanger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wanger</span>();</span><br><span class="line">wanger.setName(<span class="string">&quot;王二&quot;</span>);</span><br><span class="line">wanger.setAge(<span class="number">18</span>);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把对象写到文件中</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;chenmo&quot;</span>));)&#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读出对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;chenmo&quot;</span>)));)&#123;</span><br><span class="line">    <span class="type">Wanger</span> <span class="variable">wanger1</span> <span class="operator">=</span> (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>ObjectInputStream</code> 为例，它在反序列化的时候会依次调用 <code>readObject()</code>→<code>readObject0()</code>→<code>readOrdinaryObject()</code>→<code>readSerialData()</code>→<code>defaultReadFields()</code>。</p>
<p><code>ObjectOutputStream</code> 为例，它在序列化的时候会依次调用 <code>writeObject()</code>→<code>writeObject0()</code>→<code>writeOrdinaryObject()</code>→<code>writeSerialData()</code>→<code>invokeWriteObject()</code>→<code>defaultWriteFields()</code>。</p>
<p><code>Serializable</code>只起到一个标识作用, 真正的序列化不由他来完成</p>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p> <code>System.out.println()</code> 的使用频率恐怕不亚于 main 方法的使用频率。其中 <code>System.out</code> 返回的正是打印流 <code>PrintStream</code> 。</p>
<p>除此之外，还有它还有一个孪生兄弟，PrintWriter。</p>
<p>PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，也就是说，一个<a target="_blank" rel="noopener" href="https://javabetter.cn/io/stream.html">字节流open in new window</a>，一个是<a target="_blank" rel="noopener" href="https://javabetter.cn/io/reader-writer.html">字符流open in new window</a>。</p>
<p>打印流具有以下几个特点：</p>
<ul>
<li>可以自动进行数据类型转换：打印流可以将各种数据类型转换为字符串，并输出到指定的输出流中。</li>
<li>可以自动进行换行操作：打印流可以在输出字符串的末尾自动添加换行符，方便输出多个字符串时的格式控制。</li>
<li>可以输出到控制台或者文件中：打印流可以将数据输出到控制台或者文件中，方便调试和日志记录（尽管生产环境下更推荐使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/gongju/logback.html">Logbackopen in new window</a>、ELK 等）。</li>
</ul>
<p>PrintStream 类的常用方法包括：</p>
<ul>
<li><code>print()</code>：输出一个对象的字符串表示形式。</li>
<li><code>println()</code>：输出一个对象的字符串表示形式，并在末尾添加一个换行符。</li>
<li><code>printf()</code>：使用指定的格式字符串和参数输出格式化的字符串。</li>
</ul>
<p>关于printf</p>
<ul>
<li><code>%s</code>：输出一个字符串。</li>
<li><code>%d</code> 或 <code>%i</code>：输出一个十进制整数。</li>
<li><code>%x</code> 或 <code>%X</code>：输出一个十六进制整数，<code>%x</code> 输出小写字母，<code>%X</code> 输出大写字母。</li>
<li><code>%f</code> 或 <code>%F</code>：输出一个浮点数。</li>
<li><code>%e</code> 或 <code>%E</code>：输出一个科学计数法表示的浮点数，<code>%e</code> 输出小写字母 e，<code>%E</code> 输出大写字母 E。</li>
<li><code>%g</code> 或 <code>%G</code>：输出一个浮点数，自动选择 <code>%f</code> 或 <code>%e/%E</code> 格式输出。</li>
<li><code>%c</code>：输出一个字符。</li>
<li><code>%b</code>：输出一个布尔值。</li>
<li><code>%h</code>：输出一个哈希码（16进制）。</li>
<li><code>%n</code>：换行符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">pw.printf(<span class="string">&quot;他的年纪为 %d.\n&quot;</span>, age);</span><br><span class="line">pw.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2><p>从配置文件中</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/QyingliBoost/Photo@main/image-20240122161911353.png" alt="image-20240122161911353"></p>
<h3 id="传统方法读取"><a href="#传统方法读取" class="headerlink" title="传统方法读取"></a>传统方法读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line">    <span class="comment">//分割字符</span></span><br><span class="line">String[] split = line.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((line = br.readLine()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定只获得ip</span></span><br><span class="line">        Stirng [] spilt = line.spilt(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        System.out.println(spilt[<span class="number">0</span>] + <span class="string">&quot;值:&quot;</span> + spilt[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">br.close(</span><br></pre></td></tr></table></figure>

<h3 id="使用properties类"><a href="#使用properties类" class="headerlink" title="使用properties类"></a>使用properties类</h3><ul>
<li><code>load</code>: 加载配置文件的键值对到properties对象</li>
<li><code>list</code>: 将数据显示到指定设备</li>
<li><code>getProperties(key)</code>: 根据键值对到properties对象</li>
<li><code>setProperties(key, value)</code>: 设置键值对到Properties</li>
<li><code>store</code>: 将properties中键值对存储到配置文件, 在idea中, 保存信息到配置文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 Properties 类来读取 mysql.properties 文件</span></span><br><span class="line"><span class="comment">//1. 创建 Properties 对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//2. 加载指定配置文件</span></span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line"><span class="comment">//3. 把 k-v 显示控制台</span></span><br><span class="line">properties.list(System.out);</span><br><span class="line"><span class="comment">//4. 根据 key 获取对应的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;用户名=&quot;</span> + user);</span><br><span class="line">System.out.println(<span class="string">&quot;密码是=&quot;</span> + pwd);</span><br></pre></td></tr></table></figure>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>Share</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="http://blueofwarmth.github.io/2023/12/22/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item email" href="mailto:?subject=Java学习笔记 -第二阶段 - BlueofWarmth&amp;body=http://blueofwarmth.github.io/2023/12/22/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;Copied!&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://blueofwarmth.github.io/2023/12/22/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2024/02/04/Java%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/">Java学习笔记 -第三阶段</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2023/12/04/Java%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/">Java学习笔记 -第一阶段</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">QyingliBoost</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7"><span class="toc-text">第十章 面向对象高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81"><span class="toc-text">类变量和类方法(静态)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-text">访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82"><span class="toc-text">类方法细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-text">main方法语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-text">好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-1"><span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-2"><span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-3"><span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">抽象类实践, 模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-4"><span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">接口和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81"><span class="toc-text">接口多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E4%BC%A0%E9%80%92"><span class="toc-text">接口多态传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">第十一章 枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-text">自定义枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97enum"><span class="toc-text">关键字enum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-5"><span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">enum类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">enum实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Annotation%E4%BB%8B%E7%BB%8D"><span class="toc-text">Annotation介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Override"><span class="toc-text">@Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deprecated"><span class="toc-text">@Deprecated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SuppressWarnings"><span class="toc-text">@SuppressWarnings:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%BC%82%E5%B8%B8-Exception"><span class="toc-text">第十二章 异常(Exception)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">异常体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">常见异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">处理异常的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%EF%BC%88Catch"><span class="toc-text">捕获异常（Catch)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%88Throws%EF%BC%89%E3%80%82"><span class="toc-text">抛出异常（Throws）。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw%E5%92%8Cthrows%E5%8C%BA%E5%88%AB"><span class="toc-text">throw和throws区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">十三章 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-Wrapper"><span class="toc-text">包装类(Wrapper)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">包装类和基本数据类型的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建String对象的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E6%96%B9%E6%B3%95"><span class="toc-text">String 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E7%B1%BB"><span class="toc-text">StringBuffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94String"><span class="toc-text">对比String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-text">构造器和转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">常见方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-text">StringBuilder类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-text">比较和选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-text">Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第一代日期类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BBCalendar"><span class="toc-text">第二代日期类Calendar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">Instant时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="toc-text">更多方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="toc-text">集合体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Set和List的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Collection接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-%E6%96%B9%E6%B3%95"><span class="toc-text">Collection 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="toc-text">增强for</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-List"><span class="toc-text">1. List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-6"><span class="toc-text">细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">vector底层结构和源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EArrayList%E5%AF%B9%E6%AF%94"><span class="toc-text">与ArrayList对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList-%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90"><span class="toc-text">LinkedList 底层剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">操作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8"><span class="toc-text">操作使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%85%83%E7%B4%A0"><span class="toc-text">迭代元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Set"><span class="toc-text">2. Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-HashSet"><span class="toc-text">Set接口实现类: HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet"><span class="toc-text">LinkedHashSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-text">基本信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">常用方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Map"><span class="toc-text">3. Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0"><span class="toc-text">添加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-1"><span class="toc-text">访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Map%E5%B0%8F%E7%BB%93"><span class="toc-text">Hash Map小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable"><span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E9%80%89%E6%8B%A9%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">开发中选择集合实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">常用工具类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">排序操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-text">查找操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-text">第十五章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B"><span class="toc-text">手动设计一个泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">泛型限定符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-text">类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">类型擦除的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">泛型通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4-1"><span class="toc-text">类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">下限通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">上限通配符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">第十六章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="toc-text">程序, 进程, 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process%E4%B8%8EThread"><span class="toc-text">Process与Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">核心概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">线程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">继承Thread类（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现Runnable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">并发问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-text">线程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">停止线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-text">线程休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9"><span class="toc-text">线程礼让</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8F%92%E9%98%9F"><span class="toc-text">线程插队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B"><span class="toc-text">线程状态观测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">守护线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-text">同步原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-7"><span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-text">线程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-text">释放锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E7%AB%A0-IO%E6%B5%81"><span class="toc-text">十七章 IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">流的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">文件流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-text">IO流原理及分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-text">IO流原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86"><span class="toc-text">根据传输方式划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">字节流和字符流的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%92%E5%88%86"><span class="toc-text">操作对象划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81-IO%E6%B5%81%E7%9A%84%E8%B5%B7%E7%82%B9%E4%B8%8E%E7%BB%88%E7%82%B9"><span class="toc-text">文件流: IO流的起点与终点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">创建文件对象相关构造器和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-text">获取文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">判断功能的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4"><span class="toc-text">目录的操作和文件删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">目录的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81-Java-IO%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-text">字节流: Java IO的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88OutputStream%EF%BC%89"><span class="toc-text">字节输出流（OutputStream）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream%E5%92%8COutput%E4%BE%8B%E5%AD%90"><span class="toc-text">FileInputStream和Output例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%BD%E5%8A%A0-%E6%8D%A2%E8%A1%8C"><span class="toc-text">数据追加, 换行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%BC%A0%E5%85%A5%E6%B5%81Reader"><span class="toc-text">字符传入流Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE"><span class="toc-text">读取字符数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81-Writer"><span class="toc-text">字符输出流 Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">FileWriter 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">FileWriter写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%ADclose%E5%92%8C%E5%88%B7%E6%96%B0flush"><span class="toc-text">关闭close和刷新flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter%E7%9A%84%E7%BB%AD%E5%86%99%E5%92%8C%E6%8D%A2%E8%A1%8C"><span class="toc-text">FileWriter的续写和换行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">字节缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E9%AB%98%E6%95%88"><span class="toc-text">缓冲流的高效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89byte-0xFF"><span class="toc-text">4）byte &amp; 0xFF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">字符缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">2）字符缓冲流特有方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ASCII-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">ASCII 字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unicode-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">Unicode 字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GBK-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">GBK 字符集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader"><span class="toc-text">InputStreamReader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStreamWriter"><span class="toc-text">OutputStreamWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectOutputStream"><span class="toc-text">ObjectOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectInputStream"><span class="toc-text">ObjectInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kryo"><span class="toc-text">Kryo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Serializable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">Serializable 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties%E7%B1%BB"><span class="toc-text">Properties类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E8%AF%BB%E5%8F%96"><span class="toc-text">传统方法读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8properties%E7%B1%BB"><span class="toc-text">使用properties类</span></a></li></ol></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>Scroll to Top</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>Join Discussion</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
